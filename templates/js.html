{% extends 'base.html' %}

{% block title %}JavaScript Docs - SN VERSE{% endblock %}

{% block head %}
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.3/purify.min.js"></script>
    <style>
        body {
            background: #f8f9fa;
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            color: #212529;
        }
        .sidebar {
            position: fixed;
            top: 70px;
            left: 0;
            width: 280px;
            height: calc(100vh - 70px);
            background: #343a40;
            border-right: 1px solid #495057;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        .sidebar .nav-link {
            color: #adb5bd;
            padding: 12px 20px;
            border-radius: 0;
            margin: 0;
            transition: all 0.2s ease;
            font-weight: 500;
            border-left: 3px solid transparent;
        }
        .sidebar .nav-link:hover {
            background: #495057;
            color: #fff;
            text-decoration: none;
            border-left-color: #f7df1e;
        }
        .sidebar .nav-link.active {
            background: #f7df1e;
            color: #212529;
            border-left-color: #f7df1e;
        }
        .main-content {
            margin-left: 280px;
            padding: 30px;
            max-width: 1200px;
        }

        .content-card {
            margin-bottom: 30px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            background: #fff;
        }
        .content-card .card-header {
            background: #f7df1e;
            color: #212529;
            font-weight: 600;
            font-size: 1.1rem;
            border-bottom: 1px solid #dee2e6;
            padding: 15px 20px;
            border-radius: 8px 8px 0 0;
        }
        .search-container {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .accordion-button:not(.collapsed) {
            background: #fff9e6;
            color: #f7df1e;
            font-weight: 500;
        }
        .accordion-button {
            border-radius: 0;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        .accordion-button:focus {
            box-shadow: none;
        }
        .badge-note {
            background: #e9ecef;
            color: #495057;
            font-weight: 500;
        }
        .badge-tip {
            background: #fff3cd;
            color: #856404;
            font-weight: 500;
        }
        .btn {
            border-radius: 6px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .copy-button {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .copy-button:hover {
            background: #5a6268;
            transform: scale(1.05);
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Inter', sans-serif;
            color: #212529;
            font-weight: 600;
        }
        .card-body {
            padding: 20px;
        }
        .table {
            margin-bottom: 0;
        }
        .table th {
            background: #f8f9fa;
            font-weight: 600;
            border-top: none;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        code {
            background: #f1f3f4;
            color: #d73a49;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .js-logo {
            color: #f7df1e;
            font-weight: 700;
        }
        .data-type-section {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #f7df1e;
        }
        .method-table {
            width: 100%;
            margin-top: 10px;
            margin-bottom: 15px;
        }
        .method-table th {
            background-color: #e9ecef;
            text-align: left;
            padding: 8px;
        }
        .method-table td {
            padding: 8px;
            border-bottom: 1px solid #dee2e6;
        }
        .console-output {
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            margin: 10px 0;
        }
        .code-result {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 10px;
            margin: 10px 0;
        }
        .code-error {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px;
            margin: 10px 0;
        }
        .interactive-demo {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }
        .interactive-demo button {
            background-color: #f7df1e;
            color: #212529;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            margin-right: 10px;
        }
        .interactive-demo button:hover {
            background-color: #e5ce00;
        }
        .interactive-demo input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
        }
        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }
            .main-content {
                margin-left: 0;
            }
        }
    </style>
    <script>
        hljs.highlightAll();
    </script>
{% endblock %}

{% block content %}
    <!-- Sidebar Navigation -->
    <nav class="sidebar">
        <div class="p-3">
            <h5 class="text-center mb-3" style="font-size: 1.1rem; color: #fff; font-weight: 600;"><i class="fab fa-js-square"></i> <span class="js-logo">JavaScript</span> Documentation</h5>

            <!-- Search Box -->
            <div class="search-container">
                <input type="text" id="search-input" class="form-control" placeholder="Search documentation..." style="background: rgba(255,255,255,0.9); border: 1px solid #495057; color: #212529;">
                <button class="btn btn-sm btn-outline-dark mt-2 w-100" onclick="clearSearch()">Clear Search</button>
            </div>

            <ul class="nav flex-column">
                <li class="nav-item">
                    <a class="nav-link" href="#module1"><i class="fas fa-info-circle"></i> Module 1: Introduction to JavaScript</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module2"><i class="fas fa-code"></i> Module 2: Variables and Data Types</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module3"><i class="fas fa-calculator"></i> Module 3: Operators and Expressions</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module4"><i class="fas fa-sitemap"></i> Module 4: Control Flow and Loops</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module5"><i class="fas fa-cube"></i> Module 5: Functions and Scope</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module6"><i class="fas fa-shapes"></i> Module 6: Objects and Prototypes</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module7"><i class="fas fa-list"></i> Module 7: Arrays and Array Methods</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module8"><i class="fas fa-star"></i> Module 8: ES6+ Features</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module9"><i class="fas fa-sitemap"></i> Module 9: DOM Manipulation</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module10"><i class="fas fa-hand-pointer"></i> Module 10: Event Handling</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module11"><i class="fas fa-sync-alt"></i> Module 11: Asynchronous JavaScript</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module12"><i class="fas fa-bug"></i> Module 12: Error Handling and Debugging</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module13"><i class="fas fa-object-group"></i> Module 13: Classes and OOP</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module14"><i class="fas fa-puzzle-piece"></i> Module 14: Modules and Imports</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module15"><i class="fas fa-project-diagram"></i> Module 15: Data Structures</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module16"><i class="fas fa-chart-line"></i> Module 16: Algorithms</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module17"><i class="fas fa-award"></i> Module 17: JavaScript Best Practices</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module18"><i class="fas fa-rocket"></i> Module 18: Final Project</a>
                </li>
            </ul>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="main-content">
        <div id="content">
            <h1 class="mb-4" style="text-align: center;"><span class="js-logo">JavaScript</span> Documentation</h1>
            <p style="text-align: center; font-size: 1.1rem; color: #6c757d;">Complete guide to JavaScript programming from basics to advanced</p>

            <!-- Module 1: Introduction to JavaScript -->
            <div class="content-card" id="module1">
                <div class="card-header">
                    <i class="fas fa-info-circle"></i> Module 1: Introduction to JavaScript
                </div>
                <div class="card-body">
                    <h5>What is JavaScript?</h5>
                    <p>JavaScript is a high-level, interpreted programming language that conforms to the ECMAScript specification. It's a language that is also characterized as dynamic, weakly typed, prototype-based and multi-paradigm. JavaScript enables interactive web pages and is an essential part of web applications.</p>
                    <p>Alongside HTML and CSS, JavaScript is one of the core technologies of the World Wide Web. JavaScript supports event-driven, functional, and imperative programming styles. It has APIs for working with text, arrays, dates, regular expressions, and the DOM.</p>

                    <h5>History of JavaScript</h5>
                    <p>JavaScript was created by Brendan Eich in 1995 while he was working at Netscape. Originally named Mocha, then LiveScript, it was renamed JavaScript to capitalize on the popularity of Java. Despite the name, JavaScript and Java are entirely different languages.</p>
                    <p>In 1997, JavaScript was standardized as ECMAScript by Ecma International to ensure compatibility across different web browsers. Since then, multiple versions of ECMAScript have been released, with ES6 (ECMAScript 2015) being a major update that introduced many new features.</p>

                    <h5>How JavaScript Works</h5>
                    <p>JavaScript code is typically executed by a JavaScript engine embedded in a web browser. The most common engines include V8 (used in Chrome and Node.js), SpiderMonkey (used in Firefox), and JavaScriptCore (used in Safari).</p>
                    <p>JavaScript engines typically use a Just-In-Time (JIT) compilation approach, where the code is interpreted initially and then compiled to native machine code for better performance. The JavaScript runtime includes a call stack, heap, and a task queue for managing asynchronous operations.</p>

                    <h5>Where JavaScript Runs</h5>
                    <p>JavaScript primarily runs in web browsers, where it can manipulate the DOM, handle events, make network requests, and more. However, with the advent of Node.js, JavaScript can also run on servers, enabling full-stack JavaScript development.</p>
                    <p>JavaScript can also run in other environments like mobile apps (React Native, NativeScript), desktop apps (Electron), and even IoT devices.</p>

                    <h5>JavaScript vs. Other Languages</h5>
                    <p>JavaScript differs from many other programming languages in several ways:</p>
                    <ul>
                        <li><strong>Dynamic Typing:</strong> Variables don't have fixed types, and type checking happens at runtime</li>
                        <li><strong>Prototype-based Inheritance:</strong> Objects inherit directly from other objects, rather than from classes</li>
                        <li><strong>First-class Functions:</strong> Functions can be treated like any other variable</li>
                        <li><strong>Single-threaded with Event Loop:</strong> JavaScript uses a single thread for execution but handles concurrency through an event loop</li>
                    </ul>

                    <h5>JavaScript Ecosystem</h5>
                    <p>The JavaScript ecosystem is vast and includes:</p>
                    <ul>
                        <li><strong>Frameworks:</strong> React, Angular, Vue.js for frontend development</li>
                        <li><strong>Runtime Environments:</strong> Node.js for server-side development</li>
                        <li><strong>Package Managers:</strong> npm and yarn for managing dependencies</li>
                        <li><strong>Build Tools:</strong> Webpack, Rollup, Parcel for bundling code</li>
                        <li><strong>Testing Frameworks:</strong> Jest, Mocha, Jasmine for testing</li>
                    </ul>

                    <h5>Getting Started with JavaScript</h5>
                    <p>You can start writing JavaScript right away in your browser's developer console. For more serious development, you'll want to set up a proper development environment with a code editor like Visual Studio Code and Node.js installed.</p>
                    <p>JavaScript code can be included in HTML files using script tags or in separate .js files that are linked to the HTML.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-html">
<!-- Inline JavaScript -->
&lt;script&gt;
    console.log("Hello, World!");
&lt;/script&gt;

<!-- External JavaScript file -->
&lt;script src="script.js"&gt;&lt;/script&gt;
</code></pre>
                </div>
            </div>

            <!-- Module 2: Variables and Data Types -->
            <div class="content-card" id="module2">
                <div class="card-header">
                    <i class="fas fa-code"></i> Module 2: Variables and Data Types
                </div>
                <div class="card-body">
                    <h5>Variable Declarations</h5>
                    <p>JavaScript provides three ways to declare variables: var, let, and const. Each has different scoping rules and behaviors.</p>
                    
                    <h6>var</h6>
                    <p>var is the traditional way to declare variables in JavaScript. It has function scope (or global scope if declared outside a function) and can be redeclared and reassigned.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
var name = "John"; // Global or function-scoped
var age = 25;

// Can be redeclared
var name = "Jane";

// Can be reassigned
age = 30;
</code></pre>

                    <h6>let</h6>
                    <p>let was introduced in ES6 and has block scope, meaning it's only accessible within the block it's defined in. It can be reassigned but not redeclared within the same scope.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let name = "John"; // Block-scoped
let age = 25;

// Can be reassigned
name = "Jane";

// Cannot be redeclared in the same scope
// let name = "Bob"; // SyntaxError

// Different scopes
if (true) {
    let blockScoped = "I'm inside a block";
}
// console.log(blockScoped); // ReferenceError: blockScoped is not defined
</code></pre>

                    <h6>const</h6>
                    <p>const was also introduced in ES6 and has block scope like let. However, it cannot be reassigned after declaration. For objects and arrays, the reference cannot be changed, but the contents can be modified.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
const PI = 3.14159; // Block-scoped, cannot be reassigned

// PI = 3.14; // TypeError: Assignment to constant variable

// For objects and arrays, the reference is constant
const person = { name: "John", age: 25 };
person.age = 30; // This is allowed
// person = { name: "Jane" }; // This would throw an error

const numbers = [1, 2, 3];
numbers.push(4); // This is allowed
// numbers = [5, 6, 7]; // This would throw an error
</code></pre>

                    <h5>Data Types</h5>
                    <p>JavaScript has two categories of data types: primitive types and reference types.</p>

                    <h6>Primitive Types</h6>
                    <p>Primitive types are immutable and stored directly in the variable's memory location.</p>
                    <ul>
                        <li><strong>Number:</strong> Represents both integer and floating-point numbers</li>
                        <li><strong>String:</strong> Represents sequences of characters</li>
                        <li><strong>Boolean:</strong> Represents logical values: true or false</li>
                        <li><strong>Undefined:</strong> Represents a variable that has been declared but not assigned a value</li>
                        <li><strong>Null:</strong> Represents the intentional absence of any object value</li>
                        <li><strong>Symbol:</strong> Represents a unique identifier (introduced in ES6)</li>
                        <li><strong>BigInt:</strong> Represents integers of arbitrary precision (introduced in ES2020)</li>
                    </ul>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Number
let integer = 42;
let float = 3.14;
let scientific = 1.5e-4; // 0.00015
let hex = 0xFF; // 255
let binary = 0b1010; // 10
let octal = 0o755; // 493

// String
let singleQuotes = 'Hello';
let doubleQuotes = "World";
let template = `Hello, ${singleQuotes}!`; // Template literal

// Boolean
let isTrue = true;
let isFalse = false;

// Undefined
let undefinedVar;
console.log(undefinedVar); // undefined

// Null
let nullVar = null;
console.log(nullVar); // null

// Symbol
let symbol = Symbol('description');
let anotherSymbol = Symbol('description');
console.log(symbol === anotherSymbol); // false, symbols are always unique

// BigInt
let bigInt = 123456789012345678901234567890n;
let anotherBigInt = BigInt(123456789012345678901234567890);
</code></pre>

                    <h6>Reference Types</h6>
                    <p>Reference types are objects stored in memory and accessed by reference.</p>
                    <ul>
                        <li><strong>Object:</strong> A collection of key-value pairs</li>
                        <li><strong>Array:</strong> An ordered collection of values</li>
                        <li><strong>Function:</strong> A reusable block of code</li>
                        <li><strong>Date:</strong> Represents dates and times</li>
                        <li><strong>RegExp:</strong> Represents regular expressions</li>
                        <li><strong>Map:</strong> A collection of key-value pairs with any type of key (ES6)</li>
                        <li><strong>Set:</strong> A collection of unique values (ES6)</li>
                    </ul>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Object
let person = {
    name: "John",
    age: 25,
    greet: function() {
        return `Hello, I'm ${this.name}`;
    }
};

// Array
let fruits = ["apple", "banana", "orange"];
let mixed = [1, "hello", true, null];

// Function
function add(a, b) {
    return a + b;
}

// Date
let now = new Date();
let specificDate = new Date(2023, 0, 1); // January 1, 2023

// RegExp
let pattern = /ab+c/;
let anotherPattern = new RegExp("ab+c");

// Map
let map = new Map();
map.set("name", "John");
map.set(1, "one");

// Set
let set = new Set([1, 2, 3, 3, 4]); // {1, 2, 3, 4}
</code></pre>

                    <h5>Type Conversion</h5>
                    <p>JavaScript can convert between types implicitly (coercion) or explicitly.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Implicit coercion
console.log("5" + 5); // "55" (string concatenation)
console.log("5" - 5); // 0 (numeric subtraction)
console.log("5" * 5); // 25 (numeric multiplication)
console.log(true + 1); // 2
console.log(false + 1); // 1

// Explicit conversion
let str = "123";
let num = Number(str); // 123
let anotherNum = parseInt(str); // 123
let floatNum = parseFloat("123.45"); // 123.45

let bool = Boolean(1); // true
let anotherBool = Boolean(0); // false

let string = String(123); // "123"
let anotherString = 123.toString(); // "123"
</code></pre>

                    <h5>Type Checking</h5>
                    <p>JavaScript provides several ways to check the type of a value.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// typeof operator
console.log(typeof 42); // "number"
console.log(typeof "hello"); // "string"
console.log(typeof true); // "boolean"
console.log(typeof undefined); // "undefined"
console.log(typeof null); // "object" (this is a known bug in JavaScript)
console.log(typeof {}); // "object"
console.log(typeof []); // "object"
console.log(typeof function(){}); // "function"

// Checking for null
function isNull(value) {
    return value === null;
}

// Checking for arrays
Array.isArray([]); // true
Array.isArray({}); // false

// Checking for NaN
Number.isNaN(NaN); // true
Number.isNaN(123); // false

// More precise type checking
function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
}

console.log(getType([])); // "Array"
console.log(getType({})); // "Object"
console.log(getType(null)); // "Null"
console.log(getType(/regex/)); // "RegExp"
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try declaring different types of variables and checking their types:</p>
                        <input type="text" id="variable-value" placeholder="Enter a value">
                        <button onclick="checkVariableType()">Check Type</button>
                        <div id="type-result"></div>
                    </div>
                </div>
            </div>

            <!-- Module 3: Operators and Expressions -->
            <div class="content-card" id="module3">
                <div class="card-header">
                    <i class="fas fa-calculator"></i> Module 3: Operators and Expressions
                </div>
                <div class="card-body">
                    <h5>Arithmetic Operators</h5>
                    <p>Arithmetic operators perform mathematical operations on numbers.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let a = 10, b = 3;

// Addition
console.log(a + b); // 13

// Subtraction
console.log(a - b); // 7

// Multiplication
console.log(a * b); // 30

// Division
console.log(a / b); // 3.333...

// Remainder (Modulus)
console.log(a % b); // 1

// Exponentiation
console.log(a ** b); // 1000 (10^3)

// Increment
let x = 5;
x++; // x is now 6
console.log(x++); // Returns 6, then increments to 7
console.log(++x); // Increments to 8, then returns 8

// Decrement
let y = 5;
y--; // y is now 4
console.log(y--); // Returns 4, then decrements to 3
console.log(--y); // Decrements to 2, then returns 2
</code></pre>

                    <h5>Assignment Operators</h5>
                    <p>Assignment operators assign values to variables.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let x = 10;

// Simple assignment
x = 5;

// Addition assignment
x += 3; // x = x + 3

// Subtraction assignment
x -= 2; // x = x - 2

// Multiplication assignment
x *= 4; // x = x * 4

// Division assignment
x /= 2; // x = x / 2

// Remainder assignment
x %= 3; // x = x % 3

// Exponentiation assignment
x **= 2; // x = x ** 2

// Left shift assignment
x <<= 2; // x = x << 2

// Right shift assignment
x >>= 2; // x = x >> 2

// Unsigned right shift assignment
x >>>= 2; // x = x >>> 2

// Bitwise AND assignment
x &= 3; // x = x & 3

// Bitwise OR assignment
x |= 3; // x = x | 3

// Bitwise XOR assignment
x ^= 3; // x = x ^ 3

// Logical nullish assignment (ES2020)
let user = {};
user.name ??= "Anonymous"; // Only assigns if user.name is null or undefined
</code></pre>

                    <h5>Comparison Operators</h5>
                    <p>Comparison operators compare two values and return a boolean result.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Equality (loose)
console.log(5 == "5"); // true (type coercion)
console.log(0 == false); // true
console.log(null == undefined); // true

// Inequality (loose)
console.log(5 != "5"); // false
console.log(0 != false); // false

// Strict equality
console.log(5 === "5"); // false (different types)
console.log(0 === false); // false

// Strict inequality
console.log(5 !== "5"); // true
console.log(0 !== false); // true

// Greater than
console.log(5 > 3); // true

// Greater than or equal to
console.log(5 >= 5); // true

// Less than
console.log(5 < 3); // false

// Less than or equal to
console.log(5 <= 5); // true
</code></pre>

                    <h5>Logical Operators</h5>
                    <p>Logical operators are used to combine conditional statements.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let a = true, b = false;

// Logical AND (&&)
console.log(a && b); // false
console.log(true && true); // true
console.log(true && false); // false
console.log(false && false); // false

// Short-circuiting with &&
let x = 5;
let y = x > 0 && "Positive"; // "Positive" (x > 0 is true, so the second operand is returned)
let z = x < 0 && "Negative"; // false (x < 0 is false, so false is returned immediately)

// Logical OR (||)
console.log(a || b); // true
console.log(true || true); // true
console.log(true || false); // true
console.log(false || false); // false

// Short-circuiting with ||
let name = null || "Anonymous"; // "Anonymous" (null is falsy, so the second operand is returned)
let age = 25 || 0; // 25 (25 is truthy, so it's returned immediately)

// Logical NOT (!)
console.log(!a); // false
console.log(!b); // true
console.log(!0); // true
console.log(!""); // true
console.log(!null); // true
console.log(!undefined); // true

// Nullish coalescing operator (??) (ES2020)
let user = { name: null, age: 0 };
let userName = user.name ?? "Anonymous"; // "Anonymous" (only null or undefined trigger the default)
let userAge = user.age ?? 18; // 0 (0 is not null or undefined, so it's used)
</code></pre>

                    <h5>Bitwise Operators</h5>
                    <p>Bitwise operators work on 32-bit binary representations of numbers.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Bitwise AND (&)
console.log(5 & 3); // 1 (0101 & 0011 = 0001)

// Bitwise OR (|)
console.log(5 | 3); // 7 (0101 | 0011 = 0111)

// Bitwise XOR (^)
console.log(5 ^ 3); // 6 (0101 ^ 0011 = 0110)

// Bitwise NOT (~)
console.log(~5); // -6 (~0101 = 1010 in two's complement)

// Left shift (<<)
console.log(5 << 2); // 20 (0101 << 2 = 010100)

// Right shift (>>)
console.log(5 >> 2); // 1 (0101 >> 2 = 0001)

// Unsigned right shift (>>>)
console.log(-5 >>> 1); // 2147483645 (fills with zeros instead of the sign bit)
</code></pre>

                    <h5>String Operators</h5>
                    <p>The + operator is used for string concatenation. The += operator can also be used to concatenate strings.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let firstName = "John";
let lastName = "Doe";

// String concatenation
let fullName = firstName + " " + lastName; // "John Doe"

// Concatenation assignment
let greeting = "Hello";
greeting += ", world!"; // "Hello, world!"

// Template literals (ES6)
let message = `Hello, ${firstName} ${lastName}!`; // "Hello, John Doe!"

// String methods
console.log(fullName.length); // 8
console.log(fullName.toUpperCase()); // "JOHN DOE"
console.log(fullName.substring(0, 4)); // "John"
</code></pre>

                    <h5>Ternary Operator</h5>
                    <p>The ternary operator is a shorthand for an if-else statement.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let age = 18;
let canVote = age >= 18 ? "Yes" : "No"; // "Yes"

// Equivalent to:
let canVote2;
if (age >= 18) {
    canVote2 = "Yes";
} else {
    canVote2 = "No";
}

// Nested ternary operators
let score = 85;
let grade = score >= 90 ? "A" : score >= 80 ? "B" : score >= 70 ? "C" : score >= 60 ? "D" : "F"; // "B"
</code></pre>

                    <h5>Operator Precedence</h5>
                    <p>Operator precedence determines the order in which operations are performed. Operators with higher precedence are performed first.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Example of operator precedence
let result = 2 + 3 * 4; // 14 (multiplication has higher precedence than addition)

// Using parentheses to change precedence
let result2 = (2 + 3) * 4; // 20

// Complex expression with multiple operators
let complex = 2 + 3 * 4 ** 2 / (5 - 1); // 2 + 3 * 16 / 4 = 2 + 48 / 4 = 2 + 12 = 14
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try different JavaScript operators:</p>
                        <input type="text" id="operand1" placeholder="First operand">
                        <select id="operator">
                            <option value="+">+</option>
                            <option value="-">-</option>
                            <option value="*">*</option>
                            <option value="/">/</option>
                            <option value="%">%</option>
                            <option value="**">**</option>
                            <option value="==">==</option>
                            <option value="===">===</option>
                            <option value="!=">!=</option>
                            <option value="!==">!==</option>
                            <option value=">">></option>
                            <option value="<"><</option>
                            <option value=">=">>=</option>
                            <option value="<="><=</option>
                        </select>
                        <input type="text" id="operand2" placeholder="Second operand">
                        <button onclick="calculateResult()">Calculate</button>
                        <div id="calculation-result"></div>
                    </div>
                </div>
            </div>

            <!-- Module 4: Control Flow and Loops -->
            <div class="content-card" id="module4">
                <div class="card-header">
                    <i class="fas fa-sitemap"></i> Module 4: Control Flow and Loops
                </div>
                <div class="card-body">
                    <h5>Conditional Statements</h5>
                    <p>Conditional statements allow you to execute different code blocks based on different conditions.</p>

                    <h6>if Statement</h6>
                    <p>The if statement executes a block of code if a specified condition is true.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let age = 18;

if (age >= 18) {
    console.log("You are an adult");
}
</code></pre>

                    <h6>if...else Statement</h6>
                    <p>The if...else statement executes one block of code if a condition is true, and another block if the condition is false.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let age = 16;

if (age >= 18) {
    console.log("You are an adult");
} else {
    console.log("You are a minor");
}
</code></pre>

                    <h6>if...else if...else Statement</h6>
                    <p>The if...else if...else statement allows you to check multiple conditions.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let age = 25;

if (age < 13) {
    console.log("You are a child");
} else if (age < 18) {
    console.log("You are a teenager");
} else if (age < 65) {
    console.log("You are an adult");
} else {
    console.log("You are a senior");
}
</code></pre>

                    <h6>switch Statement</h6>
                    <p>The switch statement evaluates an expression and executes the corresponding case block.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let day = "Monday";

switch (day) {
    case "Monday":
        console.log("Start of the work week");
        break;
    case "Tuesday":
    case "Wednesday":
    case "Thursday":
        console.log("Middle of the work week");
        break;
    case "Friday":
        console.log("End of the work week");
        break;
    case "Saturday":
    case "Sunday":
        console.log("Weekend");
        break;
    default:
        console.log("Invalid day");
}
</code></pre>

                    <h5>Loops</h5>
                    <p>Loops allow you to execute a block of code multiple times.</p>

                    <h6>for Loop</h6>
                    <p>The for loop repeats a block of code a specified number of times.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
for (let i = 0; i < 5; i++) {
    console.log(i); // 0, 1, 2, 3, 4
}

// Looping through an array
let fruits = ["apple", "banana", "orange"];
for (let i = 0; i < fruits.length; i++) {
    console.log(fruits[i]);
}
</code></pre>

                    <h6>while Loop</h6>
                    <p>The while loop repeats a block of code as long as a specified condition is true.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let i = 0;
while (i < 5) {
    console.log(i); // 0, 1, 2, 3, 4
    i++;
}
</code></pre>

                    <h6>do...while Loop</h6>
                    <p>The do...while loop repeats a block of code once, and then repeats as long as a specified condition is true.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let i = 0;
do {
    console.log(i); // 0, 1, 2, 3, 4
    i++;
} while (i < 5);
</code></pre>

                    <h6>for...in Loop</h6>
                    <p>The for...in loop iterates over the properties of an object.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = {
    name: "John",
    age: 25,
    occupation: "Developer"
};

for (let key in person) {
    console.log(key + ": " + person[key]);
}
// Output:
// name: John
// age: 25
// occupation: Developer
</code></pre>

                    <h6>for...of Loop</h6>
                    <p>The for...of loop iterates over iterable objects like arrays, strings, maps, sets, etc.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let fruits = ["apple", "banana", "orange"];

for (let fruit of fruits) {
    console.log(fruit);
}
// Output:
// apple
// banana
// orange

// Iterating over a string
let str = "Hello";
for (let char of str) {
    console.log(char);
}
// Output:
// H
// e
// l
// l
// o
</code></pre>

                    <h5>Loop Control Statements</h5>
                    <p>Loop control statements change the normal execution of a loop.</p>

                    <h6>break Statement</h6>
                    <p>The break statement exits a loop immediately.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        break;
    }
    console.log(i); // 0, 1, 2, 3, 4
}
</code></pre>

                    <h6>continue Statement</h6>
                    <p>The continue statement skips the current iteration of a loop and continues with the next iteration.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        continue;
    }
    console.log(i); // 0, 1, 2, 3, 4, 6, 7, 8, 9
}
</code></pre>

                    <h6>Label Statement</h6>
                    <p>A label can be used with break or continue to control nested loops.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
outerLoop: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (i === 1 && j === 1) {
            break outerLoop; // Breaks out of the outer loop
        }
        console.log(`i: ${i}, j: ${j}`);
    }
}
// Output:
// i: 0, j: 0
// i: 0, j: 1
// i: 0, j: 2
// i: 1, j: 0
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try different control flow structures:</p>
                        <input type="number" id="loop-count" placeholder="Enter a number" value="5">
                        <button onclick="runForLoop()">Run for loop</button>
                        <button onclick="runWhileLoop()">Run while loop</button>
                        <div id="loop-output"></div>
                    </div>
                </div>
            </div>

            <!-- Module 5: Functions and Scope -->
            <div class="content-card" id="module5">
                <div class="card-header">
                    <i class="fas fa-cube"></i> Module 5: Functions and Scope
                </div>
                <div class="card-body">
                    <h5>Function Declarations</h5>
                    <p>Functions are reusable blocks of code that perform specific tasks. JavaScript provides several ways to define functions.</p>

                    <h6>Function Declaration</h6>
                    <p>A function declaration defines a function with the specified parameters.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function greet(name) {
    return "Hello, " + name + "!";
}

console.log(greet("John")); // "Hello, John!"
</code></pre>

                    <h6>Function Expression</h6>
                    <p>A function expression defines a function as part of a larger expression syntax.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
const greet = function(name) {
    return "Hello, " + name + "!";
};

console.log(greet("John")); // "Hello, John!"
</code></pre>

                    <h6>Arrow Function</h6>
                    <p>Arrow functions provide a concise syntax for writing function expressions.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Arrow function with one parameter and one statement
const greet = name => "Hello, " + name + "!";

// Arrow function with multiple parameters
const add = (a, b) => a + b;

// Arrow function with multiple statements
const calculate = (a, b, operation) => {
    let result;
    switch (operation) {
        case "add":
            result = a + b;
            break;
        case "subtract":
            result = a - b;
            break;
        case "multiply":
            result = a * b;
            break;
        case "divide":
            result = a / b;
            break;
        default:
            result = "Invalid operation";
    }
    return result;
};

console.log(greet("John")); // "Hello, John!"
console.log(add(5, 3)); // 8
console.log(calculate(5, 3, "multiply")); // 15
</code></pre>

                    <h6>Immediately Invoked Function Expression (IIFE)</h6>
                    <p>An IIFE is a function that runs as soon as it is defined.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
(function() {
    console.log("This runs immediately!");
})();

// IIFE with parameters
(function(name) {
    console.log("Hello, " + name + "!");
})("John");
</code></pre>

                    <h5>Function Parameters</h5>
                    <p>Functions can take parameters, which are values passed into the function.</p>

                    <h6>Default Parameters</h6>
                    <p>Default parameters allow named parameters to be initialized with default values if no value or undefined is passed.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function greet(name = "Guest") {
    return "Hello, " + name + "!";
}

console.log(greet()); // "Hello, Guest!"
console.log(greet("John")); // "Hello, John!"
</code></pre>

                    <h6>Rest Parameters</h6>
                    <p>Rest parameters allow an indefinite number of arguments as an array.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3)); // 6
console.log(sum(1, 2, 3, 4, 5)); // 15
</code></pre>

                    <h6>Arguments Object</h6>
                    <p>The arguments object is an array-like object containing the values of the arguments passed to a function.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function sum() {
    let total = 0;
    for (let i = 0; i < arguments.length; i++) {
        total += arguments[i];
    }
    return total;
}

console.log(sum(1, 2, 3)); // 6
console.log(sum(1, 2, 3, 4, 5)); // 15
</code></pre>

                    <h5>Function Scope</h5>
                    <p>Scope determines the accessibility of variables, functions, and objects in different parts of the code.</p>

                    <h6>Global Scope</h6>
                    <p>Variables declared outside of any function have global scope and can be accessed from anywhere in the code.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
var globalVar = "I'm global";

function showGlobal() {
    console.log(globalVar); // "I'm global"
}

showGlobal();
console.log(globalVar); // "I'm global"
</code></pre>

                    <h6>Function Scope</h6>
                    <p>Variables declared inside a function have function scope and can only be accessed within that function.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function showScope() {
    var localVar = "I'm local";
    console.log(localVar); // "I'm local"
}

showScope();
// console.log(localVar); // ReferenceError: localVar is not defined
</code></pre>

                    <h6>Block Scope</h6>
                    <p>Variables declared with let and const have block scope, meaning they are only accessible within the block they are defined in.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function showBlockScope() {
    if (true) {
        let blockVar = "I'm block-scoped";
        console.log(blockVar); // "I'm block-scoped"
    }
    // console.log(blockVar); // ReferenceError: blockVar is not defined
}

showBlockScope();
</code></pre>

                    <h5>Closures</h5>
                    <p>A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function outerFunction(x) {
    // Outer function variable
    return function(y) {
        // Inner function has access to x
        return x + y;
    };
}

const addFive = outerFunction(5);
console.log(addFive(3)); // 8

// Practical example: counter
function createCounter() {
    let count = 0;
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
console.log(counter.decrement()); // 1
</code></pre>

                    <h5>Higher-Order Functions</h5>
                    <p>Higher-order functions are functions that take other functions as arguments or return functions.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Function that takes another function as an argument
function calculate(operation, a, b) {
    return operation(a, b);
}

function add(a, b) {
    return a + b;
}

function multiply(a, b) {
    return a * b;
}

console.log(calculate(add, 5, 3)); // 8
console.log(calculate(multiply, 5, 3)); // 15

// Function that returns another function
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
</code></pre>

                    <h5>Recursive Functions</h5>
                    <p>Recursive functions call themselves to solve problems by breaking them down into smaller subproblems.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Factorial using recursion
function factorial(n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

console.log(factorial(5)); // 120

// Fibonacci using recursion
function fibonacci(n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(10)); // 55
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try defining and calling a function:</p>
                        <input type="text" id="function-param" placeholder="Enter a parameter">
                        <button onclick="callCustomFunction()">Call Function</button>
                        <div id="function-result"></div>
                    </div>
                </div>
            </div>

            <!-- Module 6: Objects and Prototypes -->
            <div class="content-card" id="module6">
                <div class="card-header">
                    <i class="fas fa-shapes"></i> Module 6: Objects and Prototypes
                </div>
                <div class="card-body">
                    <h5>Creating Objects</h5>
                    <p>Objects are collections of key-value pairs. JavaScript provides several ways to create objects.</p>

                    <h6>Object Literal</h6>
                    <p>The simplest way to create an object is using an object literal.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = {
    name: "John",
    age: 25,
    greet: function() {
        return "Hello, I'm " + this.name;
    }
};

console.log(person.name); // "John"
console.log(person.greet()); // "Hello, I'm John"
</code></pre>

                    <h6>Object Constructor</h6>
                    <p>The Object constructor creates an empty object that can be populated with properties.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = new Object();
person.name = "John";
person.age = 25;
person.greet = function() {
    return "Hello, I'm " + this.name;
};

console.log(person.name); // "John"
console.log(person.greet()); // "Hello, I'm John"
</code></pre>

                    <h6>Constructor Function</h6>
                    <p>A constructor function is used to create multiple objects of the same type.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.greet = function() {
        return "Hello, I'm " + this.name;
    };
}

let person1 = new Person("John", 25);
let person2 = new Person("Jane", 30);

console.log(person1.name); // "John"
console.log(person2.name); // "Jane"
console.log(person1.greet()); // "Hello, I'm John"
</code></pre>

                    <h6>Object.create Method</h6>
                    <p>The Object.create method creates a new object with the specified prototype object.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let personProto = {
    greet: function() {
        return "Hello, I'm " + this.name;
    }
};

let person = Object.create(personProto);
person.name = "John";
person.age = 25;

console.log(person.name); // "John"
console.log(person.greet()); // "Hello, I'm John"
</code></pre>

                    <h6>ES6 Class</h6>
                    <p>ES6 introduced class syntax for creating objects, which is syntactic sugar over JavaScript's prototype-based inheritance.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        return "Hello, I'm " + this.name;
    }
}

let person = new Person("John", 25);
console.log(person.name); // "John"
console.log(person.greet()); // "Hello, I'm John"
</code></pre>

                    <h5>Object Properties</h5>
                    <p>Object properties are key-value pairs associated with an object.</p>

                    <h6>Accessing Properties</h6>
                    <p>Properties can be accessed using dot notation or bracket notation.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = {
    name: "John",
    age: 25
};

// Dot notation
console.log(person.name); // "John"

// Bracket notation
console.log(person["age"]); // 25

// Bracket notation with variable
let property = "name";
console.log(person[property]); // "John"
</code></pre>

                    <h6>Adding and Modifying Properties</h6>
                    <p>Properties can be added or modified using dot notation or bracket notation.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = {
    name: "John",
    age: 25
};

// Adding a property
person.email = "john@example.com";

// Modifying a property
person.age = 26;

// Using bracket notation
person["city"] = "New York";
person["age"] = 27;

console.log(person);
// {
//   name: "John",
//   age: 27,
//   email: "john@example.com",
//   city: "New York"
// }
</code></pre>

                    <h6>Deleting Properties</h6>
                    <p>The delete operator removes a property from an object.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = {
    name: "John",
    age: 25,
    email: "john@example.com"
};

delete person.email;
console.log(person.email); // undefined
console.log("email" in person); // false
</code></pre>

                    <h6>Property Descriptors</h6>
                    <p>Property descriptors provide information about a property and can be used to define new properties with specific attributes.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = {};

// Define a property with descriptors
Object.defineProperty(person, "name", {
    value: "John",
    writable: false, // Cannot be changed
    enumerable: true, // Will show up in for...in loops
    configurable: false // Cannot be deleted or reconfigured
});

console.log(person.name); // "John"
person.name = "Jane"; // Won't change because writable is false
console.log(person.name); // "John"

// Get property descriptor
let descriptor = Object.getOwnPropertyDescriptor(person, "name");
console.log(descriptor);
// {
//   value: "John",
//   writable: false,
//   enumerable: true,
//   configurable: false
// }

// Define multiple properties
Object.defineProperties(person, {
    age: {
        value: 25,
        writable: true,
        enumerable: true,
        configurable: true
    },
    email: {
        value: "john@example.com",
        writable: true,
        enumerable: true,
        configurable: true
    }
});
</code></pre>

                    <h5>Object Methods</h5>
                    <p>JavaScript provides several built-in methods for working with objects.</p>

                    <h6>Object.keys</h6>
                    <p>The Object.keys method returns an array of a given object's own enumerable property names.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = {
    name: "John",
    age: 25,
    email: "john@example.com"
};

let keys = Object.keys(person);
console.log(keys); // ["name", "age", "email"]
</code></pre>

                    <h6>Object.values</h6>
                    <p>The Object.values method returns an array of a given object's own enumerable property values.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = {
    name: "John",
    age: 25,
    email: "john@example.com"
};

let values = Object.values(person);
console.log(values); // ["John", 25, "john@example.com"]
</code></pre>

                    <h6>Object.entries</h6>
                    <p>The Object.entries method returns an array of a given object's own enumerable string-keyed property [key, value] pairs.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = {
    name: "John",
    age: 25,
    email: "john@example.com"
};

let entries = Object.entries(person);
console.log(entries);
// [
//   ["name", "John"],
//   ["age", 25],
//   ["email", "john@example.com"]
// ]
</code></pre>

                    <h6>Object.assign</h6>
                    <p>The Object.assign method copies all enumerable own properties from one or more source objects to a target object.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let target = { a: 1, b: 2 };
let source = { b: 3, c: 4 };

let result = Object.assign(target, source);
console.log(result); // { a: 1, b: 3, c: 4 }

// Creating a new object
let person = { name: "John" };
let details = { age: 25, email: "john@example.com" };
let fullPerson = Object.assign({}, person, details);
console.log(fullPerson); // { name: "John", age: 25, email: "john@example.com" }
</code></pre>

                    <h5>Prototypes and Inheritance</h5>
                    <p>JavaScript uses prototypal inheritance, where objects can inherit properties from other objects.</p>

                    <h6>Prototype Chain</h6>
                    <p>Every object has a prototype, which is another object from which it inherits properties.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    return "Hello, I'm " + this.name;
};

let person = new Person("John", 25);
console.log(person.greet()); // "Hello, I'm John"

// Checking prototype
console.log(Object.getPrototypeOf(person) === Person.prototype); // true
console.log(person.__proto__ === Person.prototype); // true
</code></pre>

                    <h6>Prototype Inheritance</h6>
                    <p>Objects can inherit from other objects through the prototype chain.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    return "Hello, I'm " + this.name;
};

function Student(name, age, grade) {
    Person.call(this, name, age); // Call the parent constructor
    this.grade = grade;
}

// Inherit from Person
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

// Override the greet method
Student.prototype.greet = function() {
    return Person.prototype.greet.call(this) + " and I'm a student in grade " + this.grade;
};

let student = new Student("John", 15, 10);
console.log(student.greet()); // "Hello, I'm John and I'm a student in grade 10"
</code></pre>

                    <h5>Object Destructuring</h5>
                    <p>Object destructuring allows you to extract properties from objects into distinct variables.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = {
    name: "John",
    age: 25,
    email: "john@example.com"
};

// Basic destructuring
let { name, age } = person;
console.log(name); // "John"
console.log(age); // 25

// Destructuring with different variable names
let { name: personName, age: personAge } = person;
console.log(personName); // "John"
console.log(personAge); // 25

// Destructuring with default values
let { name, city = "Unknown" } = person;
console.log(name); // "John"
console.log(city); // "Unknown"

// Destructuring nested objects
let user = {
    profile: {
        name: "John",
        age: 25
    },
    contact: {
        email: "john@example.com",
        phone: "123-456-7890"
    }
};

let { profile: { name, age }, contact: { email } } = user;
console.log(name); // "John"
console.log(age); // 25
console.log(email); // "john@example.com"
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try creating and manipulating an object:</p>
                        <input type="text" id="object-key" placeholder="Enter a key">
                        <input type="text" id="object-value" placeholder="Enter a value">
                        <button onclick="addObjectProperty()">Add Property</button>
                        <button onclick="showObject()">Show Object</button>
                        <div id="object-display"></div>
                    </div>
                </div>
            </div>

            <!-- Module 7: Arrays and Array Methods -->
            <div class="content-card" id="module7">
                <div class="card-header">
                    <i class="fas fa-list"></i> Module 7: Arrays and Array Methods
                </div>
                <div class="card-body">
                    <h5>Creating Arrays</h5>
                    <p>Arrays are ordered collections of values. JavaScript provides several ways to create arrays.</p>

                    <h6>Array Literal</h6>
                    <p>The simplest way to create an array is using an array literal.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let fruits = ["apple", "banana", "orange"];
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "hello", true, null, undefined];
let empty = [];
</code></pre>

                    <h6>Array Constructor</h6>
                    <p>The Array constructor creates an array with the specified elements.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let fruits = new Array("apple", "banana", "orange");
let numbers = new Array(1, 2, 3, 4, 5);

// Creating an array with a specific length
let empty = new Array(5); // Creates an array with 5 empty slots
console.log(empty.length); // 5
</code></pre>

                    <h6>Array.from Method</h6>
                    <p>The Array.from method creates a new array from an array-like or iterable object.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Create an array from a string
let str = "hello";
let chars = Array.from(str);
console.log(chars); // ["h", "e", "l", "l", "o"]

// Create an array with a mapping function
let numbers = Array.from({length: 5}, (value, index) => index + 1);
console.log(numbers); // [1, 2, 3, 4, 5]
</code></pre>

                    <h6>Array.of Method</h6>
                    <p>The Array.of method creates a new array with the provided arguments, regardless of the number or type of arguments.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let numbers = Array.of(1, 2, 3, 4, 5);
console.log(numbers); // [1, 2, 3, 4, 5]

// Unlike the Array constructor, Array.of always creates an array with the provided elements
let single = Array.of(5);
console.log(single); // [5]

let withConstructor = new Array(5);
console.log(withConstructor); // [empty × 5]
</code></pre>

                    <h5>Accessing Array Elements</h5>
                    <p>Array elements can be accessed using their index, which starts at 0.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let fruits = ["apple", "banana", "orange"];

// Accessing elements
console.log(fruits[0]); // "apple"
console.log(fruits[1]); // "banana"
console.log(fruits[2]); // "orange"

// Accessing the last element
console.log(fruits[fruits.length - 1]); // "orange"

// Accessing elements that don't exist
console.log(fruits[3]); // undefined
</code></pre>

                    <h5>Modifying Arrays</h5>
                    <p>Arrays can be modified by adding, removing, or changing elements.</p>

                    <h6>Adding Elements</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let fruits = ["apple", "banana", "orange"];

// Adding to the end
fruits.push("grape");
console.log(fruits); // ["apple", "banana", "orange", "grape"]

// Adding to the beginning
fruits.unshift("strawberry");
console.log(fruits); // ["strawberry", "apple", "banana", "orange", "grape"]

// Adding at a specific position
fruits.splice(2, 0, "kiwi");
console.log(fruits); // ["strawberry", "apple", "kiwi", "banana", "orange", "grape"]
</code></pre>

                    <h6>Removing Elements</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let fruits = ["strawberry", "apple", "kiwi", "banana", "orange", "grape"];

// Removing from the end
let last = fruits.pop();
console.log(last); // "grape"
console.log(fruits); // ["strawberry", "apple", "kiwi", "banana", "orange"]

// Removing from the beginning
let first = fruits.shift();
console.log(first); // "strawberry"
console.log(fruits); // ["apple", "kiwi", "banana", "orange"]

// Removing from a specific position
let removed = fruits.splice(1, 1);
console.log(removed); // ["kiwi"]
console.log(fruits); // ["apple", "banana", "orange"]
</code></pre>

                    <h6>Changing Elements</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let fruits = ["apple", "banana", "orange"];

// Changing an element
fruits[1] = "kiwi";
console.log(fruits); // ["apple", "kiwi", "orange"]

// Changing multiple elements
fruits.splice(1, 2, "grape", "strawberry");
console.log(fruits); // ["apple", "grape", "strawberry"]
</code></pre>

                    <h5>Array Methods</h5>
                    <p>JavaScript provides many built-in methods for working with arrays.</p>

                    <h6>Iteration Methods</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let numbers = [1, 2, 3, 4, 5];

// forEach - executes a function for each array element
numbers.forEach(num => console.log(num));
// Output:
// 1
// 2
// 3
// 4
// 5

// map - creates a new array with the result of calling a function for each array element
let doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// filter - creates a new array with all elements that pass a test
let evens = numbers.filter(num => num % 2 === 0);
console.log(evens); // [2, 4]

// reduce - reduces the array to a single value
let sum = numbers.reduce((total, num) => total + num, 0);
console.log(sum); // 15

// find - returns the first element that satisfies a test
let found = numbers.find(num => num > 3);
console.log(found); // 4

// findIndex - returns the index of the first element that satisfies a test
let index = numbers.findIndex(num => num > 3);
console.log(index); // 3

// some - checks if at least one element satisfies a test
let hasEven = numbers.some(num => num % 2 === 0);
console.log(hasEven); // true

// every - checks if all elements satisfy a test
let allPositive = numbers.every(num => num > 0);
console.log(allPositive); // true
</code></pre>

                    <h6>Transformation Methods</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let numbers = [1, 2, 3, 4, 5];

// concat - merges two or more arrays
let moreNumbers = [6, 7, 8];
let allNumbers = numbers.concat(moreNumbers);
console.log(allNumbers); // [1, 2, 3, 4, 5, 6, 7, 8]

// slice - extracts a section of an array and returns a new array
let sliced = numbers.slice(1, 4);
console.log(sliced); // [2, 3, 4]

// splice - adds or removes elements from an array
let spliced = [...numbers];
spliced.splice(1, 2, 10, 20);
console.log(spliced); // [1, 10, 20, 4, 5]

// join - joins all elements of an array into a string
let joined = numbers.join("-");
console.log(joined); // "1-2-3-4-5"

// reverse - reverses the order of the elements in an array
let reversed = [...numbers].reverse();
console.log(reversed); // [5, 4, 3, 2, 1]

// sort - sorts the elements of an array
let unsorted = [3, 1, 4, 1, 5, 9, 2, 6];
let sorted = [...unsorted].sort();
console.log(sorted); // [1, 1, 2, 3, 4, 5, 6, 9]

// Custom sort
let numbersToSort = [10, 5, 40, 25];
let customSorted = [...numbersToSort].sort((a, b) => a - b);
console.log(customSorted); // [5, 10, 25, 40]
</code></pre>

                    <h6>Search Methods</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let fruits = ["apple", "banana", "orange", "grape"];

// indexOf - returns the first index at which a given element can be found
console.log(fruits.indexOf("orange")); // 2
console.log(fruits.indexOf("pear")); // -1 (not found)

// lastIndexOf - returns the last index at which a given element can be found
let duplicated = ["apple", "banana", "apple", "orange"];
console.log(duplicated.lastIndexOf("apple")); // 2

// includes - determines whether an array includes a certain value
console.log(fruits.includes("orange")); // true
console.log(fruits.includes("pear")); // false
</code></pre>

                    <h5>Array Destructuring</h5>
                    <p>Array destructuring allows you to extract values from arrays into distinct variables.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let fruits = ["apple", "banana", "orange", "grape"];

// Basic destructuring
let [first, second, third] = fruits;
console.log(first); // "apple"
console.log(second); // "banana"
console.log(third); // "orange"

// Skipping elements
let [first, , third] = fruits;
console.log(first); // "apple"
console.log(third); // "orange"

// Using rest operator
let [first, ...rest] = fruits;
console.log(first); // "apple"
console.log(rest); // ["banana", "orange", "grape"]

// Setting default values
let [first, second, third, fourth, fifth = "pear"] = fruits;
console.log(fifth); // "pear"

// Swapping variables
let a = 1, b = 2;
[a, b] = [b, a];
console.log(a); // 2
console.log(b); // 1
</code></pre>

                    <h5>Spread Operator with Arrays</h5>
                    <p>The spread operator (...) allows an iterable to be expanded in places where zero or more arguments or elements are expected.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Creating a new array with additional elements
let fruits = ["apple", "banana", "orange"];
let moreFruits = [...fruits, "grape", "strawberry"];
console.log(moreFruits); // ["apple", "banana", "orange", "grape", "strawberry"]

// Combining arrays
let vegetables = ["carrot", "broccoli"];
let food = [...fruits, ...vegetables];
console.log(food); // ["apple", "banana", "orange", "carrot", "broccoli"]

// Copying an array
let fruitsCopy = [...fruits];
console.log(fruitsCopy); // ["apple", "banana", "orange"]

// Converting a NodeList to an array
let divs = document.querySelectorAll("div");
let divsArray = [...divs];

// Using with function arguments
function sum(a, b, c) {
    return a + b + c;
}
let numbers = [1, 2, 3];
console.log(sum(...numbers)); // 6
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try different array methods:</p>
                        <input type="text" id="array-input" placeholder="Enter comma-separated values">
                        <button onclick="createArray()">Create Array</button>
                        <button onclick="sortArray()">Sort</button>
                        <button onclick="reverseArray()">Reverse</button>
                        <button onclick="filterArray()">Filter Even Numbers</button>
                        <div id="array-result"></div>
                    </div>
                </div>
            </div>

            <!-- Module 8: ES6+ Features -->
            <div class="content-card" id="module8">
                <div class="card-header">
                    <i class="fas fa-star"></i> Module 8: ES6+ Features
                </div>
                <div class="card-body">
                    <h5>Introduction to ES6+</h5>
                    <p>ES6 (ECMAScript 2015) and later versions introduced many new features to JavaScript, making the language more powerful and easier to work with. These features include new syntax, new methods, and improvements to existing functionality.</p>

                    <h5>let and const</h5>
                    <p>ES6 introduced two new ways to declare variables: let and const. Both have block scope, unlike var which has function scope.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// let - can be reassigned
let name = "John";
name = "Jane";
console.log(name); // "Jane"

// const - cannot be reassigned
const PI = 3.14159;
// PI = 3.14; // TypeError: Assignment to constant variable

// Block scope
if (true) {
    let blockScoped = "I'm block-scoped";
    const constBlockScoped = "I'm also block-scoped";
}
// console.log(blockScoped); // ReferenceError: blockScoped is not defined
// console.log(constBlockScoped); // ReferenceError: constBlockScoped is not defined
</code></pre>

                    <h5>Arrow Functions</h5>
                    <p>Arrow functions provide a concise syntax for writing function expressions. They also have lexical this binding, which means they inherit this from the enclosing scope.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Traditional function
function add(a, b) {
    return a + b;
}

// Arrow function
const addArrow = (a, b) => a + b;

// Arrow function with one parameter
const greet = name => `Hello, ${name}!`;

// Arrow function with multiple statements
const calculate = (a, b, operation) => {
    let result;
    switch (operation) {
        case "add":
            result = a + b;
            break;
        case "subtract":
            result = a - b;
            break;
        default:
            result = "Invalid operation";
    }
    return result;
};

// Lexical this binding
function Person() {
    this.age = 0;
    
    // Traditional function - this refers to the global object or undefined in strict mode
    setInterval(function() {
        // this.age++; // This won't work as expected
    }, 1000);
    
    // Arrow function - this refers to the Person instance
    setInterval(() => {
        this.age++;
    }, 1000);
}
</code></pre>

                    <h5>Template Literals</h5>
                    <p>Template literals are string literals allowing embedded expressions. They are enclosed by backticks (`) instead of single or double quotes.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Traditional string concatenation
let name = "John";
let age = 25;
let message = "My name is " + name + " and I am " + age + " years old.";

// Template literal
let templateMessage = `My name is ${name} and I am ${age} years old.`;

// Multi-line strings
let multiLine = `This is a
multi-line
string.`;

// Expressions in template literals
let price = 19.99;
let tax = 0.07;
let total = `Total: $${(price * (1 + tax)).toFixed(2)}`;
console.log(total); // "Total: $21.39"
</code></pre>

                    <h5>Destructuring</h5>
                    <p>Destructuring allows you to extract values from arrays or objects into distinct variables.</p>

                    <h6>Array Destructuring</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let fruits = ["apple", "banana", "orange", "grape"];

// Basic destructuring
let [first, second, third] = fruits;
console.log(first); // "apple"
console.log(second); // "banana"
console.log(third); // "orange"

// Skipping elements
let [first, , third] = fruits;
console.log(first); // "apple"
console.log(third); // "orange"

// Using rest operator
let [first, ...rest] = fruits;
console.log(first); // "apple"
console.log(rest); // ["banana", "orange", "grape"]

// Setting default values
let [first, second, third, fourth, fifth = "pear"] = fruits;
console.log(fifth); // "pear"
</code></pre>

                    <h6>Object Destructuring</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
let person = {
    name: "John",
    age: 25,
    email: "john@example.com"
};

// Basic destructuring
let { name, age } = person;
console.log(name); // "John"
console.log(age); // 25

// Destructuring with different variable names
let { name: personName, age: personAge } = person;
console.log(personName); // "John"
console.log(personAge); // 25

// Destructuring with default values
let { name, city = "Unknown" } = person;
console.log(name); // "John"
console.log(city); // "Unknown"

// Destructuring nested objects
let user = {
    profile: {
        name: "John",
        age: 25
    },
    contact: {
        email: "john@example.com",
        phone: "123-456-7890"
    }
};

let { profile: { name, age }, contact: { email } } = user;
console.log(name); // "John"
console.log(age); // 25
console.log(email); // "john@example.com"
</code></pre>

                    <h5>Default Parameters</h5>
                    <p>Default parameters allow named parameters to be initialized with default values if no value or undefined is passed.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Traditional way to set default values
function greet(name) {
    name = name || "Guest";
    return "Hello, " + name + "!";
}

// With default parameters
function greetWithDefault(name = "Guest") {
    return `Hello, ${name}!`;
}

console.log(greetWithDefault()); // "Hello, Guest!"
console.log(greetWithDefault("John")); // "Hello, John!"

// Default parameters with expressions
function createBooking(flightNumber, passengers = 1, price = 199 * passengers) {
    return {
        flightNumber,
        passengers,
        price
    };
}

console.log(createBooking("LH123")); // { flightNumber: "LH123", passengers: 1, price: 199 }
console.log(createBooking("LH123", 2)); // { flightNumber: "LH123", passengers: 2, price: 398 }
</code></pre>

                    <h5>Rest and Spread Operators</h5>
                    <p>The rest and spread operators both use the same syntax (...) but have different uses.</p>

                    <h6>Rest Parameters</h6>
                    <p>Rest parameters allow an indefinite number of arguments as an array.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Traditional way using arguments object
function sum() {
    let total = 0;
    for (let i = 0; i < arguments.length; i++) {
        total += arguments[i];
    }
    return total;
}

// With rest parameters
function sumWithRest(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sumWithRest(1, 2, 3)); // 6
console.log(sumWithRest(1, 2, 3, 4, 5)); // 15

// Rest parameter must be the last parameter
function createPerson(name, ...details) {
    return {
        name,
        details
    };
}

console.log(createPerson("John", 25, "Developer", "New York"));
// { name: "John", details: [25, "Developer", "New York"] }
</code></pre>

                    <h6>Spread Operator</h6>
                    <p>The spread operator allows an iterable to be expanded in places where zero or more arguments or elements are expected.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Spreading arrays
let fruits = ["apple", "banana", "orange"];
let moreFruits = [...fruits, "grape", "strawberry"];
console.log(moreFruits); // ["apple", "banana", "orange", "grape", "strawberry"]

// Combining arrays
let vegetables = ["carrot", "broccoli"];
let food = [...fruits, ...vegetables];
console.log(food); // ["apple", "banana", "orange", "carrot", "broccoli"]

// Copying an array
let fruitsCopy = [...fruits];
console.log(fruitsCopy); // ["apple", "banana", "orange"]

// Spreading objects
let person = {
    name: "John",
    age: 25
};

let personWithJob = {
    ...person,
    job: "Developer"
};
console.log(personWithJob); // { name: "John", age: 25, job: "Developer" }

// Overriding properties with spread
let updatedPerson = {
    ...person,
    age: 26
};
console.log(updatedPerson); // { name: "John", age: 26 }

// Using with function arguments
function sum(a, b, c) {
    return a + b + c;
}
let numbers = [1, 2, 3];
console.log(sum(...numbers)); // 6
</code></pre>

                    <h5>Enhanced Object Literals</h5>
                    <p>ES6 introduced several enhancements to object literals.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Property shorthand
let name = "John";
let age = 25;

// Traditional way
let person = {
    name: name,
    age: age,
    greet: function() {
        return `Hello, I'm ${this.name}`;
    }
};

// Enhanced object literal
let enhancedPerson = {
    name, // Property shorthand
    age,  // Property shorthand
    greet() { // Method shorthand
        return `Hello, I'm ${this.name}`;
    }
};

// Computed property names
let prop = "name";
let computedPerson = {
    [prop]: "John", // Computed property name
    ["age"]: 25,    // Computed property name
    ["greet" + "ing"]() { // Computed method name
        return `Hello, I'm ${this.name}`;
    }
};

console.log(computedPerson.name); // "John"
console.log(computedPerson.greeting()); // "Hello, I'm John"
</code></pre>

                    <h5>Classes</h5>
                    <p>ES6 introduced class syntax for creating objects, which is syntactic sugar over JavaScript's prototype-based inheritance.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Class declaration
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // Instance method
    greet() {
        return `Hello, I'm ${this.name}`;
    }
    
    // Getter
    get info() {
        return `${this.name} is ${this.age} years old`;
    }
    
    // Setter
    set age(newAge) {
        if (newAge > 0) {
            this._age = newAge;
        }
    }
    
    get age() {
        return this._age;
    }
    
    // Static method
    static species() {
        return "Homo sapiens";
    }
}

// Inheritance
class Student extends Person {
    constructor(name, age, grade) {
        super(name, age); // Call parent constructor
        this.grade = grade;
    }
    
    // Override method
    greet() {
        return `${super.greet()} and I'm a student in grade ${this.grade}`;
    }
    
    // New method
    study() {
        return `${this.name} is studying`;
    }
}

// Creating instances
let person = new Person("John", 25);
let student = new Student("Jane", 20, "A");

// Using instances
console.log(person.greet()); // "Hello, I'm John"
console.log(student.greet()); // "Hello, I'm Jane and I'm a student in grade A"
console.log(student.study()); // "Jane is studying"
console.log(Person.species()); // "Homo sapiens"
</code></pre>

                    <h5>Modules</h5>
                    <p>ES6 introduced a standardized module system for JavaScript, allowing you to export and import functionality between different files.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// math.js - Named exports
export const PI = 3.14159;
export function add(a, b) {
    return a + b;
}
export function multiply(a, b) {
    return a * b;
}

// utils.js - Default export
export default function formatDate(date) {
    return date.toLocaleDateString();
}

// main.js - Importing
import { PI, add, multiply } from './math.js';
import formatDate from './utils.js';

// Using imports
console.log(PI);
console.log(add(5, 3));
console.log(formatDate(new Date()));

// Import all as namespace
import * as math from './math.js';
console.log(math.multiply(4, 5));

// Dynamic import
async function loadModule() {
    const module = await import('./math.js');
    console.log(module.add(2, 3));
}

// Re-exporting
export { add, multiply } from './math.js';
export { default as formatDate } from './utils.js';
</code></pre>

                    <h5>Promises and Async/Await</h5>
                    <p>ES6 introduced Promises for handling asynchronous operations, and ES2017 introduced async/await syntax for working with Promises.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Creating a Promise
const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Success!");
        // reject("Error!");
    }, 1000);
});

// Using a Promise
promise
    .then(data => console.log(data))
    .catch(error => console.error(error))
    .finally(() => console.log("Cleanup"));

// Promise methods
Promise.all([promise1, promise2])
    .then(results => console.log(results));

Promise.race([promise1, promise2])
    .then(result => console.log(result));

// Async/Await
async function fetchData() {
    try {
        let data = await promise;
        console.log(data);
        return data;
    } catch (error) {
        console.error(error);
    }
}

// Parallel async operations
async function fetchMultiple() {
    let [data1, data2] = await Promise.all([
        fetchData1(),
        fetchData2()
    ]);
    return { data1, data2 };
}
</code></pre>

                    <h5>Other ES6+ Features</h5>
                    <p>ES6 and later versions introduced many other features:</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Symbols
const symbol = Symbol('description');
const obj = {
    [symbol]: "value"
};

// Iterators and Generators
function* generator() {
    yield 1;
    yield 2;
    yield 3;
}

const iterator = generator();
console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2
console.log(iterator.next().value); // 3

// Map and Set
const map = new Map();
map.set('key', 'value');

const set = new Set([1, 2, 3, 3, 4]); // {1, 2, 3, 4}

// Optional chaining (ES2020)
const user = { profile: { name: "John" } };
const userName = user?.profile?.name; // "John"
const city = user?.profile?.address?.city; // undefined

// Nullish coalescing (ES2020)
const value = null ?? "default"; // "default"
const value2 = 0 ?? "default"; // 0

// Private class fields (ES2022)
class BankAccount {
    #balance = 0; // Private field
    
    deposit(amount) {
        this.#balance += amount;
    }
    
    getBalance() {
        return this.#balance;
    }
}
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try ES6+ features:</p>
                        <input type="text" id="es6-name" placeholder="Enter a name">
                        <input type="number" id="es6-age" placeholder="Enter an age">
                        <button onclick="useES6Features()">Use ES6 Features</button>
                        <div id="es6-result"></div>
                    </div>
                </div>
            </div>

            <!-- Module 9: DOM Manipulation -->
            <div class="content-card" id="module9">
                <div class="card-header">
                    <i class="fas fa-sitemap"></i> Module 9: DOM Manipulation
                </div>
                <div class="card-body">
                    <h5>Introduction to the DOM</h5>
                    <p>The Document Object Model (DOM) represents the HTML document as a tree structure of nodes. JavaScript can manipulate the DOM to change content, structure, and style of web pages dynamically.</p>
                    <p>The DOM provides an API for navigating and manipulating documents. Each element in an HTML document is a node in the DOM tree, and JavaScript can access and modify these nodes.</p>

                    <h5>Selecting Elements</h5>
                    <p>Before you can manipulate elements, you need to select them. JavaScript provides several methods for selecting elements.</p>

                    <h6>getElementById</h6>
                    <p>The getElementById method returns the element with the specified ID.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Select an element by ID
const header = document.getElementById("header");
</code></pre>

                    <h6>getElementsByClassName</h6>
                    <p>The getElementsByClassName method returns a collection of elements with the specified class name.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Select elements by class name
const buttons = document.getElementsByClassName("btn");
</code></pre>

                    <h6>getElementsByTagName</h6>
                    <p>The getElementsByTagName method returns a collection of elements with the specified tag name.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Select elements by tag name
const paragraphs = document.getElementsByTagName("p");
</code></pre>

                    <h6>querySelector and querySelectorAll</h6>
                    <p>The querySelector method returns the first element that matches a specified CSS selector. The querySelectorAll method returns all elements that match a specified CSS selector.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Select the first element with a class
const firstButton = document.querySelector(".btn");

// Select all elements with a class
const allButtons = document.querySelectorAll(".btn");

// Select elements with complex selectors
const firstParagraphInDiv = document.querySelector("div p:first-child");
const allLinksInNavigation = document.querySelectorAll("nav a");
</code></pre>

                    <h5>Creating Elements</h5>
                    <p>You can create new elements using the createElement method.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Create a new element
const newDiv = document.createElement("div");
const newParagraph = document.createElement("p");
const newImage = document.createElement("img");

// Create a text node
const newText = document.createTextNode("Hello, World!");

// Set attributes
newImage.src = "image.jpg";
newImage.alt = "Description of image";
</code></pre>

                    <h5>Modifying Elements</h5>
                    <p>Once you have selected or created elements, you can modify their content, attributes, and styles.</p>

                    <h6>Modifying Content</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Get an element
const paragraph = document.getElementById("myParagraph");

// Change text content
paragraph.textContent = "New text content";

// Change HTML content
paragraph.innerHTML = "<strong>New HTML content</strong>";

// Append a text node
const textNode = document.createTextNode("Additional text");
paragraph.appendChild(textNode);
</code></pre>

                    <h6>Modifying Attributes</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Get an element
const image = document.getElementById("myImage");

// Set attributes
image.src = "new-image.jpg";
image.alt = "New description";
image.width = "300";

// Get attributes
const source = image.src;
const alt = image.alt;

// Check if an attribute exists
if (image.hasAttribute("alt")) {
    console.log("Alt attribute exists");
}

// Remove an attribute
image.removeAttribute("width");
</code></pre>

                    <h6>Modifying Styles</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Get an element
const box = document.getElementById("myBox");

// Set individual styles
box.style.color = "red";
box.style.backgroundColor = "blue";
box.style.fontSize = "16px";

// Set multiple styles using cssText
box.style.cssText = "color: red; background-color: blue; font-size: 16px;";

// Get computed styles
const computedStyle = window.getComputedStyle(box);
const color = computedStyle.color;
</code></pre>

                    <h6>Modifying Classes</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Get an element
const element = document.getElementById("myElement");

// Add a class
element.classList.add("active");

// Remove a class
element.classList.remove("inactive");

// Toggle a class
element.classList.toggle("highlight");

// Check if a class exists
if (element.classList.contains("active")) {
    console.log("Element has the active class");
}

// Replace a class
element.classList.replace("old-class", "new-class");
</code></pre>

                    <h5>Adding and Removing Elements</h5>
                    <p>You can add elements to the DOM or remove elements from the DOM.</p>

                    <h6>Adding Elements</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Create a new element
const newDiv = document.createElement("div");
newDiv.textContent = "New div element";

// Append to the body
document.body.appendChild(newDiv);

// Append to a specific element
const container = document.getElementById("container");
container.appendChild(newDiv);

// Insert before an element
const referenceElement = document.getElementById("reference");
container.insertBefore(newDiv, referenceElement);

// Insert after an element (using insertBefore with nextSibling)
container.insertBefore(newDiv, referenceElement.nextSibling);

// Prepend to an element (insert at the beginning)
container.insertBefore(newDiv, container.firstChild);
</code></pre>

                    <h6>Removing Elements</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Get an element
const element = document.getElementById("myElement");

// Remove an element (modern way)
element.remove();

// Remove an element (traditional way)
const parent = element.parentNode;
parent.removeChild(element);

// Remove all child elements
const container = document.getElementById("container");
while (container.firstChild) {
    container.removeChild(container.firstChild);
}
</code></pre>

                    <h6>Replacing Elements</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Create a new element
const newElement = document.createElement("div");
newElement.textContent = "New element";

// Get the element to replace
const oldElement = document.getElementById("oldElement");

// Replace the element
const parent = oldElement.parentNode;
parent.replaceChild(newElement, oldElement);
</code></pre>

                    <h5>Traversing the DOM</h5>
                    <p>You can navigate the DOM tree using various properties.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Get an element
const element = document.getElementById("myElement");

// Get parent element
const parent = element.parentNode;

// Get child elements
const firstChild = element.firstChild;
const lastChild = element.lastChild;
const children = element.children;

// Get sibling elements
const previousSibling = element.previousSibling;
const nextSibling = element.nextSibling;
const previousElementSibling = element.previousElementSibling;
const nextElementSibling = element.nextElementSibling;

// Note: firstChild, lastChild, previousSibling, and nextSibling include text nodes
// firstElementChild, lastElementChild, previousElementSibling, and nextElementSibling only include element nodes
</code></pre>

                    <h5>DOM Events</h5>
                    <p>Events are actions that happen in the browser, like clicks, key presses, or page loads. JavaScript can respond to these events using event handlers and event listeners.</p>

                    <h6>Event Listeners</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Get an element
const button = document.getElementById("myButton");

// Add an event listener
button.addEventListener("click", function() {
    console.log("Button clicked!");
});

// Add an event listener with an arrow function
button.addEventListener("click", () => {
    console.log("Button clicked with arrow function!");
});

// Add an event listener with a named function
function handleClick() {
    console.log("Button clicked with named function!");
}
button.addEventListener("click", handleClick);

// Remove an event listener
button.removeEventListener("click", handleClick);
</code></pre>

                    <h6>Event Object</h6>
                    <p>When an event occurs, an event object is created with information about the event.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Add an event listener with event object
button.addEventListener("click", function(event) {
    console.log("Event type:", event.type);
    console.log("Target element:", event.target);
    console.log("Current target:", event.currentTarget);
    
    // Prevent default behavior
    event.preventDefault();
    
    // Stop event propagation
    event.stopPropagation();
});
</code></pre>

                    <h6>Event Delegation</h6>
                    <p>Event delegation is a technique where you add a single event listener to a parent element to handle events for multiple child elements.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Add a single event listener to a parent element
document.addEventListener("click", function(event) {
    // Check if the clicked element matches a specific selector
    if (event.target.matches(".button")) {
        console.log("Delegated button click");
    }
});
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try DOM manipulation:</p>
                        <button onclick="createElement()">Create Element</button>
                        <button onclick="changeStyle()">Change Style</button>
                        <button onclick="addElement()">Add Element</button>
                        <button onclick="removeElement()">Remove Element</button>
                        <div id="dom-demo" style="margin-top: 10px; padding: 10px; border: 1px solid #ccc;">
                            <p>This is a demo area for DOM manipulation.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 10: Event Handling -->
            <div class="content-card" id="module10">
                <div class="card-header">
                    <i class="fas fa-hand-pointer"></i> Module 10: Event Handling
                </div>
                <div class="card-body">
                    <h5>Introduction to Events</h5>
                    <p>Events are actions that happen in the browser, such as a user clicking a button, pressing a key, or the page finishing loading. JavaScript can respond to these events using event handlers and event listeners.</p>
                    <p>Understanding events is crucial for creating interactive web applications. Events allow you to respond to user actions and make your web pages dynamic and responsive.</p>

                    <h5>Event Listeners</h5>
                    <p>Event listeners are functions that wait for a specific event to occur on a specific element. When the event occurs, the listener function is executed.</p>

                    <h6>addEventListener Method</h6>
                    <p>The addEventListener method attaches an event handler to an element without overwriting existing event handlers.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Get an element
const button = document.getElementById("myButton");

// Add an event listener
button.addEventListener("click", function() {
    console.log("Button clicked!");
});

// Add multiple event listeners to the same element
button.addEventListener("click", function() {
    console.log("Another click handler!");
});

// Add an event listener with an arrow function
button.addEventListener("click", () => {
    console.log("Arrow function click handler!");
});

// Add an event listener with a named function
function handleClick() {
    console.log("Named function click handler!");
}
button.addEventListener("click", handleClick);
</code></pre>

                    <h6>Removing Event Listeners</h6>
                    <p>You can remove event listeners using the removeEventListener method. To remove an event listener, you need a reference to the same function that was added.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Add an event listener with a named function
function handleClick() {
    console.log("Button clicked!");
}
button.addEventListener("click", handleClick);

// Remove the event listener
button.removeEventListener("click", handleClick);

// You cannot remove anonymous event listeners
button.addEventListener("click", function() {
    console.log("This cannot be removed!");
});
// This won't work because the function is anonymous
button.removeEventListener("click", function() {
    console.log("This cannot be removed!");
});
</code></pre>

                    <h6>Event Options</h6>
                    <p>The addEventListener method can take an options object as a third argument.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Add an event listener with options
button.addEventListener("click", function() {
    console.log("Button clicked!");
}, {
    capture: false,    // Whether to use the capturing phase
    once: true,       // Whether the listener should be removed after being called once
    passive: false    // Whether the listener will call preventDefault()
});

// Shorthand for once option
button.addEventListener("click", function() {
    console.log("This will only be called once!");
}, { once: true });
</code></pre>

                    <h5>Event Object</h5>
                    <p>When an event occurs, an event object is created with information about the event. This object is passed as an argument to the event handler function.</p>

                    <h6>Common Event Properties</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Add an event listener with event object
button.addEventListener("click", function(event) {
    console.log("Event type:", event.type);        // "click"
    console.log("Target element:", event.target);  // The element that triggered the event
    console.log("Current target:", event.currentTarget); // The element the listener is attached to
    console.log("Timestamp:", event.timeStamp);    // When the event occurred
    console.log("Coordinates:", event.clientX, event.clientY); // Mouse position
});

// Keyboard events
document.addEventListener("keydown", function(event) {
    console.log("Key pressed:", event.key);        // The key that was pressed
    console.log("Key code:", event.keyCode);        // The key code
    console.log("Shift key:", event.shiftKey);      // Whether shift was pressed
    console.log("Ctrl key:", event.ctrlKey);        // Whether ctrl was pressed
    console.log("Alt key:", event.altKey);          // Whether alt was pressed
});
</code></pre>

                    <h6>Event Methods</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Prevent default behavior
document.querySelector("a").addEventListener("click", function(event) {
    event.preventDefault(); // Prevents the link from being followed
});

// Stop event propagation
document.querySelector("div").addEventListener("click", function(event) {
    event.stopPropagation(); // Prevents the event from bubbling up to parent elements
});

// Prevent default and stop propagation
form.addEventListener("submit", function(event) {
    event.preventDefault(); // Prevents the form from being submitted
    event.stopPropagation(); // Prevents the event from bubbling up
});
</code></pre>

                    <h5>Event Phases</h5>
                    <p>Events propagate through the DOM in three phases: capturing phase, target phase, and bubbling phase.</p>

                    <h6>Capturing Phase</h6>
                    <p>In the capturing phase, the event travels from the window down to the target element.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Add an event listener for the capturing phase
document.addEventListener("click", function(event) {
    console.log("Document capturing phase");
}, { capture: true });

document.querySelector("div").addEventListener("click", function(event) {
    console.log("Div capturing phase");
}, { capture: true });

document.querySelector("button").addEventListener("click", function(event) {
    console.log("Button target phase");
}, { capture: true });
</code></pre>

                    <h6>Bubbling Phase</h6>
                    <p>In the bubbling phase, the event travels from the target element up to the window.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Add an event listener for the bubbling phase (default)
document.addEventListener("click", function(event) {
    console.log("Document bubbling phase");
});

document.querySelector("div").addEventListener("click", function(event) {
    console.log("Div bubbling phase");
});

document.querySelector("button").addEventListener("click", function(event) {
    console.log("Button target phase");
});
</code></pre>

                    <h5>Common Event Types</h5>
                    <p>JavaScript supports many different types of events. Here are some of the most common ones:</p>

                    <h6>Mouse Events</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Click - when the element is clicked
element.addEventListener("click", function(event) {
    console.log("Element clicked");
});

// Double click - when the element is double-clicked
element.addEventListener("dblclick", function(event) {
    console.log("Element double-clicked");
});

// Mouse down - when a mouse button is pressed down
element.addEventListener("mousedown", function(event) {
    console.log("Mouse button pressed");
});

// Mouse up - when a mouse button is released
element.addEventListener("mouseup", function(event) {
    console.log("Mouse button released");
});

// Mouse over - when the mouse pointer enters the element
element.addEventListener("mouseover", function(event) {
    console.log("Mouse entered element");
});

// Mouse out - when the mouse pointer leaves the element
element.addEventListener("mouseout", function(event) {
    console.log("Mouse left element");
});

// Mouse move - when the mouse pointer moves over the element
element.addEventListener("mousemove", function(event) {
    console.log("Mouse moved over element");
});
</code></pre>

                    <h6>Keyboard Events</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Key down - when a key is pressed down
document.addEventListener("keydown", function(event) {
    console.log("Key pressed:", event.key);
});

// Key up - when a key is released
document.addEventListener("keyup", function(event) {
    console.log("Key released:", event.key);
});

// Key press - when a key that produces a character value is pressed
document.addEventListener("keypress", function(event) {
    console.log("Character key pressed:", event.key);
});
</code></pre>

                    <h6>Form Events</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Submit - when a form is submitted
form.addEventListener("submit", function(event) {
    event.preventDefault(); // Prevent the form from submitting
    console.log("Form submitted");
});

// Change - when the value of an element changes
input.addEventListener("change", function(event) {
    console.log("Input value changed:", event.target.value);
});

// Input - when the value of an element changes (for every keystroke)
input.addEventListener("input", function(event) {
    console.log("Input value:", event.target.value);
});

// Focus - when an element receives focus
input.addEventListener("focus", function(event) {
    console.log("Input received focus");
});

// Blur - when an element loses focus
input.addEventListener("blur", function(event) {
    console.log("Input lost focus");
});
</code></pre>

                    <h6>Document/Window Events</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Load - when the page is fully loaded
window.addEventListener("load", function(event) {
    console.log("Page fully loaded");
});

// DOMContentLoaded - when the DOM is fully loaded
document.addEventListener("DOMContentLoaded", function(event) {
    console.log("DOM fully loaded");
});

// Resize - when the browser window is resized
window.addEventListener("resize", function(event) {
    console.log("Window resized");
});

// Scroll - when the document is scrolled
window.addEventListener("scroll", function(event) {
    console.log("Document scrolled");
});
</code></pre>

                    <h5>Event Delegation</h5>
                    <p>Event delegation is a technique where you add a single event listener to a parent element to handle events for multiple child elements. This is more efficient than adding a separate event listener to each child element.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Add a single event listener to a parent element
document.addEventListener("click", function(event) {
    // Check if the clicked element matches a specific selector
    if (event.target.matches(".button")) {
        console.log("Delegated button click");
    }
    
    // Check if the clicked element is within a specific element
    if (event.target.closest(".card")) {
        console.log("Clicked within a card");
    }
});

// Example with a list
document.querySelector("ul").addEventListener("click", function(event) {
    if (event.target.tagName === "LI") {
        console.log("List item clicked:", event.target.textContent);
    }
});
</code></pre>

                    <h5>Custom Events</h5>
                    <p>You can create and dispatch your own custom events.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Create a custom event
const customEvent = new Event("customEvent");

// Create a custom event with details
const detailedEvent = new CustomEvent("detailedEvent", {
    detail: { message: "This is a custom event with details" }
});

// Add an event listener for the custom event
document.addEventListener("customEvent", function(event) {
    console.log("Custom event fired");
});

document.addEventListener("detailedEvent", function(event) {
    console.log("Detailed event fired:", event.detail.message);
});

// Dispatch the custom event
document.dispatchEvent(customEvent);
document.dispatchEvent(detailedEvent);
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try different event types:</p>
                        <button id="event-button">Click Me</button>
                        <input type="text" id="event-input" placeholder="Type here">
                        <div id="event-output" style="margin-top: 10px; padding: 10px; border: 1px solid #ccc;">
                            Event output will appear here...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 11: Asynchronous JavaScript -->
            <div class="content-card" id="module11">
                <div class="card-header">
                    <i class="fas fa-sync-alt"></i> Module 11: Asynchronous JavaScript
                </div>
                <div class="card-body">
                    <h5>Introduction to Asynchronous JavaScript</h5>
                    <p>JavaScript is single-threaded, meaning it can only do one thing at a time. However, it can handle asynchronous operations using callbacks, promises, and async/await. This is essential for operations that take time, like API calls, file operations, or timers.</p>
                    <p>Understanding the event loop, callback queue, and microtask queue is crucial for mastering asynchronous JavaScript.</p>

                    <h5>The Event Loop</h5>
                    <p>The event loop is a mechanism that allows JavaScript to perform non-blocking operations despite being single-threaded. It continuously checks the call stack and the task queue, and pushes tasks from the queue to the stack when the stack is empty.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
console.log("Start");

setTimeout(function() {
    console.log("Timeout");
}, 0);

Promise.resolve().then(function() {
    console.log("Promise");
});

console.log("End");

// Output:
// Start
// End
// Promise
// Timeout

// Explanation:
// 1. "Start" is logged to the console.
// 2. setTimeout is added to the task queue.
// 3. Promise.resolve().then() is added to the microtask queue.
// 4. "End" is logged to the console.
// 5. The call stack is empty, so the event loop checks the microtask queue first.
// 6. The promise callback is executed, logging "Promise".
// 7. The event loop checks the task queue.
// 8. The timeout callback is executed, logging "Timeout".
</code></pre>

                    <h5>Callbacks</h5>
                    <p>Callbacks are functions that are passed as arguments to other functions and are executed after an operation completes. Callbacks were the original way to handle asynchronous operations in JavaScript.</p>

                    <h6>Simple Callback Example</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function fetchData(callback) {
    setTimeout(function() {
        const data = "Some data";
        callback(data);
    }, 1000);
}

function processData(data) {
    console.log("Processing data:", data);
}

fetchData(processData);
// After 1 second: "Processing data: Some data"
</code></pre>

                    <h6>Callback Hell</h6>
                    <p>Nesting multiple callbacks can lead to "callback hell" or "pyramid of doom," which makes the code hard to read and maintain.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Callback hell example
fetchData(function(data1) {
    processData1(data1, function(result1) {
        fetchData2(function(data2) {
            processData2(data2, function(result2) {
                fetchData3(function(data3) {
                    processData3(data3, function(result3) {
                        console.log("Final result:", result3);
                    });
                });
            });
        });
    });
});
</code></pre>

                    <h5>Promises</h5>
                    <p>Promises provide a cleaner way to handle asynchronous operations. A promise represents a value that may be available now, or in the future, or never.</p>

                    <h6>Creating a Promise</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
const promise = new Promise(function(resolve, reject) {
    // Asynchronous operation
    setTimeout(function() {
        const success = true;
        
        if (success) {
            resolve("Success!"); // Resolve the promise with a value
        } else {
            reject("Error!"); // Reject the promise with a reason
        }
    }, 1000);
});

// Using the promise
promise
    .then(function(data) {
        console.log(data); // "Success!"
    })
    .catch(function(error) {
        console.error(error); // This won't be executed in this example
    });
</code></pre>

                    <h6>Promise Methods</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Promise.all - waits for all promises to resolve
const promise1 = Promise.resolve(3);
const promise2 = new Promise(function(resolve) {
    setTimeout(resolve, 100, "foo");
});
const promise3 = Promise.resolve(42);

Promise.all([promise1, promise2, promise3])
    .then(function(values) {
        console.log(values); // [3, "foo", 42]
    })
    .catch(function(error) {
        console.error(error);
    });

// Promise.race - waits for the first promise to resolve or reject
const promise4 = new Promise(function(resolve) {
    setTimeout(resolve, 500, "one");
});
const promise5 = new Promise(function(resolve) {
    setTimeout(resolve, 100, "two");
});

Promise.race([promise4, promise5])
    .then(function(value) {
        console.log(value); // "two"
    })
    .catch(function(error) {
        console.error(error);
    });

// Promise.allSettled - waits for all promises to settle (resolve or reject)
const promise6 = Promise.resolve(3);
const promise7 = new Promise(function(resolve, reject) {
    setTimeout(reject, 100, "error");
});

Promise.allSettled([promise6, promise7])
    .then(function(results) {
        console.log(results);
        // [
        //   { status: "fulfilled", value: 3 },
        //   { status: "rejected", reason: "error" }
        // ]
    });

// Promise.any - waits for the first promise to fulfill
const promise8 = Promise.reject("error1");
const promise9 = Promise.reject("error2");
const promise10 = Promise.resolve("success");

Promise.any([promise8, promise9, promise10])
    .then(function(value) {
        console.log(value); // "success"
    })
    .catch(function(error) {
        console.error(error); // AggregateError: All promises were rejected
    });
</code></pre>

                    <h6>Chaining Promises</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function fetchData() {
    return new Promise(function(resolve) {
        setTimeout(function() {
            resolve("Data fetched");
        }, 1000);
    });
}

function processData(data) {
    return new Promise(function(resolve) {
        setTimeout(function() {
            resolve(data + " and processed");
        }, 1000);
    });
}

function saveData(data) {
    return new Promise(function(resolve) {
        setTimeout(function() {
            resolve(data + " and saved");
        }, 1000);
    });
}

// Chaining promises
fetchData()
    .then(function(data) {
        console.log(data); // "Data fetched"
        return processData(data);
    })
    .then(function(data) {
        console.log(data); // "Data fetched and processed"
        return saveData(data);
    })
    .then(function(data) {
        console.log(data); // "Data fetched and processed and saved"
    })
    .catch(function(error) {
        console.error(error);
    });
</code></pre>

                    <h5>Async/Await</h5>
                    <p>Async/await is syntactic sugar over promises that makes asynchronous code look and behave more like synchronous code. It was introduced in ES2017.</p>

                    <h6>Async Functions</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Declaring an async function
async function fetchData() {
    return "Data fetched";
}

// Calling an async function
fetchData().then(function(data) {
    console.log(data); // "Data fetched"
});

// Using await inside an async function
async function processData() {
    const data = await fetchData(); // Waits for the promise to resolve
    return data + " and processed";
}

processData().then(function(data) {
    console.log(data); // "Data fetched and processed"
});
</code></pre>

                    <h6>Error Handling with Async/Await</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
async function fetchData() {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            reject("Error fetching data");
        }, 1000);
    });
}

// Using try/catch for error handling
async function processData() {
    try {
        const data = await fetchData();
        return data + " and processed";
    } catch (error) {
        console.error(error); // "Error fetching data"
        return "Default data";
    }
}

processData().then(function(data) {
    console.log(data); // "Default data"
});
</code></pre>

                    <h6>Parallel Async Operations</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
async function fetchMultipleData() {
    // Fetch data in parallel
    const [data1, data2, data3] = await Promise.all([
        fetchData1(),
        fetchData2(),
        fetchData3()
    ]);
    
    return { data1, data2, data3 };
}

// Sequential async operations
async function fetchSequentialData() {
    const data1 = await fetchData1();
    const data2 = await fetchData2();
    const data3 = await fetchData3();
    
    return { data1, data2, data3 };
}
</code></pre>

                    <h5>Fetch API</h5>
                    <p>The Fetch API provides a modern interface for fetching resources. It is more powerful and flexible than the older XMLHttpRequest.</p>

                    <h6>Basic Fetch</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Basic fetch with promises
fetch("https://api.example.com/data")
    .then(function(response) {
        if (!response.ok) {
            throw new Error("Network response was not ok");
        }
        return response.json();
    })
    .then(function(data) {
        console.log(data);
    })
    .catch(function(error) {
        console.error("Fetch error:", error);
    });

// Basic fetch with async/await
async function fetchData() {
    try {
        const response = await fetch("https://api.example.com/data");
        
        if (!response.ok) {
            throw new Error("Network response was not ok");
        }
        
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error("Fetch error:", error);
    }
}
</code></pre>

                    <h6>Fetch Options</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// POST request with fetch
async function postData(url, data) {
    try {
        const response = await fetch(url, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify(data),
        });
        
        if (!response.ok) {
            throw new Error("Network response was not ok");
        }
        
        const responseData = await response.json();
        return responseData;
    } catch (error) {
        console.error("Fetch error:", error);
    }
}

// Using the postData function
postData("https://api.example.com/data", { name: "John", age: 25 })
    .then(function(data) {
        console.log(data);
    });
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try asynchronous operations:</p>
                        <button onclick="runAsyncOperation()">Run Async Operation</button>
                        <button onclick="runPromiseChain()">Run Promise Chain</button>
                        <button onclick="runAsyncAwait()">Run Async/Await</button>
                        <div id="async-output" style="margin-top: 10px; padding: 10px; border: 1px solid #ccc;">
                            Async output will appear here...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 12: Error Handling and Debugging -->
            <div class="content-card" id="module12">
                <div class="card-header">
                    <i class="fas fa-bug"></i> Module 12: Error Handling and Debugging
                </div>
                <div class="card-body">
                    <h5>Introduction to Error Handling</h5>
                    <p>Errors are inevitable in programming. JavaScript provides mechanisms for handling errors gracefully, making your code more robust and user-friendly. Proper error handling prevents your application from crashing and provides meaningful feedback to users.</p>

                    <h5>Types of Errors</h5>
                    <p>JavaScript has several built-in error types, each representing a different kind of error:</p>
                    <ul>
                        <li><strong>Error:</strong> The base error type, all other error types inherit from it</li>
                        <li><strong>SyntaxError:</strong> Occurs when there's a syntax error in the code</li>
                        <li><strong>ReferenceError:</strong> Occurs when trying to access a non-existent variable</li>
                        <li><strong>TypeError:</strong> Occurs when an operation is performed on a value of the wrong type</li>
                        <li><strong>RangeError:</strong> Occurs when a numeric value is outside its allowed range</li>
                        <li><strong>URIError:</strong> Occurs when using encodeURI() or decodeURI() with invalid URIs</li>
                        <li><strong>EvalError:</strong> Occurs when using the eval() function (rarely used now)</li>
                    </ul>

                    <h5>Try-Catch-Finally</h5>
                    <p>The try-catch-finally statement is used to handle errors. The try block contains the code that might throw an error, the catch block contains the code to handle the error, and the finally block contains code that will always execute, regardless of whether an error occurred.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
try {
    // Code that might throw an error
    let result = riskyOperation();
    console.log(result);
} catch (error) {
    // Code to handle the error
    console.error("Error occurred:", error.message);
} finally {
    // Code that will always execute
    console.log("Cleanup code");
}

// Example with a specific error
try {
    let obj = null;
    console.log(obj.property); // Throws a TypeError
} catch (error) {
    if (error instanceof TypeError) {
        console.error("Type error occurred:", error.message);
    } else {
        console.error("Unknown error:", error);
    }
}
</code></pre>

                    <h5>Throwing Errors</h5>
                    <p>You can throw your own errors using the throw statement. This is useful for validating input or handling specific conditions in your code.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function divide(a, b) {
    if (b === 0) {
        throw new Error("Division by zero is not allowed");
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    console.log(result);
} catch (error) {
    console.error(error.message); // "Division by zero is not allowed"
}

// Throwing different types of errors
function validateAge(age) {
    if (typeof age !== "number") {
        throw new TypeError("Age must be a number");
    }
    if (age < 0) {
        throw new RangeError("Age cannot be negative");
    }
    if (age > 120) {
        throw new RangeError("Age seems unrealistic");
    }
    return true;
}

try {
    validateAge("twenty");
} catch (error) {
    console.error(error.name + ": " + error.message); // "TypeError: Age must be a number"
}
</code></pre>

                    <h5>Custom Error Types</h5>
                    <p>You can create your own error types by extending the Error class. This allows you to handle specific errors in your application.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Custom error type
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = "ValidationError";
    }
}

// Another custom error type
class NetworkError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = "NetworkError";
        this.statusCode = statusCode;
    }
}

// Using custom errors
function validateEmail(email) {
    if (!email.includes("@")) {
        throw new ValidationError("Invalid email format");
    }
    return true;
}

function fetchData(url) {
    return new Promise((resolve, reject) => {
        // Simulate a network request
        setTimeout(() => {
            if (url.startsWith("https://")) {
                resolve("Data fetched successfully");
            } else {
                reject(new NetworkError("Insecure protocol", 400));
            }
        }, 1000);
    });
}

// Handling custom errors
try {
    validateEmail("invalid-email");
} catch (error) {
    if (error instanceof ValidationError) {
        console.error("Validation error:", error.message);
    } else {
        console.error("Unknown error:", error);
    }
}

fetchData("http://example.com")
    .then(data => console.log(data))
    .catch(error => {
        if (error instanceof NetworkError) {
            console.error(`Network error (${error.statusCode}): ${error.message}`);
        } else {
            console.error("Unknown error:", error);
        }
    });
</code></pre>

                    <h5>Global Error Handlers</h5>
                    <p>You can set up global error handlers to catch errors that aren't caught by try-catch blocks.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Global error handler for synchronous errors
window.addEventListener("error", function(event) {
    console.error("Global error:", event.error);
    // You might want to send the error to a logging service
});

// Global error handler for unhandled promise rejections
window.addEventListener("unhandledrejection", function(event) {
    console.error("Unhandled promise rejection:", event.reason);
    // You might want to send the error to a logging service
    event.preventDefault(); // Prevents the default browser behavior
});

// Using these global handlers is especially useful in production
// to catch and log unexpected errors
</code></pre>

                    <h5>Debugging Techniques</h5>
                    <p>Debugging is the process of finding and fixing errors in your code. JavaScript provides several tools and techniques for debugging.</p>

                    <h6>Console Methods</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// console.log - for general output
console.log("Variable value:", variable);

// console.error - for errors
console.error("Something went wrong:", error);

// console.warn - for warnings
console.warn("This might cause issues");

// console.info - for informational messages
console.info("Process completed successfully");

// console.table - for displaying tabular data
const users = [
    { id: 1, name: "John", age: 25 },
    { id: 2, name: "Jane", age: 30 }
];
console.table(users);

// console.group and console.groupEnd - for grouping related messages
console.group("User validation");
console.log("Validating user data");
console.log("User data is valid");
console.groupEnd();

// console.trace - for showing the call stack
function functionA() {
    functionB();
}

function functionB() {
    console.trace("Trace from functionB");
}

functionA();

// console.time and console.timeEnd - for measuring execution time
console.time("Array processing");
// Some array processing code
console.timeEnd("Array processing");
</code></pre>

                    <h6>Debugger Statement</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function calculateTotal(items) {
    debugger; // Execution will pause here if developer tools are open
    
    let total = 0;
    for (let i = 0; i < items.length; i++) {
        total += items[i].price;
    }
    
    return total;
}

// The debugger statement is useful when you want to pause execution
// at a specific point without setting a breakpoint manually
</code></pre>

                    <h6>Using Browser Developer Tools</h6>
                    <p>Modern browsers provide powerful developer tools for debugging JavaScript:</p>
                    <ul>
                        <li><strong>Console:</strong> For viewing logs and running JavaScript code</li>
                        <li><strong>Sources:</strong> For viewing and debugging source code</li>
                        <li><strong>Network:</strong> For monitoring network requests</li>
                        <li><strong>Performance:</strong> For analyzing performance</li>
                    </ul>

                    <h5>Error Handling Best Practices</h5>
                    <p>Follow these best practices for effective error handling:</p>
                    <ul>
                        <li><strong>Be Specific:</strong> Catch specific errors rather than using a generic catch-all</li>
                        <li><strong>Log Errors:</strong> Log errors to help with debugging</li>
                        <li><strong>Provide Feedback:</strong> Give users meaningful feedback when errors occur</li>
                        <li><strong>Fail Gracefully:</strong> Ensure your application doesn't crash when errors occur</li>
                        <li><strong>Validate Input:</strong> Validate input to prevent errors before they occur</li>
                    </ul>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Example of good error handling
async function fetchUserData(userId) {
    try {
        // Validate input
        if (!userId || typeof userId !== "string") {
            throw new ValidationError("Invalid user ID");
        }
        
        // Fetch data
        const response = await fetch(`/api/users/${userId}`);
        
        if (!response.ok) {
            throw new NetworkError(`Failed to fetch user data: ${response.statusText}`, response.status);
        }
        
        const userData = await response.json();
        
        // Validate response data
        if (!userData || !userData.id) {
            throw new ValidationError("Invalid user data received");
        }
        
        return userData;
    } catch (error) {
        // Log the error for debugging
        console.error("Error fetching user data:", error);
        
        // Provide meaningful feedback to the user
        if (error instanceof ValidationError) {
            showUserMessage("Invalid input. Please check your user ID and try again.");
        } else if (error instanceof NetworkError) {
            showUserMessage("Network error. Please check your connection and try again.");
        } else {
            showUserMessage("An unexpected error occurred. Please try again later.");
        }
        
        // Re-throw the error if you want calling code to handle it
        throw error;
    }
}

// Using the function with proper error handling
try {
    const userData = await fetchUserData("user123");
    displayUserData(userData);
} catch (error) {
    // Error is already handled in the function, but we might want to do additional cleanup
    hideLoadingIndicator();
}
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try error handling:</p>
                        <input type="number" id="error-input" placeholder="Enter a number">
                        <button onclick="tryErrorHandling()">Try Operation</button>
                        <div id="error-output" style="margin-top: 10px; padding: 10px; border: 1px solid #ccc;">
                            Error handling output will appear here...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 13: Classes and OOP -->
            <div class="content-card" id="module13">
                <div class="card-header">
                    <i class="fas fa-object-group"></i> Module 13: Classes and OOP
                </div>
                <div class="card-body">
                    <h5>Introduction to Object-Oriented Programming</h5>
                    <p>Object-Oriented Programming (OOP) is a programming paradigm based on the concept of "objects," which can contain data and code. JavaScript supports OOP through prototypes, and ES6 introduced class syntax that makes OOP more intuitive.</p>
                    <p>OOP concepts include encapsulation, inheritance, polymorphism, and abstraction. Understanding these concepts will help you write more organized, reusable, and maintainable code.</p>

                    <h5>Class Syntax</h5>
                    <p>ES6 introduced class syntax for creating objects, which is syntactic sugar over JavaScript's prototype-based inheritance. Classes provide a cleaner way to create objects and implement inheritance.</p>

                    <h6>Class Declaration</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Class declaration
class Person {
    // Constructor method
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // Instance method
    greet() {
        return `Hello, I'm ${this.name}`;
    }
    
    // Another instance method
    celebrateBirthday() {
        this.age++;
        return `Happy birthday! You are now ${this.age} years old.`;
    }
}

// Creating an instance of the class
const person = new Person("John", 25);
console.log(person.greet()); // "Hello, I'm John"
console.log(person.celebrateBirthday()); // "Happy birthday! You are now 26 years old."
</code></pre>

                    <h6>Class Expression</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Class expression (unnamed)
const Person = class {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        return `Hello, I'm ${this.name}`;
    }
};

// Class expression (named)
const Person = class PersonClass {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        return `Hello, I'm ${this.name}`;
    }
    
    getClassName() {
        return PersonClass.name;
    }
};

const person = new Person("John", 25);
console.log(person.getClassName()); // "PersonClass"
</code></pre>

                    <h5>Fields and Methods</h6>
                    <p>Classes can have fields (properties) and methods (functions). Fields can be instance fields (unique to each instance) or static fields (shared by all instances).</p>

                    <h6>Instance Fields</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class Person {
    // Instance fields (can be declared outside constructor in ES2022)
    name;
    age;
    
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // Instance method
    greet() {
        return `Hello, I'm ${this.name}`;
    }
}

const person1 = new Person("John", 25);
const person2 = new Person("Jane", 30);

console.log(person1.name); // "John"
console.log(person2.name); // "Jane"
</code></pre>

                    <h6>Static Fields and Methods</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class Person {
    // Static field
    static species = "Homo sapiens";
    
    // Static method
    static getSpecies() {
        return Person.species;
    }
    
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // Instance method
    greet() {
        return `Hello, I'm ${this.name} and I'm a ${Person.species}`;
    }
}

// Accessing static fields and methods
console.log(Person.species); // "Homo sapiens"
console.log(Person.getSpecies()); // "Homo sapiens"

// Creating an instance
const person = new Person("John", 25);
console.log(person.greet()); // "Hello, I'm John and I'm a Homo sapiens"
</code></pre>

                    <h6>Private Fields and Methods</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class BankAccount {
    // Private field (ES2022)
    #balance;
    
    constructor(initialBalance) {
        this.#balance = initialBalance;
    }
    
    // Public method
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            return this.#balance;
        }
        throw new Error("Deposit amount must be positive");
    }
    
    // Public method
    withdraw(amount) {
        if (amount > 0 && amount <= this.#balance) {
            this.#balance -= amount;
            return this.#balance;
        }
        throw new Error("Invalid withdrawal amount");
    }
    
    // Public method
    getBalance() {
        return this.#balance;
    }
    
    // Private method (ES2022)
    #validateAmount(amount) {
        return typeof amount === "number" && amount > 0;
    }
}

const account = new BankAccount(1000);
console.log(account.getBalance()); // 1000
account.deposit(500);
console.log(account.getBalance()); // 1500

// Trying to access private field directly
// console.log(account.#balance); // SyntaxError: Private field '#balance' must be declared in an enclosing class
</code></pre>

                    <h5>Getters and Setters</h5>
                    <p>Getters and setters allow you to define how properties are accessed and modified. They provide a way to execute code when getting or setting a property value.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class Person {
    constructor(name, age) {
        this._name = name; // Convention: underscore for "private" properties
        this._age = age;
    }
    
    // Getter for name
    get name() {
        return this._name;
    }
    
    // Setter for name
    set name(newName) {
        if (typeof newName === "string" && newName.length > 0) {
            this._name = newName;
        } else {
            throw new Error("Name must be a non-empty string");
        }
    }
    
    // Getter for age
    get age() {
        return this._age;
    }
    
    // Setter for age
    set age(newAge) {
        if (typeof newAge === "number" && newAge >= 0) {
            this._age = newAge;
        } else {
            throw new Error("Age must be a non-negative number");
        }
    }
    
    // Computed getter
    get info() {
        return `${this._name} is ${this._age} years old`;
    }
}

const person = new Person("John", 25);
console.log(person.name); // "John" (calls the getter)
console.log(person.age); // 25 (calls the getter)
console.log(person.info); // "John is 25 years old" (calls the computed getter)

person.name = "Jane"; // Calls the setter
person.age = 26; // Calls the setter
console.log(person.info); // "Jane is 26 years old"

// person.name = ""; // Throws an error
// person.age = -5; // Throws an error
</code></pre>

                    <h5>Inheritance</h5>
                    <p>Inheritance allows a class to inherit properties and methods from another class. The class that inherits is called the subclass or derived class, and the class being inherited from is called the superclass or base class.</p>

                    <h6>Extending a Class</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Base class
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        return `Hello, I'm ${this.name}`;
    }
}

// Derived class
class Student extends Person {
    constructor(name, age, grade) {
        // Call the parent constructor
        super(name, age);
        this.grade = grade;
    }
    
    // Override the greet method
    greet() {
        return `${super.greet()} and I'm a student in grade ${this.grade}`;
    }
    
    // New method
    study() {
        return `${this.name} is studying hard`;
    }
}

const student = new Student("John", 15, 10);
console.log(student.greet()); // "Hello, I'm John and I'm a student in grade 10"
console.log(student.study()); // "John is studying hard"
</code></pre>

                    <h6>Overriding Methods</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        return `${this.name} makes a sound`;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
    
    // Override the speak method
    speak() {
        return `${this.name} barks`;
    }
    
    // Call the parent method
    speakLikeAnimal() {
        return super.speak();
    }
}

const dog = new Dog("Rex", "Labrador");
console.log(dog.speak()); // "Rex barks"
console.log(dog.speakLikeAnimal()); // "Rex makes a sound"
</code></pre>

                    <h5>Polymorphism</h5>
                    <p>Polymorphism allows objects of different classes to be treated as objects of a common superclass. This is achieved through method overriding and interfaces.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class Shape {
    calculateArea() {
        throw new Error("Method must be implemented by subclass");
    }
}

class Rectangle extends Shape {
    constructor(width, height) {
        super();
        this.width = width;
        this.height = height;
    }
    
    calculateArea() {
        return this.width * this.height;
    }
}

class Circle extends Shape {
    constructor(radius) {
        super();
        this.radius = radius;
    }
    
    calculateArea() {
        return Math.PI * this.radius * this.radius;
    }
}

// Polymorphism in action
function printArea(shape) {
    console.log(`Area: ${shape.calculateArea()}`);
}

const rectangle = new Rectangle(5, 10);
const circle = new Circle(7);

printArea(rectangle); // "Area: 50"
printArea(circle); // "Area: 153.93804002589985"
</code></pre>

                    <h5>Abstract Classes</h5>
                    <p>JavaScript doesn't have built-in support for abstract classes, but you can simulate them using regular classes and throwing errors in methods that should be implemented by subclasses.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Simulating an abstract class
class Animal {
    constructor(name) {
        if (this.constructor === Animal) {
            throw new Error("Animal is an abstract class and cannot be instantiated directly");
        }
        this.name = name;
    }
    
    // Abstract method
    speak() {
        throw new Error("Method 'speak' must be implemented by subclass");
    }
    
    // Concrete method
    eat() {
        return `${this.name} is eating`;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
    
    // Implement the abstract method
    speak() {
        return `${this.name} barks`;
    }
}

// const animal = new Animal("Generic Animal"); // Throws an error
const dog = new Dog("Rex", "Labrador");
console.log(dog.speak()); // "Rex barks"
console.log(dog.eat()); // "Rex is eating"
</code></pre>

                    <h5>Mixins</h5>
                    <p>Mixins are a way to reuse code in multiple class hierarchies. They are classes that provide methods that can be used by other classes.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Mixin class
const CanFly = {
    fly() {
        return `${this.name} is flying`;
    }
};

const CanSwim = {
    swim() {
        return `${this.name} is swimming`;
    }
};

// Using mixins with classes
class Bird {
    constructor(name) {
        this.name = name;
    }
}

// Apply the mixin
Object.assign(Bird.prototype, CanFly);

const bird = new Bird("Tweety");
console.log(bird.fly()); // "Tweety is flying"

// Using multiple mixins
class Duck {
    constructor(name) {
        this.name = name;
    }
}

// Apply multiple mixins
Object.assign(Duck.prototype, CanFly, CanSwim);

const duck = new Duck("Donald");
console.log(duck.fly()); // "Donald is flying"
console.log(duck.swim()); // "Donald is swimming"
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try creating and using classes:</p>
                        <input type="text" id="class-name" placeholder="Enter a name">
                        <input type="number" id="class-age" placeholder="Enter an age">
                        <button onclick="createClassInstance()">Create Instance</button>
                        <button onclick="callClassMethod()">Call Method</button>
                        <div id="class-output" style="margin-top: 10px; padding: 10px; border: 1px solid #ccc;">
                            Class output will appear here...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 14: Modules and Imports -->
            <div class="content-card" id="module14">
                <div class="card-header">
                    <i class="fas fa-puzzle-piece"></i> Module 14: Modules and Imports
                </div>
                <div class="card-body">
                    <h5>Introduction to Modules</h5>
                    <p>JavaScript modules allow you to break up your code into separate, reusable files. ES6 introduced a standardized module system with import and export syntax. Modules help organize code, avoid namespace pollution, and enable better code reuse.</p>
                    <p>Before ES6 modules, JavaScript relied on various module systems like CommonJS (used in Node.js) and AMD (Asynchronous Module Definition). ES6 modules provide a native solution that works in both browsers and Node.js.</p>

                    <h5>Exporting from Modules</h5>
                    <p>You can export functions, objects, or primitive values from a module using the export keyword. There are two types of exports: named exports and default exports.</p>

                    <h6>Named Exports</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// math.js

// Exporting a variable
export const PI = 3.14159;

// Exporting a function
export function add(a, b) {
    return a + b;
}

// Exporting another function
export function multiply(a, b) {
    return a * b;
}

// Exporting a class
export class Calculator {
    constructor() {
        this.result = 0;
    }
    
    add(value) {
        this.result += value;
        return this;
    }
    
    subtract(value) {
        this.result -= value;
        return this;
    }
    
    getResult() {
        return this.result;
    }
}

// Exporting an object
export const utils = {
    formatNumber: (num) => num.toFixed(2),
    isEven: (num) => num % 2 === 0
};
</code></pre>

                    <h6>Default Exports</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// utils.js

// Default export of a function
export default function formatDate(date) {
    return date.toLocaleDateString();
}

// You can also have named exports alongside a default export
export const formatTime = (date) => {
    return date.toLocaleTimeString();
};

// Default export of a class
// export default class DateFormatter {
//     format(date) {
//         return date.toLocaleDateString();
//     }
// }
</code></pre>

                    <h6>Exporting After Declaration</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// helpers.js

const API_URL = "https://api.example.com";

function fetchData(endpoint) {
    return fetch(`${API_URL}/${endpoint}`);
}

class ApiClient {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
    }
    
    async get(endpoint) {
        const response = await fetch(`${this.baseUrl}/${endpoint}`);
        return response.json();
    }
}

// Exporting after declaration
export { API_URL, fetchData, ApiClient };
</code></pre>

                    <h6>Re-exporting</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// index.js

// Re-exporting named exports
export { add, multiply, PI } from './math.js';

// Re-exporting with different names
export { add as sum, multiply as product } from './math.js';

// Re-exporting a default export
export { default as formatDate } from './utils.js';

// Re-exporting all from a module
export * from './helpers.js';

// Re-exporting all named exports from a module
export * as MathUtils from './math.js';
</code></pre>

                    <h5>Importing Modules</h5>
                    <p>You can import exported values from other modules using the import keyword. The import statement must be at the top level of a module.</p>

                    <h6>Importing Named Exports</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// main.js

// Import specific named exports
import { PI, add, multiply } from './math.js';

// Using the imports
console.log(PI); // 3.14159
console.log(add(5, 3)); // 8
console.log(multiply(5, 3)); // 15

// Import with different names
import { add as sum, multiply as product } from './math.js';

console.log(sum(5, 3)); // 8
console.log(product(5, 3)); // 15

// Import all named exports as a namespace
import * as MathUtils from './math.js';

console.log(MathUtils.PI); // 3.14159
console.log(MathUtils.add(5, 3)); // 8
console.log(MathUtils.multiply(5, 3)); // 15
</code></pre>

                    <h6>Importing Default Exports</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// main.js

// Import a default export
import formatDate from './utils.js';

// Using the import
const today = new Date();
console.log(formatDate(today)); // "5/15/2023" (format depends on locale)

// Import a default export with a different name
import dateFormatter from './utils.js';

console.log(dateFormatter(today)); // "5/15/2023"

// Import both default and named exports
import formatDate, { formatTime } from './utils.js';

console.log(formatDate(today)); // "5/15/2023"
console.log(formatTime(today)); // "2:30:45 PM" (format depends on locale)
</code></pre>

                    <h6>Importing All Exports</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// main.js

// Import all exports from a module
import * as Utils from './utils.js';

// Using the imports
const today = new Date();
console.log(Utils.formatDate(today)); // "5/15/2023"
console.log(Utils.formatTime(today)); // "2:30:45 PM"

// Import all exports from a module with a namespace
import * as MathUtils from './math.js';

console.log(MathUtils.PI); // 3.14159
console.log(MathUtils.add(5, 3)); // 8
</code></pre>

                    <h5>Dynamic Imports</h5>
                    <p>Dynamic imports allow you to load modules on demand, which can improve performance by only loading code when it's needed. Dynamic imports return a promise.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// main.js

// Dynamic import of a module
async function loadMathModule() {
    try {
        const MathUtils = await import('./math.js');
        console.log(MathUtils.add(5, 3)); // 8
        console.log(MathUtils.multiply(5, 3)); // 15
    } catch (error) {
        console.error("Failed to load math module:", error);
    }
}

// Call the function to load the module
loadMathModule();

// Using dynamic imports with conditional loading
async function loadFeature(feature) {
    if (feature === "math") {
        const MathUtils = await import('./math.js');
        return MathUtils;
    } else if (feature === "utils") {
        const Utils = await import('./utils.js');
        return Utils;
    }
}

// Using the function
loadFeature("math").then(MathUtils => {
    console.log(MathUtils.add(5, 3)); // 8
});
</code></pre>

                    <h5>Module Loading in HTML</h5>
                    <p>To use ES6 modules in an HTML file, you need to set the type attribute of the script tag to "module".</p>
                    <pre><button class="copy-button">Copy</button><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;ES6 Modules Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;ES6 Modules Example&lt;/h1&gt;
    &lt;div id="output"&gt;&lt;/div&gt;
    
    &lt;!-- Load the main module --&gt;
    &lt;script type="module" src="main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

                    <h5>Module Bundlers</h5>
                    <p>Module bundlers like Webpack, Rollup, and Parcel are tools that take modules with dependencies and bundle them into static assets that browsers can understand. Bundlers are commonly used in modern web development to optimize the loading and execution of JavaScript code.</p>

                    <h5>CommonJS vs. ES6 Modules</h5>
                    <p>CommonJS is the module system used by Node.js, while ES6 modules are the standard for JavaScript. Here are the key differences:</p>
                    <ul>
                        <li><strong>Syntax:</strong> CommonJS uses require() and module.exports, while ES6 modules use import and export</li>
                        <li><strong>Loading:</strong> CommonJS modules are loaded synchronously, while ES6 modules are loaded asynchronously</li>
                        <li><strong>this:</strong> In CommonJS, this refers to the module exports, while in ES6 modules, this is undefined</li>
                        <li><strong>Imports:</strong> CommonJS imports are copies of the exported values, while ES6 module imports are live bindings to the exported values</li>
                    </ul>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// CommonJS (Node.js)
// math.js
const PI = 3.14159;

function add(a, b) {
    return a + b;
}

module.exports = { PI, add };

// main.js
const { PI, add } = require('./math.js');
console.log(PI); // 3.14159
console.log(add(5, 3)); // 8

// ES6 Modules
// math.js
export const PI = 3.14159;

export function add(a, b) {
    return a + b;
}

// main.js
import { PI, add } from './math.js';
console.log(PI); // 3.14159
console.log(add(5, 3)); // 8
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try module concepts:</p>
                        <button onclick="simulateModuleImport()">Simulate Module Import</button>
                        <button onclick="simulateDynamicImport()">Simulate Dynamic Import</button>
                        <div id="module-output" style="margin-top: 10px; padding: 10px; border: 1px solid #ccc;">
                            Module output will appear here...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 15: Data Structures -->
            <div class="content-card" id="module15">
                <div class="card-header">
                    <i class="fas fa-project-diagram"></i> Module 15: Data Structures
                </div>
                <div class="card-body">
                    <h5>Introduction to Data Structures</h5>
                    <p>Data structures are ways of organizing and storing data so that it can be accessed and modified efficiently. Different data structures are suited for different kinds of applications, and some are highly specialized to specific tasks.</p>
                    <p>Understanding data structures is crucial for writing efficient code and solving complex problems. In this module, we'll cover common data structures and their implementations in JavaScript.</p>

                    <h5>Arrays (Advanced)</h5>
                    <p>Arrays are one of the most fundamental data structures. In JavaScript, arrays are dynamic and can hold values of different types. We've covered basic array operations in previous modules, so let's focus on more advanced concepts.</p>

                    <h6>Multi-dimensional Arrays</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Creating a 2D array
const matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

// Accessing elements
console.log(matrix[0][0]); // 1
console.log(matrix[1][2]); // 6

// Iterating over a 2D array
for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[i].length; j++) {
        console.log(matrix[i][j]);
    }
}

// Creating a 3D array
const cube = [
    [
        [1, 2],
        [3, 4]
    ],
    [
        [5, 6],
        [7, 8]
    ]
];

console.log(cube[0][1][0]); // 3
</code></pre>

                    <h6>Sparse Arrays</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Creating a sparse array
const sparseArray = [];
sparseArray[0] = "a";
sparseArray[5] = "f";

console.log(sparseArray.length); // 6
console.log(sparseArray); // ["a", empty × 4, "f"]

// Checking if an index is empty
console.log(0 in sparseArray); // true
console.log(1 in sparseArray); // false

// Iterating over a sparse array
for (let i = 0; i < sparseArray.length; i++) {
    if (i in sparseArray) {
        console.log(i, sparseArray[i]);
    }
}
</code></pre>

                    <h5>Linked Lists</h5>
                    <p>A linked list is a linear data structure where elements are not stored at contiguous memory locations. Each element (node) contains a value and a pointer to the next node.</p>

                    <h6>Singly Linked List</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }
    
    // Add to the beginning of the list
    prepend(data) {
        const newNode = new Node(data);
        newNode.next = this.head;
        this.head = newNode;
        this.size++;
    }
    
    // Add to the end of the list
    append(data) {
        const newNode = new Node(data);
        
        if (!this.head) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = newNode;
        }
        this.size++;
    }
    
    // Insert at a specific index
    insertAt(data, index) {
        if (index < 0 || index > this.size) {
            return false;
        }
        
        if (index === 0) {
            this.prepend(data);
        } else {
            const newNode = new Node(data);
            let current = this.head;
            let previous;
            
            for (let i = 0; i < index; i++) {
                previous = current;
                current = current.next;
            }
            
            newNode.next = current;
            previous.next = newNode;
            this.size++;
        }
        return true;
    }
    
    // Remove at a specific index
    removeAt(index) {
        if (index < 0 || index >= this.size) {
            return null;
        }
        
        let current = this.head;
        let previous;
        
        if (index === 0) {
            this.head = current.next;
        } else {
            for (let i = 0; i < index; i++) {
                previous = current;
                current = current.next;
            }
            previous.next = current.next;
        }
        
        this.size--;
        return current.data;
    }
    
    // Get the data at a specific index
    get(index) {
        if (index < 0 || index >= this.size) {
            return null;
        }
        
        let current = this.head;
        for (let i = 0; i < index; i++) {
            current = current.next;
        }
        
        return current.data;
    }
    
    // Convert to array
    toArray() {
        const result = [];
        let current = this.head;
        
        while (current) {
            result.push(current.data);
            current = current.next;
        }
        
        return result;
    }
    
    // Print the list
    print() {
        let current = this.head;
        let result = "";
        
        while (current) {
            result += current.data + " -> ";
            current = current.next;
        }
        
        console.log(result + "null");
    }
}

// Using the linked list
const list = new LinkedList();
list.append(1);
list.append(2);
list.append(3);
list.prepend(0);
list.insertAt(1.5, 2);
list.print(); // "0 -> 1 -> 1.5 -> 2 -> 3 -> null"
console.log(list.get(2)); // 1.5
list.removeAt(2);
list.print(); // "0 -> 1 -> 2 -> 3 -> null"
console.log(list.toArray()); // [0, 1, 2, 3]
</code></pre>

                    <h6>Doubly Linked List</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class DoublyNode {
    constructor(data) {
        this.data = data;
        this.next = null;
        this.prev = null;
    }
}

class DoublyLinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    
    // Add to the beginning of the list
    prepend(data) {
        const newNode = new DoublyNode(data);
        
        if (!this.head) {
            this.head = newNode;
            this.tail = newNode;
        } else {
            newNode.next = this.head;
            this.head.prev = newNode;
            this.head = newNode;
        }
        
        this.size++;
    }
    
    // Add to the end of the list
    append(data) {
        const newNode = new DoublyNode(data);
        
        if (!this.tail) {
            this.head = newNode;
            this.tail = newNode;
        } else {
            newNode.prev = this.tail;
            this.tail.next = newNode;
            this.tail = newNode;
        }
        
        this.size++;
    }
    
    // Remove at a specific index
    removeAt(index) {
        if (index < 0 || index >= this.size) {
            return null;
        }
        
        let current = this.head;
        
        if (index === 0) {
            this.head = current.next;
            if (this.head) {
                this.head.prev = null;
            } else {
                this.tail = null;
            }
        } else if (index === this.size - 1) {
            current = this.tail;
            this.tail = current.prev;
            this.tail.next = null;
        } else {
            for (let i = 0; i < index; i++) {
                current = current.next;
            }
            
            current.prev.next = current.next;
            current.next.prev = current.prev;
        }
        
        this.size--;
        return current.data;
    }
    
    // Print the list forward
    printForward() {
        let current = this.head;
        let result = "";
        
        while (current) {
            result += current.data + " <-> ";
            current = current.next;
        }
        
        console.log(result + "null");
    }
    
    // Print the list backward
    printBackward() {
        let current = this.tail;
        let result = "";
        
        while (current) {
            result += current.data + " <-> ";
            current = current.prev;
        }
        
        console.log(result + "null");
    }
}

// Using the doubly linked list
const doublyList = new DoublyLinkedList();
doublyList.append(1);
doublyList.append(2);
doublyList.append(3);
doublyList.prepend(0);
doublyList.printForward(); // "0 <-> 1 <-> 2 <-> 3 <-> null"
doublyList.printBackward(); // "3 <-> 2 <-> 1 <-> 0 <-> null"
doublyList.removeAt(2);
doublyList.printForward(); // "0 <-> 1 <-> 3 <-> null"
</code></pre>

                    <h5>Stacks</h5>
                    <p>A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle. Elements can only be added and removed from the top of the stack.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class Stack {
    constructor() {
        this.items = [];
    }
    
    // Add an element to the top of the stack
    push(element) {
        this.items.push(element);
    }
    
    // Remove and return the top element of the stack
    pop() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items.pop();
    }
    
    // Return the top element of the stack without removing it
    peek() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items[this.items.length - 1];
    }
    
    // Check if the stack is empty
    isEmpty() {
        return this.items.length === 0;
    }
    
    // Return the size of the stack
    size() {
        return this.items.length;
    }
    
    // Clear the stack
    clear() {
        this.items = [];
    }
    
    // Print the stack
    print() {
        console.log(this.items.toString());
    }
}

// Using the stack
const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
stack.print(); // "1,2,3"
console.log(stack.pop()); // 3
console.log(stack.peek()); // 2
console.log(stack.size()); // 2
</code></pre>

                    <h5>Queues</h5>
                    <p>A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. Elements are added at the rear and removed from the front.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class Queue {
    constructor() {
        this.items = [];
    }
    
    // Add an element to the rear of the queue
    enqueue(element) {
        this.items.push(element);
    }
    
    // Remove and return the front element of the queue
    dequeue() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items.shift();
    }
    
    // Return the front element of the queue without removing it
    front() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items[0];
    }
    
    // Check if the queue is empty
    isEmpty() {
        return this.items.length === 0;
    }
    
    // Return the size of the queue
    size() {
        return this.items.length;
    }
    
    // Clear the queue
    clear() {
        this.items = [];
    }
    
    // Print the queue
    print() {
        console.log(this.items.toString());
    }
}

// Using the queue
const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);
queue.print(); // "1,2,3"
console.log(queue.dequeue()); // 1
console.log(queue.front()); // 2
console.log(queue.size()); // 2
</code></pre>

                    <h5>Priority Queue</h5>
                    <p>A priority queue is a special type of queue where each element has a priority associated with it. Elements with higher priority are served before elements with lower priority.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class PriorityQueue {
    constructor() {
        this.items = [];
    }
    
    // Add an element with a priority
    enqueue(element, priority) {
        const queueElement = { element, priority };
        let added = false;
        
        for (let i = 0; i < this.items.length; i++) {
            if (queueElement.priority < this.items[i].priority) {
                this.items.splice(i, 0, queueElement);
                added = true;
                break;
            }
        }
        
        if (!added) {
            this.items.push(queueElement);
        }
    }
    
    // Remove and return the element with the highest priority
    dequeue() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items.shift().element;
    }
    
    // Return the element with the highest priority without removing it
    front() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items[0].element;
    }
    
    // Check if the queue is empty
    isEmpty() {
        return this.items.length === 0;
    }
    
    // Return the size of the queue
    size() {
        return this.items.length;
    }
    
    // Print the queue
    print() {
        const result = this.items.map(item => `${item.element}(${item.priority})`);
        console.log(result.toString());
    }
}

// Using the priority queue
const priorityQueue = new PriorityQueue();
priorityQueue.enqueue("John", 2);
priorityQueue.enqueue("Jane", 1);
priorityQueue.enqueue("Bob", 3);
priorityQueue.print(); // "Jane(1),John(2),Bob(3)"
console.log(priorityQueue.dequeue()); // "Jane"
console.log(priorityQueue.front()); // "John"
</code></pre>

                    <h5>Trees</h5>
                    <p>A tree is a hierarchical data structure with a root node and child nodes. Each node contains a value and references to its child nodes.</p>

                    <h6>Binary Tree</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class TreeNode {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

class BinaryTree {
    constructor() {
        this.root = null;
    }
    
    // Insert a value into the tree
    insert(value) {
        const newNode = new TreeNode(value);
        
        if (!this.root) {
            this.root = newNode;
        } else {
            this.insertNode(this.root, newNode);
        }
    }
    
    insertNode(node, newNode) {
        if (newNode.value < node.value) {
            if (!node.left) {
                node.left = newNode;
            } else {
                this.insertNode(node.left, newNode);
            }
        } else {
            if (!node.right) {
                node.right = newNode;
            } else {
                this.insertNode(node.right, newNode);
            }
        }
    }
    
    // Search for a value in the tree
    search(value) {
        return this.searchNode(this.root, value);
    }
    
    searchNode(node, value) {
        if (!node) {
            return false;
        }
        
        if (value < node.value) {
            return this.searchNode(node.left, value);
        } else if (value > node.value) {
            return this.searchNode(node.right, value);
        } else {
            return true;
        }
    }
    
    // In-order traversal (left, root, right)
    inOrder(callback) {
        this.inOrderTraversal(this.root, callback);
    }
    
    inOrderTraversal(node, callback) {
        if (node) {
            this.inOrderTraversal(node.left, callback);
            callback(node.value);
            this.inOrderTraversal(node.right, callback);
        }
    }
    
    // Pre-order traversal (root, left, right)
    preOrder(callback) {
        this.preOrderTraversal(this.root, callback);
    }
    
    preOrderTraversal(node, callback) {
        if (node) {
            callback(node.value);
            this.preOrderTraversal(node.left, callback);
            this.preOrderTraversal(node.right, callback);
        }
    }
    
    // Post-order traversal (left, right, root)
    postOrder(callback) {
        this.postOrderTraversal(this.root, callback);
    }
    
    postOrderTraversal(node, callback) {
        if (node) {
            this.postOrderTraversal(node.left, callback);
            this.postOrderTraversal(node.right, callback);
            callback(node.value);
        }
    }
}

// Using the binary tree
const tree = new BinaryTree();
tree.insert(7);
tree.insert(4);
tree.insert(9);
tree.insert(1);
tree.insert(5);
tree.insert(8);
tree.insert(10);

console.log(tree.search(5)); // true
console.log(tree.search(6)); // false

console.log("In-order traversal:");
tree.inOrder(value => console.log(value)); // 1, 4, 5, 7, 8, 9, 10

console.log("Pre-order traversal:");
tree.preOrder(value => console.log(value)); // 7, 4, 1, 5, 9, 8, 10

console.log("Post-order traversal:");
tree.postOrder(value => console.log(value)); // 1, 5, 4, 8, 10, 9, 7
</code></pre>

                    <h5>Graphs</h5>
                    <p>A graph is a non-linear data structure consisting of vertices (nodes) and edges. Graphs can be directed or undirected, weighted or unweighted.</p>

                    <h6>Adjacency List Representation</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class Graph {
    constructor() {
        this.adjacencyList = {};
    }
    
    // Add a vertex
    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) {
            this.adjacencyList[vertex] = [];
        }
    }
    
    // Add an edge (undirected)
    addEdge(vertex1, vertex2) {
        if (!this.adjacencyList[vertex1] || !this.adjacencyList[vertex2]) {
            return false;
        }
        
        this.adjacencyList[vertex1].push(vertex2);
        this.adjacencyList[vertex2].push(vertex1);
        return true;
    }
    
    // Add a directed edge
    addDirectedEdge(from, to) {
        if (!this.adjacencyList[from] || !this.adjacencyList[to]) {
            return false;
        }
        
        this.adjacencyList[from].push(to);
        return true;
    }
    
    // Remove an edge
    removeEdge(vertex1, vertex2) {
        this.adjacencyList[vertex1] = this.adjacencyList[vertex1].filter(
            v => v !== vertex2
        );
        this.adjacencyList[vertex2] = this.adjacencyList[vertex2].filter(
            v => v !== vertex1
        );
    }
    
    // Remove a vertex
    removeVertex(vertex) {
        while (this.adjacencyList[vertex].length) {
            const adjacentVertex = this.adjacencyList[vertex].pop();
            this.removeEdge(vertex, adjacentVertex);
        }
        delete this.adjacencyList[vertex];
    }
    
    // Depth First Search (DFS)
    dfs(start) {
        const result = [];
        const visited = {};
        const stack = [start];
        visited[start] = true;
        
        while (stack.length) {
            const vertex = stack.pop();
            result.push(vertex);
            
            this.adjacencyList[vertex].forEach(neighbor => {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    stack.push(neighbor);
                }
            });
        }
        
        return result;
    }
    
    // Breadth First Search (BFS)
    bfs(start) {
        const result = [];
        const visited = {};
        const queue = [start];
        visited[start] = true;
        
        while (queue.length) {
            const vertex = queue.shift();
            result.push(vertex);
            
            this.adjacencyList[vertex].forEach(neighbor => {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.push(neighbor);
                }
            });
        }
        
        return result;
    }
    
    // Print the graph
    print() {
        for (const vertex in this.adjacencyList) {
            console.log(vertex + " -> " + this.adjacencyList[vertex].join(", "));
        }
    }
}

// Using the graph
const graph = new Graph();
graph.addVertex("A");
graph.addVertex("B");
graph.addVertex("C");
graph.addVertex("D");
graph.addVertex("E");
graph.addVertex("F");

graph.addEdge("A", "B");
graph.addEdge("A", "C");
graph.addEdge("B", "D");
graph.addEdge("C", "E");
graph.addEdge("D", "E");
graph.addEdge("D", "F");
graph.addEdge("E", "F");

graph.print();
// A -> B, C
// B -> A, D
// C -> A, E
// D -> B, E, F
// E -> C, D, F
// F -> D, E

console.log("DFS:", graph.dfs("A")); // ["A", "C", "E", "F", "D", "B"]
console.log("BFS:", graph.bfs("A")); // ["A", "B", "C", "D", "E", "F"]
</code></pre>

                    <h5>Hash Tables</h5>
                    <p>A hash table is a data structure that maps keys to values for highly efficient lookup. It uses a hash function to compute an index into an array of buckets or slots.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
class HashTable {
    constructor(size = 53) {
        this.keyMap = new Array(size);
    }
    
    // Hash function
    _hash(key) {
        let total = 0;
        let WEIRD_PRIME = 31;
        
        for (let i = 0; i < Math.min(key.length, 100); i++) {
            let char = key[i];
            let value = char.charCodeAt(0) - 96;
            total = (total * WEIRD_PRIME + value) % this.keyMap.length;
        }
        
        return total;
    }
    
    // Set a key-value pair
    set(key, value) {
        const index = this._hash(key);
        
        if (!this.keyMap[index]) {
            this.keyMap[index] = [];
        }
        
        // Check if the key already exists and update it
        for (let i = 0; i < this.keyMap[index].length; i++) {
            if (this.keyMap[index][i][0] === key) {
                this.keyMap[index][i][1] = value;
                return true;
            }
        }
        
        // Add a new key-value pair
        this.keyMap[index].push([key, value]);
        return true;
    }
    
    // Get a value by key
    get(key) {
        const index = this._hash(key);
        
        if (!this.keyMap[index]) {
            return undefined;
        }
        
        for (let i = 0; i < this.keyMap[index].length; i++) {
            if (this.keyMap[index][i][0] === key) {
                return this.keyMap[index][i][1];
            }
        }
        
        return undefined;
    }
    
    // Remove a key-value pair
    remove(key) {
        const index = this._hash(key);
        
        if (!this.keyMap[index]) {
            return false;
        }
        
        for (let i = 0; i < this.keyMap[index].length; i++) {
            if (this.keyMap[index][i][0] === key) {
                this.keyMap[index].splice(i, 1);
                return true;
            }
        }
        
        return false;
    }
    
    // Get all keys
    keys() {
        const keys = [];
        
        for (let i = 0; i < this.keyMap.length; i++) {
            if (this.keyMap[i]) {
                for (let j = 0; j < this.keyMap[i].length; j++) {
                    keys.push(this.keyMap[i][j][0]);
                }
            }
        }
        
        return keys;
    }
    
    // Get all values
    values() {
        const values = [];
        
        for (let i = 0; i < this.keyMap.length; i++) {
            if (this.keyMap[i]) {
                for (let j = 0; j < this.keyMap[i].length; j++) {
                    values.push(this.keyMap[i][j][1]);
                }
            }
        }
        
        return values;
    }
    
    // Print the hash table
    print() {
        for (let i = 0; i < this.keyMap.length; i++) {
            if (this.keyMap[i]) {
                console.log(i, this.keyMap[i]);
            }
        }
    }
}

// Using the hash table
const hashTable = new HashTable();
hashTable.set("name", "John");
hashTable.set("age", 25);
hashTable.set("email", "john@example.com");

console.log(hashTable.get("name")); // "John"
console.log(hashTable.get("age")); // 25
console.log(hashTable.get("email")); // "john@example.com"

hashTable.remove("age");
console.log(hashTable.get("age")); // undefined

console.log(hashTable.keys()); // ["name", "email"]
console.log(hashTable.values()); // ["John", "john@example.com"]
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try different data structures:</p>
                        <button onclick="useStack()">Use Stack</button>
                        <button onclick="useQueue()">Use Queue</button>
                        <button onclick="useLinkedList()">Use Linked List</button>
                        <div id="data-structure-output" style="margin-top: 10px; padding: 10px; border: 1px solid #ccc;">
                            Data structure output will appear here...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 16: Algorithms -->
            <div class="content-card" id="module16">
                <div class="card-header">
                    <i class="fas fa-chart-line"></i> Module 16: Algorithms
                </div>
                <div class="card-body">
                    <h5>Introduction to Algorithms</h5>
                    <p>An algorithm is a step-by-step procedure for solving a problem or completing a task. In computer science, algorithms are fundamental to writing efficient code. Understanding algorithms helps you choose the right approach for a problem and optimize your code for better performance.</p>
                    <p>Algorithms are often analyzed in terms of time complexity (how the runtime grows with input size) and space complexity (how much memory is used). Big O notation is commonly used to describe these complexities.</p>

                    <h5>Sorting Algorithms</h5>
                    <p>Sorting algorithms arrange elements in a specific order. Different sorting algorithms have different time and space complexities, making them suitable for different scenarios.</p>

                    <h6>Bubble Sort</h6>
                    <p>Bubble sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. It has a time complexity of O(n²).</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function bubbleSort(arr) {
    const n = arr.length;
    
    for (let i = 0; i < n - 1; i++) {
        let swapped = false;
        
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap elements
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                swapped = true;
            }
        }
        
        // If no swapping occurred, the array is sorted
        if (!swapped) break;
    }
    
    return arr;
}

// Using bubble sort
const unsortedArray = [64, 34, 25, 12, 22, 11, 90];
console.log(bubbleSort([...unsortedArray])); // [11, 12, 22, 25, 34, 64, 90]
</code></pre>

                    <h6>Selection Sort</h6>
                    <p>Selection sort divides the input into a sorted and an unsorted region, and repeatedly selects the smallest element from the unsorted region and moves it to the sorted region. It has a time complexity of O(n²).</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function selectionSort(arr) {
    const n = arr.length;
    
    for (let i = 0; i < n - 1; i++) {
        let minIndex = i;
        
        // Find the minimum element in the unsorted part
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        // Swap the found minimum element with the first element
        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
    
    return arr;
}

// Using selection sort
const unsortedArray = [64, 34, 25, 12, 22, 11, 90];
console.log(selectionSort([...unsortedArray])); // [11, 12, 22, 25, 34, 64, 90]
</code></pre>

                    <h6>Insertion Sort</h6>
                    <p>Insertion sort builds the final sorted array one item at a time. It's much less efficient on large lists than more advanced algorithms like quicksort, heapsort, or merge sort. It has a time complexity of O(n²).</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        let key = arr[i];
        let j = i - 1;
        
        // Move elements of arr[0..i-1] that are greater than key
        // to one position ahead of their current position
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = key;
    }
    
    return arr;
}

// Using insertion sort
const unsortedArray = [64, 34, 25, 12, 22, 11, 90];
console.log(insertionSort([...unsortedArray])); // [11, 12, 22, 25, 34, 64, 90]
</code></pre>

                    <h6>Merge Sort</h6>
                    <p>Merge sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves. It has a time complexity of O(n log n).</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    
    // Find the middle of the array
    const middle = Math.floor(arr.length / 2);
    
    // Divide the array into two halves
    const left = arr.slice(0, middle);
    const right = arr.slice(middle);
    
    // Recursively sort the two halves
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
    let result = [];
    let leftIndex = 0;
    let rightIndex = 0;
    
    // Compare elements from both arrays and add the smaller one to the result
    while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex] < right[rightIndex]) {
            result.push(left[leftIndex]);
            leftIndex++;
        } else {
            result.push(right[rightIndex]);
            rightIndex++;
        }
    }
    
    // Add the remaining elements from the left array
    while (leftIndex < left.length) {
        result.push(left[leftIndex]);
        leftIndex++;
    }
    
    // Add the remaining elements from the right array
    while (rightIndex < right.length) {
        result.push(right[rightIndex]);
        rightIndex++;
    }
    
    return result;
}

// Using merge sort
const unsortedArray = [64, 34, 25, 12, 22, 11, 90];
console.log(mergeSort([...unsortedArray])); // [11, 12, 22, 25, 34, 64, 90]
</code></pre>

                    <h6>Quick Sort</h6>
                    <p>Quick sort is a divide-and-conquer algorithm that picks an element as a pivot and partitions the array around the pivot, placing smaller elements to the left and larger elements to the right. It has an average time complexity of O(n log n) but a worst-case time complexity of O(n²).</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function quickSort(arr, left = 0, right = arr.length - 1) {
    if (left < right) {
        // Partition the array and get the pivot index
        const pivotIndex = partition(arr, left, right);
        
        // Recursively sort the elements before and after the pivot
        quickSort(arr, left, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, right);
    }
    
    return arr;
}

function partition(arr, left, right) {
    // Choose the rightmost element as the pivot
    const pivot = arr[right];
    
    // Index of the smaller element
    let i = left - 1;
    
    for (let j = left; j < right; j++) {
        // If the current element is smaller than the pivot
        if (arr[j] < pivot) {
            i++;
            // Swap arr[i] and arr[j]
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    
    // Swap arr[i+1] and arr[right] (the pivot)
    [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
    
    // Return the partition index
    return i + 1;
}

// Using quick sort
const unsortedArray = [64, 34, 25, 12, 22, 11, 90];
console.log(quickSort([...unsortedArray])); // [11, 12, 22, 25, 34, 64, 90]
</code></pre>

                    <h5>Searching Algorithms</h5>
                    <p>Searching algorithms are used to find a specific item in a collection of items. The efficiency of a search algorithm depends on the structure of the data and the specific requirements of the search.</p>

                    <h6>Linear Search</h6>
                    <p>Linear search sequentially checks each element of the list until a match is found or the whole list has been searched. It has a time complexity of O(n).</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Return the index of the found element
        }
    }
    return -1; // Return -1 if the element is not found
}

// Using linear search
const array = [2, 4, 0, 1, 9, 5, 3, 7];
console.log(linearSearch(array, 5)); // 5
console.log(linearSearch(array, 8)); // -1
</code></pre>

                    <h6>Binary Search</h6>
                    <p>Binary search works on sorted arrays by repeatedly dividing the search interval in half. It has a time complexity of O(log n).</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        // Find the middle index
        const middle = Math.floor((left + right) / 2);
        
        // Check if the middle element is the target
        if (arr[middle] === target) {
            return middle;
        }
        
        // If the target is in the left half
        if (arr[middle] > target) {
            right = middle - 1;
        }
        // If the target is in the right half
        else {
            left = middle + 1;
        }
    }
    
    return -1; // Return -1 if the element is not found
}

// Using binary search
const sortedArray = [0, 1, 2, 3, 4, 5, 7, 9];
console.log(binarySearch(sortedArray, 5)); // 5
console.log(binarySearch(sortedArray, 6)); // -1
</code></pre>

                    <h5>Recursive Algorithms</h5>
                    <p>Recursive algorithms solve problems by breaking them down into smaller subproblems of the same type. The solution to the problem is then constructed from the solutions to the subproblems.</p>

                    <h6>Factorial</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function factorial(n) {
    // Base case
    if (n <= 1) {
        return 1;
    }
    
    // Recursive case
    return n * factorial(n - 1);
}

// Using the factorial function
console.log(factorial(5)); // 120
console.log(factorial(0)); // 1
</code></pre>

                    <h6>Fibonacci</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Naive recursive Fibonacci (inefficient)
function fibonacci(n) {
    // Base cases
    if (n <= 1) {
        return n;
    }
    
    // Recursive case
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Optimized Fibonacci with memoization
function fibonacciMemo(n, memo = {}) {
    // Check if the result is already in the memo
    if (n in memo) {
        return memo[n];
    }
    
    // Base cases
    if (n <= 1) {
        return n;
    }
    
    // Recursive case with memoization
    memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
    return memo[n];
}

// Using the Fibonacci functions
console.log(fibonacci(10)); // 55
console.log(fibonacciMemo(10)); // 55
</code></pre>

                    <h5>Dynamic Programming</h5>
                    <p>Dynamic programming is a method for solving complex problems by breaking them down into simpler subproblems. It is applicable when the subproblems have overlapping sub-subproblems.</p>

                    <h6>Longest Common Subsequence</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function longestCommonSubsequence(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    
    // Create a table to store results of subproblems
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // Fill the table in a bottom-up manner
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}

// Using the LCS function
console.log(longestCommonSubsequence("AGGTAB", "GXTXAYB")); // 4 (GTAB)
</code></pre>

                    <h6>Knapsack Problem</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function knapsack(weights, values, capacity) {
    const n = weights.length;
    
    // Create a table to store results of subproblems
    const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));
    
    // Fill the table in a bottom-up manner
    for (let i = 1; i <= n; i++) {
        for (let w = 1; w <= capacity; w++) {
            if (weights[i - 1] <= w) {
                dp[i][w] = Math.max(
                    values[i - 1] + dp[i - 1][w - weights[i - 1]],
                    dp[i - 1][w]
                );
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }
    
    return dp[n][capacity];
}

// Using the knapsack function
const weights = [1, 3, 4, 5];
const values = [1, 4, 5, 7];
const capacity = 7;
console.log(knapsack(weights, values, capacity)); // 9
</code></pre>

                    <h5>Greedy Algorithms</h5>
                    <p>Greedy algorithms make locally optimal choices at each step with the hope of finding a global optimum. They are often simpler to implement than dynamic programming solutions but don't always produce the optimal solution.</p>

                    <h6>Activity Selection Problem</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function activitySelection(start, end) {
    const n = start.length;
    
    // Create an array of activities with start and end times
    const activities = [];
    for (let i = 0; i < n; i++) {
        activities.push({
            start: start[i],
            end: end[i],
            index: i
        });
    }
    
    // Sort activities by end time
    activities.sort((a, b) => a.end - b.end);
    
    // Select the first activity
    const selected = [activities[0].index];
    let lastEnd = activities[0].end;
    
    // Select the rest of the activities
    for (let i = 1; i < n; i++) {
        if (activities[i].start >= lastEnd) {
            selected.push(activities[i].index);
            lastEnd = activities[i].end;
        }
    }
    
    return selected;
}

// Using the activity selection function
const start = [1, 3, 0, 5, 8, 5];
const end = [2, 4, 6, 7, 9, 9];
console.log(activitySelection(start, end)); // [0, 1, 3, 4]
</code></pre>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try different algorithms:</p>
                        <input type="text" id="algorithm-input" placeholder="Enter comma-separated numbers">
                        <button onclick="runSortingAlgorithm()">Sort Array</button>
                        <button onclick="runSearchAlgorithm()">Search Array</button>
                        <div id="algorithm-output" style="margin-top: 10px; padding: 10px; border: 1px solid #ccc;">
                            Algorithm output will appear here...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 17: JavaScript Best Practices -->
            <div class="content-card" id="module17">
                <div class="card-header">
                    <i class="fas fa-award"></i> Module 17: JavaScript Best Practices
                </div>
                <div class="card-body">
                    <h5>Introduction to Best Practices</h5>
                    <p>Following best practices is essential for writing clean, efficient, and maintainable JavaScript code. These practices help you avoid common pitfalls, improve performance, and make your code easier to understand and modify.</p>
                    <p>In this module, we'll cover various best practices for JavaScript development, including code organization, performance optimization, security, and more.</p>

                    <h5>Code Organization</h5>
                    <p>Well-organized code is easier to read, understand, and maintain. Here are some best practices for organizing your JavaScript code:</p>

                    <h6>Use Modules</h6>
                    <p>Break your code into modules with single responsibilities. This makes your code more modular, reusable, and easier to test.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// math.js
export const PI = 3.14159;

export function add(a, b) {
    return a + b;
}

export function multiply(a, b) {
    return a * b;
}

// main.js
import { PI, add, multiply } from './math.js';

console.log(PI);
console.log(add(5, 3));
console.log(multiply(5, 3));
</code></pre>

                    <h6>Use Descriptive Names</h6>
                    <p>Use meaningful names for variables, functions, and classes. This makes your code self-documenting and easier to understand.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Bad
const d = new Date();
const u = users.filter(u => u.age > 18);

// Good
const currentDate = new Date();
const adultUsers = users.filter(user => user.age > 18);
</code></pre>

                    <h6>Keep Functions Small</h6>
                    <p>Functions should do one thing and do it well. Small functions are easier to test, understand, and reuse.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Bad
function processUsers(users) {
    const validUsers = [];
    for (let i = 0; i < users.length; i++) {
        if (users[i].age >= 18 && users[i].email) {
            validUsers.push(users[i]);
        }
    }
    
    const result = [];
    for (let i = 0; i < validUsers.length; i++) {
        result.push({
            id: validUsers[i].id,
            name: validUsers[i].name,
            email: validUsers[i].email
        });
    }
    
    return result;
}

// Good
function isAdult(user) {
    return user.age >= 18;
}

function hasEmail(user) {
    return !!user.email;
}

function isValidUser(user) {
    return isAdult(user) && hasEmail(user);
}

function formatUser(user) {
    return {
        id: user.id,
        name: user.name,
        email: user.email
    };
}

function processUsers(users) {
    return users
        .filter(isValidUser)
        .map(formatUser);
}
</code></pre>

                    <h5>Performance Optimization</h5>
                    <p>Optimizing your JavaScript code can significantly improve the performance of your web applications. Here are some best practices for performance optimization:</p>

                    <h6>Minimize DOM Manipulation</h6>
                    <p>DOM manipulation is expensive. Minimize the number of DOM operations by batching changes or using document fragments.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Bad
const list = document.getElementById("list");
for (let i = 0; i < 1000; i++) {
    const item = document.createElement("li");
    item.textContent = "Item " + i;
    list.appendChild(item);
}

// Good
const list = document.getElementById("list");
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
    const item = document.createElement("li");
    item.textContent = "Item " + i;
    fragment.appendChild(item);
}
list.appendChild(fragment);
</code></pre>

                    <h6>Use Event Delegation</h6>
                    <p>Instead of adding an event listener to each element, add a single event listener to a parent element and use event delegation.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Bad
const buttons = document.querySelectorAll(".button");
buttons.forEach(button => {
    button.addEventListener("click", function() {
        console.log("Button clicked");
    });
});

// Good
document.addEventListener("click", function(event) {
    if (event.target.matches(".button")) {
        console.log("Button clicked");
    }
});
</code></pre>

                    <h6>Use RequestAnimationFrame for Animations</h6>
                    <p>When creating animations, use requestAnimationFrame instead of setInterval or setTimeout for smoother animations and better performance.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Bad
let position = 0;
setInterval(() => {
    position += 1;
    element.style.left = position + "px";
}, 16);

// Good
let position = 0;
function animate() {
    position += 1;
    element.style.left = position + "px";
    requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</code></pre>

                    <h6>Optimize Loops</h6>
                    <p>Optimize loops by minimizing the work done inside the loop and using efficient iteration methods.</p>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Bad
for (let i = 0; i < array.length; i++) {
    // array.length is calculated in each iteration
    console.log(array[i]);
}

// Good
const length = array.length;
for (let i = 0; i < length; i++) {
    console.log(array[i]);
}

// Even better (for arrays)
for (const item of array) {
    console.log(item);
}
</code></pre>

                    <h5>Error Handling</h5>
                    <p>Proper error handling makes your code more robust and user-friendly. Here are some best practices for error handling:</p>

                    <h6>Use Try-Catch for Error-Prone Operations</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
try {
    const data = JSON.parse(jsonString);
    processData(data);
} catch (error) {
    console.error("Error parsing JSON:", error);
    showUserMessage("Invalid data format");
}
</code></pre>

                    <h6>Validate Input</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
function processUser(user) {
    if (!user || typeof user !== "object") {
        throw new Error("Invalid user object");
    }
    
    if (!user.name || typeof user.name !== "string") {
        throw new Error("Invalid user name");
    }
    
    if (!user.age || typeof user.age !== "number" || user.age < 0) {
        throw new Error("Invalid user age");
    }
    
    // Process user
}
</code></pre>

                    <h6>Handle Promises Properly</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Bad
fetch("/api/data")
    .then(response => response.json())
    .then(data => processData(data)); // No error handling

// Good
fetch("/api/data")
    .then(response => {
        if (!response.ok) {
            throw new Error("Network response was not ok");
        }
        return response.json();
    })
    .then(data => processData(data))
    .catch(error => {
        console.error("Error fetching data:", error);
        showUserMessage("Failed to load data");
    });

// Even better with async/await
async function fetchData() {
    try {
        const response = await fetch("/api/data");
        
        if (!response.ok) {
            throw new Error("Network response was not ok");
        }
        
        const data = await response.json();
        return processData(data);
    } catch (error) {
        console.error("Error fetching data:", error);
        showUserMessage("Failed to load data");
    }
}
</code></pre>

                    <h5>Security</h5>
                    <p>Security is crucial in web development. Here are some best practices for writing secure JavaScript code:</p>

                    <h6>Avoid eval()</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Bad - eval can execute arbitrary code
const code = "alert('XSS attack')";
eval(code);

// Good - Use JSON.parse for parsing JSON
const jsonString = '{"name": "John", "age": 25}';
const data = JSON.parse(jsonString);
</code></pre>

                    <h6>Sanitize User Input</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Bad - Directly using user input
element.innerHTML = userInput;

// Good - Sanitize user input
element.textContent = userInput;

// If you need to use HTML, sanitize it first
function sanitizeHTML(str) {
    return str.replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&#039;");
}

element.innerHTML = sanitizeHTML(userInput);
</code></pre>

                    <h6>Use HTTPS</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Bad - Using HTTP
fetch("http://api.example.com/data");

// Good - Using HTTPS
fetch("https://api.example.com/data");
</code></pre>

                    <h5>Testing</h5>
                    <p>Testing is essential for ensuring the quality and reliability of your code. Here are some best practices for testing JavaScript code:</p>

                    <h6>Write Unit Tests</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// math.js
export function add(a, b) {
    return a + b;
}

// math.test.js
import { add } from "./math.js";

function testAdd() {
    if (add(2, 3) !== 5) {
        throw new Error("add(2, 3) should return 5");
    }
    
    if (add(-1, 1) !== 0) {
        throw new Error("add(-1, 1) should return 0");
    }
    
    console.log("All add tests passed");
}

testAdd();
</code></pre>

                    <h6>Use Test Frameworks</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Using Jest
import { add } from "./math.js";

test("adds 1 + 2 to equal 3", () => {
    expect(add(1, 2)).toBe(3);
});

test("adds -1 + 1 to equal 0", () => {
    expect(add(-1, 1)).toBe(0);
});
</code></pre>

                    <h5>Code Style and Formatting</h6>
                    <p>Consistent code style and formatting make your code easier to read and maintain. Here are some best practices:</p>

                    <h6>Use a Linter</h6>
                    <p>Use a linter like ESLint to enforce consistent code style and catch potential errors.</p>

                    <h6>Use a Formatter</h6>
                    <p>Use a formatter like Prettier to automatically format your code according to a consistent style.</p>

                    <h6>Follow Naming Conventions</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// Variables and functions: camelCase
const userName = "John";
function calculateTotal() {}

// Classes: PascalCase
class UserAccount {}

// Constants: UPPER_SNAKE_CASE
const API_URL = "https://api.example.com";

// Private properties: underscore prefix
class User {
    constructor() {
        this._id = null;
    }
}
</code></pre>

                    <h5>Documentation</h6>
                    <p>Good documentation makes your code easier to understand and use. Here are some best practices for documenting your code:</p>

                    <h6>Use JSDoc</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
/**
 * Calculates the sum of two numbers.
 * @param {number} a - The first number.
 * @param {number} b - The second number.
 * @returns {number} The sum of a and b.
 * @example
 * // returns 5
 * add(2, 3);
 */
function add(a, b) {
    return a + b;
}
</code></pre>

                    <h6>Write README Files</h6>
                    <p>Write a README file for your projects that explains what the project does, how to install and use it, and how to contribute.</p>

                    <h5>Interactive Example</h5>
                    <div class="interactive-demo">
                        <p>Try applying best practices:</p>
                        <button onclick="refactorCode()">Refactor Code</button>
                        <button onclick="optimizePerformance()">Optimize Performance</button>
                        <button onclick="handleErrors()">Handle Errors</button>
                        <div id="best-practices-output" style="margin-top: 10px; padding: 10px; border: 1px solid #ccc;">
                            Best practices output will appear here...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 18: Final Project -->
            <div class="content-card" id="module18">
                <div class="card-header">
                    <i class="fas fa-rocket"></i> Module 18: Final Project
                </div>
                <div class="card-body">
                    <h5>Project Overview</h5>
                    <p>For the final project, you'll create a comprehensive web application that demonstrates all the JavaScript concepts learned throughout the course. This project will include DOM manipulation, event handling, asynchronous operations, and a polished user interface.</p>
                    <p>The project will be a task management application that allows users to create, read, update, and delete tasks. It will also include features like filtering, sorting, and local storage for persistence.</p>

                    <h5>Project Structure</h5>
                    <pre><button class="copy-button">Copy</button><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Task Manager&lt;/title&gt;
    &lt;link rel="stylesheet" href="styles.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;
        &lt;h1&gt;Task Manager&lt;/h1&gt;
    &lt;/header&gt;
    
    &lt;main&gt;
        &lt;section id="task-form"&gt;
            &lt;form&gt;
                &lt;div&gt;
                    &lt;label for="title"&gt;Title:&lt;/label&gt;
                    &lt;input type="text" id="title" required&gt;
                &lt;/div&gt;
                &lt;div&gt;
                    &lt;label for="description"&gt;Description:&lt;/label&gt;
                    &lt;textarea id="description"&gt;&lt;/textarea&gt;
                &lt;/div&gt;
                &lt;div&gt;
                    &lt;label for="due-date"&gt;Due Date:&lt;/label&gt;
                    &lt;input type="date" id="due-date"&gt;
                &lt;/div&gt;
                &lt;div&gt;
                    &lt;label for="priority"&gt;Priority:&lt;/label&gt;
                    &lt;select id="priority"&gt;
                        &lt;option value="low"&gt;Low&lt;/option&gt;
                        &lt;option value="medium"&gt;Medium&lt;/option&gt;
                        &lt;option value="high"&gt;High&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
                &lt;button type="submit"&gt;Add Task&lt;/button&gt;
            &lt;/form&gt;
        &lt;/section&gt;
        
        &lt;section id="task-filters"&gt;
            &lt;div&gt;
                &lt;label for="filter-status"&gt;Filter by Status:&lt;/label&gt;
                &lt;select id="filter-status"&gt;
                    &lt;option value="all"&gt;All&lt;/option&gt;
                    &lt;option value="pending"&gt;Pending&lt;/option&gt;
                    &lt;option value="completed"&gt;Completed&lt;/option&gt;
                &lt;/select&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;label for="filter-priority"&gt;Filter by Priority:&lt;/label&gt;
                &lt;select id="filter-priority"&gt;
                    &lt;option value="all"&gt;All&lt;/option&gt;
                    &lt;option value="low"&gt;Low&lt;/option&gt;
                    &lt;option value="medium"&gt;Medium&lt;/option&gt;
                    &lt;option value="high"&gt;High&lt;/option&gt;
                &lt;/select&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;label for="sort-by"&gt;Sort By:&lt;/label&gt;
                &lt;select id="sort-by"&gt;
                    &lt;option value="due-date"&gt;Due Date&lt;/option&gt;
                    &lt;option value="priority"&gt;Priority&lt;/option&gt;
                    &lt;option value="title"&gt;Title&lt;/option&gt;
                &lt;/select&gt;
            &lt;/div&gt;
        &lt;/section&gt;
        
        &lt;section id="task-list"&gt;
            &lt;h2&gt;Tasks&lt;/h2&gt;
            &lt;div id="tasks"&gt;&lt;/div&gt;
        &lt;/section&gt;
    &lt;/main&gt;
    
    &lt;footer&gt;
        &lt;p&gt;&copy; 2023 Task Manager&lt;/p&gt;
    &lt;/footer&gt;
    
    &lt;script type="module" src="app.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

                    <h5>CSS Styling</h5>
                    <pre><button class="copy-button">Copy</button><code class="language-css">
/* styles.css */
:root {
    --primary-color: #4a6cf7;
    --secondary-color: #6c757d;
    --success-color: #28a745;
    --danger-color: #dc3545;
    --warning-color: #ffc107;
    --light-color: #f8f9fa;
    --dark-color: #343a40;
    --border-radius: 0.25rem;
    --box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    color: var(--dark-color);
    background-color: var(--light-color);
}

header {
    background-color: var(--primary-color);
    color: white;
    padding: 1rem;
    text-align: center;
}

main {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
}

section {
    background-color: white;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    padding: 1.5rem;
    margin-bottom: 2rem;
}

form {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
}

form div {
    display: flex;
    flex-direction: column;
}

label {
    margin-bottom: 0.5rem;
    font-weight: 500;
}

input, textarea, select, button {
    padding: 0.75rem;
    border: 1px solid #ced4da;
    border-radius: var(--border-radius);
    font-size: 1rem;
}

button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s;
}

button:hover {
    background-color: #3a5bd9;
}

#task-filters {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
}

#task-filters > div {
    flex: 1;
    min-width: 200px;
}

.task {
    border: 1px solid #ced4da;
    border-radius: var(--border-radius);
    padding: 1rem;
    margin-bottom: 1rem;
    position: relative;
}

.task.completed {
    background-color: #f8f9fa;
    text-decoration: line-through;
}

.task-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.task-title {
    font-weight: 600;
    font-size: 1.1rem;
}

.task-priority {
    padding: 0.25rem 0.5rem;
    border-radius: var(--border-radius);
    font-size: 0.8rem;
    font-weight: 500;
}

.priority-high {
    background-color: var(--danger-color);
    color: white;
}

.priority-medium {
    background-color: var(--warning-color);
    color: var(--dark-color);
}

.priority-low {
    background-color: var(--success-color);
    color: white;
}

.task-description {
    margin-bottom: 0.5rem;
}

.task-meta {
    display: flex;
    justify-content: space-between;
    font-size: 0.9rem;
    color: var(--secondary-color);
}

.task-actions {
    position: absolute;
    top: 1rem;
    right: 1rem;
    display: flex;
    gap: 0.5rem;
}

.task-actions button {
    padding: 0.25rem 0.5rem;
    font-size: 0.8rem;
}

.edit-btn {
    background-color: var(--warning-color);
}

.delete-btn {
    background-color: var(--danger-color);
}

footer {
    text-align: center;
    padding: 1rem;
    color: var(--secondary-color);
}

@media (max-width: 768px) {
    main {
        padding: 1rem;
    }
    
    form {
        grid-template-columns: 1fr;
    }
    
    #task-filters {
        flex-direction: column;
    }
    
    #task-filters > div {
        min-width: auto;
    }
}
</code></pre>

                    <h5>JavaScript Implementation</h5>
                    <pre><button class="copy-button">Copy</button><code class="language-javascript">
// app.js
// Task class
class Task {
    constructor(title, description, dueDate, priority, status = 'pending') {
        this.id = Date.now().toString();
        this.title = title;
        this.description = description;
        this.dueDate = dueDate;
        this.priority = priority;
        this.status = status;
    }
    
    static fromJSON(json) {
        const task = new Task(
            json.title,
            json.description,
            json.dueDate,
            json.priority,
            json.status
        );
        task.id = json.id;
        return task;
    }
}

// Task Manager class
class TaskManager {
    constructor() {
        this.tasks = this.loadTasks();
        this.filterStatus = 'all';
        this.filterPriority = 'all';
        this.sortBy = 'due-date';
        this.init();
    }
    
    init() {
        this.bindEvents();
        this.renderTasks();
    }
    
    bindEvents() {
        // Form submission
        document.getElementById('task-form').addEventListener('submit', (e) => {
            e.preventDefault();
            this.addTask();
        });
        
        // Filter changes
        document.getElementById('filter-status').addEventListener('change', (e) => {
            this.filterStatus = e.target.value;
            this.renderTasks();
        });
        
        document.getElementById('filter-priority').addEventListener('change', (e) => {
            this.filterPriority = e.target.value;
            this.renderTasks();
        });
        
        // Sort change
        document.getElementById('sort-by').addEventListener('change', (e) => {
            this.sortBy = e.target.value;
            this.renderTasks();
        });
    }
    
    addTask() {
        const title = document.getElementById('title').value.trim();
        const description = document.getElementById('description').value.trim();
        const dueDate = document.getElementById('due-date').value;
        const priority = document.getElementById('priority').value;
        
        if (!title) {
            this.showMessage('Please enter a task title', 'error');
            return;
        }
        
        const task = new Task(title, description, dueDate, priority);
        this.tasks.push(task);
        this.saveTasks();
        this.renderTasks();
        this.resetForm();
        this.showMessage('Task added successfully', 'success');
    }
    
    updateTask(id, updatedTask) {
        const index = this.tasks.findIndex(task => task.id === id);
        if (index !== -1) {
            this.tasks[index] = { ...this.tasks[index], ...updatedTask };
            this.saveTasks();
            this.renderTasks();
            this.showMessage('Task updated successfully', 'success');
        }
    }
    
    deleteTask(id) {
        if (confirm('Are you sure you want to delete this task?')) {
            this.tasks = this.tasks.filter(task => task.id !== id);
            this.saveTasks();
            this.renderTasks();
            this.showMessage('Task deleted successfully', 'success');
        }
    }
    
    toggleTaskStatus(id) {
        const task = this.tasks.find(task => task.id === id);
        if (task) {
            task.status = task.status === 'pending' ? 'completed' : 'pending';
            this.saveTasks();
            this.renderTasks();
        }
    }
    
    getFilteredAndSortedTasks() {
        let filteredTasks = [...this.tasks];
        
        // Apply filters
        if (this.filterStatus !== 'all') {
            filteredTasks = filteredTasks.filter(task => task.status === this.filterStatus);
        }
        
        if (this.filterPriority !== 'all') {
            filteredTasks = filteredTasks.filter(task => task.priority === this.filterPriority);
        }
        
        // Apply sorting
        filteredTasks.sort((a, b) => {
            switch (this.sortBy) {
                case 'due-date':
                    return new Date(a.dueDate) - new Date(b.dueDate);
                case 'priority':
                    const priorityOrder = { high: 0, medium: 1, low: 2 };
                    return priorityOrder[a.priority] - priorityOrder[b.priority];
                case 'title':
                    return a.title.localeCompare(b.title);
                default:
                    return 0;
            }
        });
        
        return filteredTasks;
    }
    
    renderTasks() {
        const tasksContainer = document.getElementById('tasks');
        const tasks = this.getFilteredAndSortedTasks();
        
        if (tasks.length === 0) {
            tasksContainer.innerHTML = '<p>No tasks found</p>';
            return;
        }
        
        tasksContainer.innerHTML = tasks.map(task => this.createTaskHTML(task)).join('');
        
        // Add event listeners to task actions
        tasks.forEach(task => {
            const deleteBtn = document.getElementById(`delete-${task.id}`);
            const editBtn = document.getElementById(`edit-${task.id}`);
            const toggleBtn = document.getElementById(`toggle-${task.id}`);
            
            if (deleteBtn) {
                deleteBtn.addEventListener('click', () => this.deleteTask(task.id));
            }
            
            if (editBtn) {
                editBtn.addEventListener('click', () => this.editTask(task.id));
            }
            
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => this.toggleTaskStatus(task.id));
            }
        });
    }
    
    createTaskHTML(task) {
        const dueDate = task.dueDate ? new Date(task.dueDate).toLocaleDateString() : 'No due date';
        const isCompleted = task.status === 'completed';
        
        return `
            <div class="task ${isCompleted ? 'completed' : ''}">
                <div class="task-header">
                    <div class="task-title">${task.title}</div>
                    <div class="task-priority priority-${task.priority}">${task.priority}</div>
                </div>
                ${task.description ? `<div class="task-description">${task.description}</div>` : ''}
                <div class="task-meta">
                    <div>Due: ${dueDate}</div>
                    <div>Status: ${task.status}</div>
                </div>
                <div class="task-actions">
                    <button id="toggle-${task.id}" class="toggle-btn">
                        ${isCompleted ? 'Mark Pending' : 'Mark Complete'}
                    </button>
                    <button id="edit-${task.id}" class="edit-btn">Edit</button>
                    <button id="delete-${task.id}" class="delete-btn">Delete</button>
                </div>
            </div>
        `;
    }
    
    editTask(id) {
        const task = this.tasks.find(task => task.id === id);
        if (!task) return;
        
        // Populate form with task data
        document.getElementById('title').value = task.title;
        document.getElementById('description').value = task.description;
        document.getElementById('due-date').value = task.dueDate;
        document.getElementById('priority').value = task.priority;
        
        // Change form submission to update instead of add
        const form = document.getElementById('task-form');
        form.removeEventListener('submit', this.addTaskHandler);
        
        const updateHandler = (e) => {
            e.preventDefault();
            
            const title = document.getElementById('title').value.trim();
            const description = document.getElementById('description').value.trim();
            const dueDate = document.getElementById('due-date').value;
            const priority = document.getElementById('priority').value;
            
            if (!title) {
                this.showMessage('Please enter a task title', 'error');
                return;
            }
            
            this.updateTask(id, { title, description, dueDate, priority });
            
            // Reset form to add mode
            form.removeEventListener('submit', updateHandler);
            form.addEventListener('submit', this.addTaskHandler);
            this.resetForm();
        };
        
        form.addEventListener('submit', updateHandler);
        
        // Scroll to form
        document.getElementById('task-form').scrollIntoView({ behavior: 'smooth' });
    }
    
    resetForm() {
        document.getElementById('task-form').reset();
    }
    
    showMessage(message, type) {
        // Create message element
        const messageEl = document.createElement('div');
        messageEl.className = `message ${type}`;
        messageEl.textContent = message;
        
        // Style the message
        messageEl.style.padding = '1rem';
        messageEl.style.marginBottom = '1rem';
        messageEl.style.borderRadius = 'var(--border-radius)';
        
        if (type === 'success') {
            messageEl.style.backgroundColor = '#d4edda';
            messageEl.style.color = '#155724';
            messageEl.style.border = '1px solid #c3e6cb';
        } else if (type === 'error') {
            messageEl.style.backgroundColor = '#f8d7da';
            messageEl.style.color = '#721c24';
            messageEl.style.border = '1px solid #f5c6cb';
        }
        
        // Insert message at the top of main
        const main = document.querySelector('main');
        main.insertBefore(messageEl, main.firstChild);
        
        // Remove message after 3 seconds
        setTimeout(() => {
            messageEl.remove();
        }, 3000);
    }
    
    saveTasks() {
        localStorage.setItem('tasks', JSON.stringify(this.tasks));
    }
    
    loadTasks() {
        const tasksJSON = localStorage.getItem('tasks');
        if (tasksJSON) {
            try {
                const tasksData = JSON.parse(tasksJSON);
                return tasksData.map(taskData => Task.fromJSON(taskData));
            } catch (error) {
                console.error('Error loading tasks:', error);
                return [];
            }
        }
        return [];
    }
}

// Initialize the app
document.addEventListener('DOMContentLoaded', () => {
    new TaskManager();
});
</code></pre>

                    <h5>Project Features</h5>
                    <ul>
                        <li><strong>CRUD Operations:</strong> Create, Read, Update, and Delete tasks</li>
                        <li><strong>Filtering:</strong> Filter tasks by status and priority</li>
                        <li><strong>Sorting:</strong> Sort tasks by due date, priority, or title</li>
                        <li><strong>Local Storage:</strong> Persist tasks in local storage</li>
                        <li><strong>Responsive Design:</strong> Works on different screen sizes</li>
                        <li><strong>Form Validation:</strong> Validate user input</li>
                        <li><strong>User Feedback:</strong> Show success and error messages</li>
                        <li><strong>Modern JavaScript:</strong> Uses ES6+ features like classes, arrow functions, and modules</li>
                    </ul>

                    <h5>Project Extensions</h5>
                    <p>Once you've implemented the basic task manager, consider these extensions:</p>
                    <ul>
                        <li>Add user authentication and authorization</li>
                        <li>Implement drag-and-drop to reorder tasks</li>
                        <li>Add categories or tags to tasks</li>
                        <li>Implement a search functionality</li>
                        <li>Add a calendar view for tasks</li>
                        <li>Implement task reminders or notifications</li>
                        <li>Add data visualization for task statistics</li>
                        <li>Implement collaborative features for sharing tasks</li>
                    </ul>

                    <h5>Interactive Demo</h5>
                    <div class="interactive-demo">
                        <p>Try the task manager:</p>
                        <button onclick="loadTaskManager()">Load Task Manager</button>
                        <div id="task-manager-demo" style="margin-top: 10px; padding: 10px; border: 1px solid #ccc;">
                            Task manager will appear here...
                        </div>
                    </div>
                </div>
            </div>

            <div class="mt-5 text-center">
                <a href="/practice" class="btn btn-primary btn-lg">Take Practice Test</a>
            </div>

            <div id="animation-container-docs" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1;"></div>
        </div>
    </div>

    <script>
        // Smooth scrolling for sidebar navigation
        document.querySelectorAll('.sidebar .nav-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth' });
                }
                // Update active state
                document.querySelectorAll('.sidebar .nav-link').forEach(l => l.classList.remove('active'));
                this.classList.add('active');
            });
        });

        // Search functionality
        document.getElementById('search-input').addEventListener('input', function() {
            const query = this.value.toLowerCase();
            const content = document.getElementById('content');
            const elements = content.querySelectorAll('h2, h3, h4, h5, h6, p, pre, .card');
            
            elements.forEach(element => {
                const text = element.textContent.toLowerCase();
                if (query === '' || text.includes(query)) {
                    element.style.display = '';
                } else {
                    element.style.display = 'none';
                }
            });
        });

        // Clear search function
        function clearSearch() {
            document.getElementById('search-input').value = '';
            const content = document.getElementById('content');
            const elements = content.querySelectorAll('h2, h3, h4, h5, h6, p, pre, .card');
            elements.forEach(element => {
                element.style.display = '';
            });
        }

        // Copy to clipboard functionality
        const copyButtons = document.querySelectorAll('.copy-button');
        copyButtons.forEach(button => {
            button.addEventListener('click', function() {
                const code = this.parentNode.querySelector('code').textContent;
                navigator.clipboard.writeText(code);
                this.textContent = 'Copied!';
                setTimeout(() => {
                    this.textContent = 'Copy';
                }, 2000);
            });
        });

        // Highlight active section in sidebar based on scroll position
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('[id]');
            const navLinks = document.querySelectorAll('.sidebar .nav-link');

            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (pageYOffset >= sectionTop - 100) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        });

        // Interactive demo functions
        function checkVariableType() {
            const input = document.getElementById('variable-value').value;
            const resultDiv = document.getElementById('type-result');
            
            let type;
            try {
                // Try to parse as JSON first
                const parsed = JSON.parse(input);
                type = typeof parsed;
            } catch (e) {
                // If not valid JSON, treat as string
                type = typeof input;
            }
            
            resultDiv.innerHTML = `<p>Value: ${input}</p><p>Type: ${type}</p>`;
        }

        function calculateResult() {
            const operand1 = document.getElementById('operand1').value;
            const operand2 = document.getElementById('operand2').value;
            const operator = document.getElementById('operator').value;
            const resultDiv = document.getElementById('calculation-result');
            
            let result;
            try {
                // Convert operands to numbers if possible
                const num1 = isNaN(operand1) ? operand1 : Number(operand1);
                const num2 = isNaN(operand2) ? operand2 : Number(operand2);
                
                switch (operator) {
                    case '+':
                        result = num1 + num2;
                        break;
                    case '-':
                        result = num1 - num2;
                        break;
                    case '*':
                        result = num1 * num2;
                        break;
                    case '/':
                        result = num1 / num2;
                        break;
                    case '%':
                        result = num1 % num2;
                        break;
                    case '**':
                        result = num1 ** num2;
                        break;
                    case '==':
                        result = num1 == num2;
                        break;
                    case '===':
                        result = num1 === num2;
                        break;
                    case '!=':
                        result = num1 != num2;
                        break;
                    case '!==':
                        result = num1 !== num2;
                        break;
                    case '>':
                        result = num1 > num2;
                        break;
                    case '<':
                        result = num1 < num2;
                        break;
                    case '>=':
                        result = num1 >= num2;
                        break;
                    case '<=':
                        result = num1 <= num2;
                        break;
                    default:
                        result = 'Invalid operator';
                }
                
                resultDiv.innerHTML = `<p>Result: ${result}</p>`;
            } catch (error) {
                resultDiv.innerHTML = `<p>Error: ${error.message}</p>`;
            }
        }

        function runForLoop() {
            const count = parseInt(document.getElementById('loop-count').value) || 5;
            const outputDiv = document.getElementById('loop-output');
            
            let output = '<p>For loop output:</p>';
            for (let i = 0; i < count; i++) {
                output += `<p>${i}</p>`;
            }
            
            outputDiv.innerHTML = output;
        }

        function runWhileLoop() {
            const count = parseInt(document.getElementById('loop-count').value) || 5;
            const outputDiv = document.getElementById('loop-output');
            
            let output = '<p>While loop output:</p>';
            let i = 0;
            while (i < count) {
                output += `<p>${i}</p>`;
                i++;
            }
            
            outputDiv.innerHTML = output;
        }

        function callCustomFunction() {
            const param = document.getElementById('function-param').value;
            const resultDiv = document.getElementById('function-result');
            
            // Define a custom function
            function greet(name = 'Guest') {
                return `Hello, ${name}!`;
            }
            
            const result = greet(param);
            resultDiv.innerHTML = `<p>Function result: ${result}</p>`;
        }

        function addObjectProperty() {
            const key = document.getElementById('object-key').value;
            const value = document.getElementById('object-value').value;
            const displayDiv = document.getElementById('object-display');
            
            // Create or update the object
            if (!window.demoObject) {
                window.demoObject = {};
            }
            
            window.demoObject[key] = value;
            
            displayDiv.innerHTML = `<p>Object: ${JSON.stringify(window.demoObject, null, 2)}</p>`;
        }

        function showObject() {
            const displayDiv = document.getElementById('object-display');
            
            if (window.demoObject) {
                displayDiv.innerHTML = `<p>Object: ${JSON.stringify(window.demoObject, null, 2)}</p>`;
            } else {
                displayDiv.innerHTML = '<p>No object created yet</p>';
            }
        }

        function createArray() {
            const input = document.getElementById('array-input').value;
            const resultDiv = document.getElementById('array-result');
            
            if (!input) {
                resultDiv.innerHTML = '<p>Please enter some values</p>';
                return;
            }
            
            const array = input.split(',').map(item => {
                const trimmed = item.trim();
                // Try to parse as number, otherwise keep as string
                return isNaN(trimmed) ? trimmed : Number(trimmed);
            });
            
            window.demoArray = array;
            resultDiv.innerHTML = `<p>Array: [${array.join(', ')}]</p>`;
        }

        function sortArray() {
            if (!window.demoArray) {
                document.getElementById('array-result').innerHTML = '<p>No array created yet</p>';
                return;
            }
            
            const sorted = [...window.demoArray].sort((a, b) => {
                if (typeof a === 'number' && typeof b === 'number') {
                    return a - b;
                }
                return String(a).localeCompare(String(b));
            });
            
            document.getElementById('array-result').innerHTML = `<p>Sorted: [${sorted.join(', ')}]</p>`;
        }

        function reverseArray() {
            if (!window.demoArray) {
                document.getElementById('array-result').innerHTML = '<p>No array created yet</p>';
                return;
            }
            
            const reversed = [...window.demoArray].reverse();
            document.getElementById('array-result').innerHTML = `<p>Reversed: [${reversed.join(', ')}]</p>`;
        }

        function filterArray() {
            if (!window.demoArray) {
                document.getElementById('array-result').innerHTML = '<p>No array created yet</p>';
                return;
            }
            
            const evens = window.demoArray.filter(item => typeof item === 'number' && item % 2 === 0);
            document.getElementById('array-result').innerHTML = `<p>Even numbers: [${evens.join(', ')}]</p>`;
        }

        function useES6Features() {
            const name = document.getElementById('es6-name').value;
            const age = document.getElementById('es6-age').value;
            const resultDiv = document.getElementById('es6-result');
            
            // Create an object using enhanced object literals
            const person = {
                name,
                age: parseInt(age) || 0,
                greet() {
                    return `Hello, I'm ${this.name} and I'm ${this.age} years old.`;
                }
            };
            
            // Use template literals
            const message = `Person created: ${person.name}, ${person.age}`;
            
            // Use destructuring
            const { name: personName, age: personAge } = person;
            
            resultDiv.innerHTML = `
                <p>${message}</p>
                <p>Greeting: ${person.greet()}</p>
                <p>Destructured: ${personName}, ${personAge}</p>
            `;
        }

        function createElement() {
            const demoDiv = document.getElementById('dom-demo');
            const newElement = document.createElement('p');
            newElement.textContent = `New element created at ${new Date().toLocaleTimeString()}`;
            demoDiv.appendChild(newElement);
        }

        function changeStyle() {
            const demoDiv = document.getElementById('dom-demo');
            const currentColor = demoDiv.style.backgroundColor;
            
            if (currentColor === 'lightblue') {
                demoDiv.style.backgroundColor = 'lightgreen';
            } else {
                demoDiv.style.backgroundColor = 'lightblue';
            }
        }

        function addElement() {
            const demoDiv = document.getElementById('dom-demo');
            const newElement = document.createElement('div');
            newElement.textContent = `Added element at ${new Date().toLocaleTimeString()}`;
            newElement.style.marginTop = '10px';
            newElement.style.padding = '5px';
            newElement.style.border = '1px solid #ccc';
            demoDiv.appendChild(newElement);
        }

        function removeElement() {
            const demoDiv = document.getElementById('dom-demo');
            if (demoDiv.lastChild && demoDiv.lastChild.id !== 'dom-demo') {
                demoDiv.removeChild(demoDiv.lastChild);
            }
        }

        // Initialize event button
        document.getElementById('event-button').addEventListener('click', function() {
            document.getElementById('event-output').innerHTML += '<p>Button clicked at ' + new Date().toLocaleTimeString() + '</p>';
        });

        // Initialize input event
        document.getElementById('event-input').addEventListener('input', function() {
            document.getElementById('event-output').innerHTML = '<p>Input value: ' + this.value + '</p>';
        });

        function runAsyncOperation() {
            const outputDiv = document.getElementById('async-output');
            outputDiv.innerHTML = '<p>Starting async operation...</p>';
            
            setTimeout(() => {
                outputDiv.innerHTML += '<p>Async operation completed after 2 seconds!</p>';
            }, 2000);
        }

        function runPromiseChain() {
            const outputDiv = document.getElementById('async-output');
            outputDiv.innerHTML = '<p>Starting promise chain...</p>';
            
            new Promise(resolve => {
                setTimeout(() => {
                    outputDiv.innerHTML += '<p>First promise resolved</p>';
                    resolve('First result');
                }, 500);
            })
            .then(result => {
                outputDiv.innerHTML += `<p>Received: ${result}</p>`;
                return new Promise(resolve => {
                    setTimeout(() => {
                        outputDiv.innerHTML += '<p>Second promise resolved</p>';
                        resolve('Second result');
                    }, 500);
                });
            })
            .then(result => {
                outputDiv.innerHTML += `<p>Received: ${result}</p>`;
                outputDiv.innerHTML += '<p>Promise chain completed!</p>';
            });
        }

        async function runAsyncAwait() {
            const outputDiv = document.getElementById('async-output');
            outputDiv.innerHTML = '<p>Starting async/await...</p>';
            
            try {
                const result1 = await new Promise(resolve => {
                    setTimeout(() => {
                        outputDiv.innerHTML += '<p>First async operation completed</p>';
                        resolve('First result');
                    }, 500);
                });
                
                outputDiv.innerHTML += `<p>Received: ${result1}</p>`;
                
                const result2 = await new Promise(resolve => {
                    setTimeout(() => {
                        outputDiv.innerHTML += '<p>Second async operation completed</p>';
                        resolve('Second result');
                    }, 500);
                });
                
                outputDiv.innerHTML += `<p>Received: ${result2}</p>`;
                outputDiv.innerHTML += '<p>Async/await completed!</p>';
            } catch (error) {
                outputDiv.innerHTML += `<p>Error: ${error.message}</p>`;
            }
        }

        function tryErrorHandling() {
            const input = document.getElementById('error-input').value;
            const outputDiv = document.getElementById('error-output');
            
            try {
                // Try to parse the input as a number
                const number = Number(input);
                
                if (isNaN(number)) {
                    throw new Error('Input is not a valid number');
                }
                
                if (number < 0) {
                    throw new RangeError('Number must be positive');
                }
                
                outputDiv.innerHTML = `<p>Success! The square of ${number} is ${number * number}</p>`;
            } catch (error) {
                outputDiv.innerHTML = `<p>Error: ${error.message}</p>`;
            }
        }

        function createClassInstance() {
            const name = document.getElementById('class-name').value;
            const age = document.getElementById('class-age').value;
            const outputDiv = document.getElementById('class-output');
            
            // Define a simple Person class
            class Person {
                constructor(name, age) {
                    this.name = name;
                    this.age = age;
                }
                
                greet() {
                    return `Hello, I'm ${this.name} and I'm ${this.age} years old.`;
                }
            }
            
            try {
                const person = new Person(name, parseInt(age) || 0);
                outputDiv.innerHTML = `<p>${person.greet()}</p>`;
            } catch (error) {
                outputDiv.innerHTML = `<p>Error: ${error.message}</p>`;
            }
        }

        function callClassMethod() {
            const outputDiv = document.getElementById('class-output');
            
            // Define a Calculator class
            class Calculator {
                constructor() {
                    this.result = 0;
                }
                
                add(value) {
                    this.result += value;
                    return this;
                }
                
                multiply(value) {
                    this.result *= value;
                    return this;
                }
                
                getResult() {
                    return this.result;
                }
            }
            
            const calc = new Calculator();
            const result = calc.add(5).multiply(2).getResult();
            
            outputDiv.innerHTML = `<p>Calculator result: ${result}</p>`;
        }

        function simulateModuleImport() {
            const outputDiv = document.getElementById('module-output');
            
            // Simulate importing a module
            const mathModule = {
                PI: 3.14159,
                add: (a, b) => a + b,
                multiply: (a, b) => a * b
            };
            
            const result = mathModule.add(5, 3);
            const product = mathModule.multiply(5, 3);
            
            outputDiv.innerHTML = `
                <p>Imported math module</p>
                <p>PI: ${mathModule.PI}</p>
                <p>5 + 3 = ${result}</p>
                <p>5 * 3 = ${product}</p>
            `;
        }

        async function simulateDynamicImport() {
            const outputDiv = document.getElementById('module-output');
            outputDiv.innerHTML = '<p>Simulating dynamic import...</p>';
            
            // Simulate a dynamic import with a delay
            setTimeout(() => {
                const utilsModule = {
                    formatDate: (date) => date.toLocaleDateString(),
                    formatTime: (date) => date.toLocaleTimeString()
                };
                
                const now = new Date();
                const formattedDate = utilsModule.formatDate(now);
                const formattedTime = utilsModule.formatTime(now);
                
                outputDiv.innerHTML += `
                    <p>Dynamic import completed</p>
                    <p>Date: ${formattedDate}</p>
                    <p>Time: ${formattedTime}</p>
                `;
            }, 1000);
        }

        function useStack() {
            const outputDiv = document.getElementById('data-structure-output');
            
            // Implement a simple stack
            class Stack {
                constructor() {
                    this.items = [];
                }
                
                push(element) {
                    this.items.push(element);
                }
                
                pop() {
                    return this.items.pop();
                }
                
                peek() {
                    return this.items[this.items.length - 1];
                }
                
                isEmpty() {
                    return this.items.length === 0;
                }
            }
            
            const stack = new Stack();
            stack.push('A');
            stack.push('B');
            stack.push('C');
            
            outputDiv.innerHTML = `
                <p>Stack operations:</p>
                <p>Pushed: A, B, C</p>
                <p>Peek: ${stack.peek()}</p>
                <p>Pop: ${stack.pop()}</p>
                <p>Peek: ${stack.peek()}</p>
                <p>Is empty: ${stack.isEmpty()}</p>
            `;
        }

        function useQueue() {
            const outputDiv = document.getElementById('data-structure-output');
            
            // Implement a simple queue
            class Queue {
                constructor() {
                    this.items = [];
                }
                
                enqueue(element) {
                    this.items.push(element);
                }
                
                dequeue() {
                    return this.items.shift();
                }
                
                front() {
                    return this.items[0];
                }
                
                isEmpty() {
                    return this.items.length === 0;
                }
            }
            
            const queue = new Queue();
            queue.enqueue('A');
            queue.enqueue('B');
            queue.enqueue('C');
            
            outputDiv.innerHTML = `
                <p>Queue operations:</p>
                <p>Enqueued: A, B, C</p>
                <p>Front: ${queue.front()}</p>
                <p>Dequeue: ${queue.dequeue()}</p>
                <p>Front: ${queue.front()}</p>
                <p>Is empty: ${queue.isEmpty()}</p>
            `;
        }

        function useLinkedList() {
            const outputDiv = document.getElementById('data-structure-output');
            
            // Implement a simple linked list
            class Node {
                constructor(data) {
                    this.data = data;
                    this.next = null;
                }
            }
            
            class LinkedList {
                constructor() {
                    this.head = null;
                    this.size = 0;
                }
                
                add(data) {
                    const newNode = new Node(data);
                    
                    if (!this.head) {
                        this.head = newNode;
                    } else {
                        let current = this.head;
                        while (current.next) {
                            current = current.next;
                        }
                        current.next = newNode;
                    }
                    
                    this.size++;
                }
                
                toString() {
                    let result = '';
                    let current = this.head;
                    
                    while (current) {
                        result += current.data + ' -> ';
                        current = current.next;
                    }
                    
                    return result + 'null';
                }
            }
            
            const list = new LinkedList();
            list.add('A');
            list.add('B');
            list.add('C');
            
            outputDiv.innerHTML = `
                <p>Linked list operations:</p>
                <p>Added: A, B, C</p>
                <p>List: ${list.toString()}</p>
                <p>Size: ${list.size}</p>
            `;
        }

        function runSortingAlgorithm() {
            const input = document.getElementById('algorithm-input').value;
            const outputDiv = document.getElementById('algorithm-output');
            
            if (!input) {
                outputDiv.innerHTML = '<p>Please enter some numbers</p>';
                return;
            }
            
            // Parse input as numbers
            const array = input.split(',').map(item => {
                const trimmed = item.trim();
                return isNaN(trimmed) ? 0 : Number(trimmed);
            });
            
            // Implement bubble sort
            function bubbleSort(arr) {
                const n = arr.length;
                const sorted = [...arr];
                
                for (let i = 0; i < n - 1; i++) {
                    for (let j = 0; j < n - i - 1; j++) {
                        if (sorted[j] > sorted[j + 1]) {
                            [sorted[j], sorted[j + 1]] = [sorted[j + 1], sorted[j]];
                        }
                    }
                }
                
                return sorted;
            }
            
            const sorted = bubbleSort(array);
            
            outputDiv.innerHTML = `
                <p>Sorting algorithm (Bubble Sort):</p>
                <p>Original: [${array.join(', ')}]</p>
                <p>Sorted: [${sorted.join(', ')}]</p>
            `;
        }

        function runSearchAlgorithm() {
            const input = document.getElementById('algorithm-input').value;
            const outputDiv = document.getElementById('algorithm-output');
            
            if (!input) {
                outputDiv.innerHTML = '<p>Please enter some numbers</p>';
                return;
            }
            
            // Parse input as numbers
            const array = input.split(',').map(item => {
                const trimmed = item.trim();
                return isNaN(trimmed) ? 0 : Number(trimmed);
            });
            
            // Implement binary search (requires sorted array)
            function binarySearch(arr, target) {
                let left = 0;
                let right = arr.length - 1;
                
                while (left <= right) {
                    const middle = Math.floor((left + right) / 2);
                    
                    if (arr[middle] === target) {
                        return middle;
                    } else if (arr[middle] < target) {
                        left = middle + 1;
                    } else {
                        right = middle - 1;
                    }
                }
                
                return -1;
            }
            
            // Sort the array first
            const sorted = [...array].sort((a, b) => a - b);
            
            // Search for a random element
            const target = sorted[Math.floor(Math.random() * sorted.length)];
            const index = binarySearch(sorted, target);
            
            outputDiv.innerHTML = `
                <p>Search algorithm (Binary Search):</p>
                <p>Array: [${sorted.join(', ')}]</p>
                <p>Searching for: ${target}</p>
                <p>Found at index: ${index}</p>
            `;
        }

        function refactorCode() {
            const outputDiv = document.getElementById('best-practices-output');
            
            // Bad code example
            function badCode(a, b, c, d, e) {
                let x = a + b;
                let y = x * c;
                let z = y - d;
                return z / e;
            }
            
            // Refactored code example
            function calculateTotal(price, quantity, taxRate, discount, shipping) {
                const subtotal = price * quantity;
                const totalWithTax = subtotal * (1 + taxRate);
                const totalWithDiscount = totalWithTax - discount;
                return totalWithDiscount + shipping;
            }
            
            outputDiv.innerHTML = `
                <p>Code refactoring example:</p>
                <p>Before: function with unclear parameter names and calculations</p>
                <p>After: function with descriptive names and clear calculations</p>
                <p>Result: ${calculateTotal(10, 2, 0.08, 5, 3)}</p>
            `;
        }

        function optimizePerformance() {
            const outputDiv = document.getElementById('best-practices-output');
            
            // Inefficient code example
            function inefficientCode(items) {
                const result = [];
                for (let i = 0; i < items.length; i++) {
                    for (let j = 0; j < items.length; j++) {
                        if (items[i] === items[j] && i !== j) {
                            result.push(items[i]);
                        }
                    }
                }
                return result;
            }
            
            // Optimized code example
            function optimizedCode(items) {
                const seen = new Set();
                const duplicates = [];
                
                for (const item of items) {
                    if (seen.has(item)) {
                        duplicates.push(item);
                    } else {
                        seen.add(item);
                    }
                }
                
                return duplicates;
            }
            
            const testArray = [1, 2, 3, 2, 4, 5, 3, 6];
            
            outputDiv.innerHTML = `
                <p>Performance optimization example:</p>
                <p>Test array: [${testArray.join(', ')}]</p>
                <p>Optimized result: [${optimizedCode(testArray).join(', ')}]</p>
                <p>Using Set for O(n) complexity instead of O(n²)</p>
            `;
        }

        function handleErrors() {
            const outputDiv = document.getElementById('best-practices-output');
            
            // Error handling example
            function divide(a, b) {
                try {
                    if (typeof a !== 'number' || typeof b !== 'number') {
                        throw new TypeError('Both arguments must be numbers');
                    }
                    
                    if (b === 0) {
                        throw new Error('Division by zero is not allowed');
                    }
                    
                    return a / b;
                } catch (error) {
                    console.error('Error in divide function:', error.message);
                    return null;
                }
            }
            
            const result1 = divide(10, 2);
            const result2 = divide(10, 0);
            const result3 = divide('10', 2);
            
            outputDiv.innerHTML = `
                <p>Error handling example:</p>
                <p>10 / 2 = ${result1}</p>
                <p>10 / 0 = ${result2} (error handled)</p>
                <p>'10' / 2 = ${result3} (error handled)</p>
                <p>Check console for error messages</p>
            `;
        }

        function loadTaskManager() {
            const demoDiv = document.getElementById('task-manager-demo');
            
            // Create a simplified task manager demo
            demoDiv.innerHTML = `
                <div style="border: 1px solid #ccc; padding: 15px; border-radius: 5px;">
                    <h3>Task Manager Demo</h3>
                    <div style="margin-bottom: 10px;">
                        <input type="text" id="task-title" placeholder="Task title" style="margin-right: 10px; padding: 5px;">
                        <button onclick="addTaskDemo()">Add Task</button>
                    </div>
                    <div id="task-list-demo" style="max-height: 200px; overflow-y: auto;">
                        <p>No tasks yet. Add a task to get started.</p>
                    </div>
                </div>
            `;
            
            // Initialize tasks array
            if (!window.demoTasks) {
                window.demoTasks = [];
            }
            
            renderTasksDemo();
        }

        function addTaskDemo() {
            const titleInput = document.getElementById('task-title');
            const title = titleInput.value.trim();
            
            if (!title) {
                alert('Please enter a task title');
                return;
            }
            
            const task = {
                id: Date.now().toString(),
                title: title,
                completed: false,
                createdAt: new Date().toLocaleString()
            };
            
            window.demoTasks.push(task);
            titleInput.value = '';
            renderTasksDemo();
        }

        function toggleTaskDemo(id) {
            const task = window.demoTasks.find(t => t.id === id);
            if (task) {
                task.completed = !task.completed;
                renderTasksDemo();
            }
        }

        function deleteTaskDemo(id) {
            window.demoTasks = window.demoTasks.filter(t => t.id !== id);
            renderTasksDemo();
        }

        function renderTasksDemo() {
            const taskListDiv = document.getElementById('task-list-demo');
            
            if (window.demoTasks.length === 0) {
                taskListDiv.innerHTML = '<p>No tasks yet. Add a task to get started.</p>';
                return;
            }
            
            taskListDiv.innerHTML = window.demoTasks.map(task => `
                <div style="padding: 8px; margin-bottom: 5px; border: 1px solid #eee; border-radius: 3px; ${task.completed ? 'background-color: #f8f9fa; text-decoration: line-through;' : ''}">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span>${task.title}</span>
                        <div>
                            <button onclick="toggleTaskDemo('${task.id}')" style="margin-right: 5px; padding: 2px 5px; font-size: 12px;">
                                ${task.completed ? 'Undo' : 'Complete'}
                            </button>
                            <button onclick="deleteTaskDemo('${task.id}')" style="padding: 2px 5px; font-size: 12px; background-color: #dc3545; color: white; border: none; border-radius: 3px;">
                                Delete
                            </button>
                        </div>
                    </div>
                    <div style="font-size: 12px; color: #666; margin-top: 3px;">
                        Created: ${task.createdAt}
                    </div>
                </div>
            `).join('');
        }
    </script>
{% endblock %}