{% extends 'base.html' %}

{% block title %}React Documentation - SN VERSE{% endblock %}

{% block head %}
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.3/purify.min.js"></script>
    <style>
        body {
            background: #f8f9fa;
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            color: #212529;
        }
        .sidebar {
            position: fixed;
            top: 70px;
            left: 0;
            width: 280px;
            height: calc(100vh - 70px);
            background: #343a40;
            border-right: 1px solid #495057;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        .sidebar .nav-link {
            color: #adb5bd;
            padding: 12px 20px;
            border-radius: 0;
            margin: 0;
            transition: all 0.2s ease;
            font-weight: 500;
            border-left: 3px solid transparent;
        }
        .sidebar .nav-link:hover {
            background: #495057;
            color: #fff;
            text-decoration: none;
            border-left-color: #61dafb;
        }
        .sidebar .nav-link.active {
            background: #61dafb;
            color: #212529;
            border-left-color: #61dafb;
        }
        .main-content {
            margin-left: 280px;
            padding: 30px 0;
            max-width: 1200px;
        }

        .content-card {
            margin-bottom: 30px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            background: #fff;
        }
        .content-card .card-header {
            background: #61dafb;
            color: #212529;
            font-weight: 600;
            font-size: 1.1rem;
            border-bottom: 1px solid #dee2e6;
            padding: 15px 20px;
            border-radius: 8px 8px 0 0;
        }
        .search-container {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .accordion-button:not(.collapsed) {
            background: #e6f7ff;
            color: #61dafb;
            font-weight: 500;
        }
        .accordion-button {
            border-radius: 0;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        .accordion-button:focus {
            box-shadow: none;
        }
        .badge-note {
            background: #e9ecef;
            color: #495057;
            font-weight: 500;
        }
        .badge-tip {
            background: #d1ecf1;
            color: #0c5460;
            font-weight: 500;
        }
        .btn {
            border-radius: 6px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .copy-button {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .copy-button:hover {
            background: #5a6268;
            transform: scale(1.05);
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Inter', sans-serif;
            color: #212529;
            font-weight: 600;
        }
        .card-body {
            padding: 20px;
        }
        .table {
            margin-bottom: 0;
        }
        .table th {
            background: #f8f9fa;
            font-weight: 600;
            border-top: none;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        code {
            background: #f1f3f4;
            color: #d73a49;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .react-logo {
            color: #61dafb;
            font-weight: 700;
        }
        .data-type-section {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #61dafb;
        }
        .method-table {
            width: 100%;
            margin-top: 10px;
            margin-bottom: 15px;
        }
        .method-table th {
            background-color: #e9ecef;
            text-align: left;
            padding: 8px;
        }
        .method-table td {
            padding: 8px;
            border-bottom: 1px solid #dee2e6;
        }
        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }
            .main-content {
                margin-left: 0;
            }
        }
    </style>
    <script>
        hljs.highlightAll();
    </script>
{% endblock %}

{% block content %}
    <!-- Sidebar Navigation -->
    <nav class="sidebar">
        <div class="p-3">
            <h5 class="text-center mb-3" style="font-size: 1.1rem; color: #fff; font-weight: 600;"><i class="fab fa-react"></i> <span class="react-logo">React</span> Documentation</h5>

            <!-- Search Box -->
            <div class="search-container">
                <input type="text" id="search-input" class="form-control" placeholder="Search documentation..." style="background: rgba(255,255,255,0.9); border: 1px solid #495057; color: #212529;">
                <button class="btn btn-sm btn-outline-dark mt-2 w-100" onclick="clearSearch()">Clear Search</button>
            </div>

            <ul class="nav flex-column">
                <li class="nav-item">
                    <a class="nav-link" href="#module1"><i class="fas fa-info-circle"></i> Module 1: Introduction to React</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module2"><i class="fas fa-code"></i> Module 2: Setup and Installation</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module3"><i class="fas fa-code"></i> Module 3: JSX - JavaScript XML</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module4"><i class="fas fa-cube"></i> Module 4: Components</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module5"><i class="fas fa-database"></i> Module 5: State</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module6"><i class="fas fa-link"></i> Module 6: React Hooks</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module7"><i class="fas fa-hand-pointer"></i> Module 7: Event Handling</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module8"><i class="fas fa-code-branch"></i> Module 8: Conditional Rendering</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module9"><i class="fas fa-list"></i> Module 9: Lists and Keys</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module10"><i class="fas fa-edit"></i> Module 10: Forms</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module11"><i class="fas fa-route"></i> Module 11: Routing with React Router</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module12"><i class="fas fa-tachometer-alt"></i> Module 12: Performance Optimization</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module13"><i class="fas fa-vial"></i> Module 13: Testing React Applications</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module14"><i class="fas fa-star"></i> Module 14: React Best Practices</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module15"><i class="fas fa-project-diagram"></i> Module 15: Advanced React Patterns</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module16"><i class="fas fa-bug"></i> Module 16: Error Boundaries</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module17"><i class="fas fa-door-open"></i> Module 17: Portals</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#module18"><i class="fas fa-layer-group"></i> Module 18: Advanced Context API</a>
                </li>
            </ul>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="main-content">
        <div id="content">
            <h1 class="mb-4" style="text-align: center;"><span class="react-logo">React</span> Documentation</h1>
            <p style="text-align: center; font-size: 1.1rem; color: #6c757d;">Complete guide to React from basics to advanced</p>

            <!-- Module 1: Introduction to React -->
            <div class="content-card" id="module1">
                <div class="card-header">
                    <i class="fas fa-info-circle"></i> Module 1: Introduction to React
                </div>
                <div class="card-body">
                    <h5>What is React?</h5>
                    <p>React is a declarative, efficient, and flexible JavaScript library for building user interfaces. It was created by Jordan Walke, a software engineer at Facebook, and was first deployed on Facebook's newsfeed in 2011 and later on Instagram in 2012.</p>

                    <h5>Core Concepts</h5>
                    <ul>
                        <li><strong>Components</strong> - Building blocks that encapsulate markup, logic, and styling</li>
                        <li><strong>Props</strong> - Read-only inputs passed to components</li>
                        <li><strong>State</strong> - Mutable data that determines component rendering</li>
                        <li><strong>Virtual DOM</strong> - JavaScript representation of the real DOM</li>
                        <li><strong>Unidirectional Data Flow</strong> - Data flows from parent to child components</li>
                    </ul>

                    <h5>Why React?</h5>
                    <div class="data-type-section">
                        <h6>Performance Benefits</h6>
                        <p>React's Virtual DOM enables efficient updates by comparing the new virtual tree with the previous one and calculating the minimal set of changes required to update the real DOM.</p>
                        
                        <h6>Developer Experience</h6>
                        <p>React provides excellent developer tools, hot reloading, and a component-based architecture that makes code more maintainable and reusable.</p>
                        
                        <h6>Ecosystem</h6>
                        <p>React has a vast ecosystem of libraries, tools, and community support, making it easy to find solutions to common problems.</p>
                    </div>

                    <h5>React Philosophy</h5>
                    <p>React follows several key principles:</p>
                    <ul>
                        <li><strong>Composition over Inheritance</strong> - Prefer composing components rather than using inheritance</li>
                        <li><strong>Single Responsibility</strong> - Each component should have one reason to change</li>
                        <li><strong>Immutability</strong> - Treat state as immutable to prevent unexpected side effects</li>
                        <li><strong>Pure Functions</strong> - Components should be pure functions of their props and state</li>
                    </ul>

                    <h5>React vs Other Frameworks</h5>
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Feature</th>
                                <th>React</th>
                                <th>Vue</th>
                                <th>Angular</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Learning Curve</td>
                                <td>Moderate</td>
                                <td>Easy</td>
                                <td>Steep</td>
                            </tr>
                            <tr>
                                <td>Performance</td>
                                <td>Excellent</td>
                                <td>Good</td>
                                <td>Good</td>
                            </tr>
                            <tr>
                                <td>Flexibility</td>
                                <td>High</td>
                                <td>Moderate</td>
                                <td>Low</td>
                            </tr>
                            <tr>
                                <td>Bundle Size</td>
                                <td>Small</td>
                                <td>Small</td>
                                <td>Large</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Module 2: Setup and Installation -->
            <div class="content-card" id="module2">
                <div class="card-header">
                    <i class="fas fa-code"></i> Module 2: Setup and Installation
                </div>
                <div class="card-body">
                    <h5>Prerequisites</h5>
                    <p>Before starting with React, ensure you have:</p>
                    <ul>
                        <li>Node.js (version 14 or higher)</li>
                        <li>npm (comes with Node.js) or yarn</li>
                        <li>Basic knowledge of HTML, CSS, and JavaScript</li>
                        <li>Familiarity with ES6+ features (arrow functions, destructuring, classes)</li>
                    </ul>

                    <h5>Installation Methods</h5>
                    
                    <h6>Method 1: Create React App (Recommended for Beginners)</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-bash"># Install globally (optional)
npm install -g create-react-app

# Create a new React application
npx create-react-app my-react-app
cd my-react-app

# Start the development server
npm start

# Build for production
npm run build

# Run tests
npm test</code></pre>

                    <h6>Method 2: Vite (Modern and Fast)</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-bash"># Create a new React project with Vite
npm create vite@latest my-vite-app -- --template react
cd my-vite-app

# Install dependencies
npm install

# Start development server
npm run dev

# Build for production
npm run build

# Preview production build
npm run preview</code></pre>

                    <h6>Method 3: Next.js (Full-Stack Framework)</h6>
                    <pre><button class="copy-button">Copy</button><code class="language-bash"># Create a new Next.js application
npx create-next-app@latest my-next-app
cd my-next-app

# Start development server
npm run dev

# Build for production
npm run build

# Start production server
npm start</code></pre>

                    <h5>Project Structure</h5>
                    <p>A typical React project structure:</p>
                    <pre><button class="copy-button">Copy</button><code class="language-bash">my-react-app/
├── public/                 # Static files
│   ├── index.html         # Main HTML file
│   ├── favicon.ico        # Favicon
│   └── manifest.json      # PWA configuration
├── src/                   # Source code
│   ├── components/        # Reusable components
│   ├── pages/            # Page components
│   ├── hooks/            # Custom hooks
│   ├── utils/            # Utility functions
│   ├── styles/           # CSS/SCSS files
│   ├── assets/           # Images, fonts, etc.
│   ├── App.js            # Main App component
│   ├── index.js          # Entry point
│   └── index.css         # Global styles
├── package.json          # Dependencies and scripts
├── package-lock.json     # Lock file for dependencies
└── README.md             # Project documentation</code></pre>

                    <h5>Essential VS Code Extensions</h5>
                    <ul>
                        <li><strong>ES7+ React/Redux/React-Native snippets</strong> - Code snippets for React</li>
                        <li><strong>Prettier - Code formatter</strong> - Automatic code formatting</li>
                        <li><strong>ESLint</strong> - Code linting and error detection</li>
                        <li><strong>Auto Rename Tag</strong> - Auto rename paired HTML/XML tags</li>
                        <li><strong>Bracket Pair Colorizer</strong> - Colorize matching brackets</li>
                    </ul>

                    <h5>Environment Variables</h5>
                    <p>Create a <code>.env</code> file in the root directory:</p>
                    <pre><button class="copy-button">Copy</button><code class="language-bash"># Environment variables must start with REACT_APP_
REACT_APP_API_URL=http://localhost:3001/api
REACT_APP_ENVIRONMENT=development
REACT_APP_VERSION=1.0.0

# Access in React
process.env.REACT_APP_API_URL</code></pre>
                </div>
            </div>

            <!-- Module 3: JSX - JavaScript XML -->
            <div class="content-card" id="module3">
                <div class="card-header">
                    <i class="fas fa-code"></i> Module 3: JSX - JavaScript XML
                </div>
                <div class="card-body">
                    <h5>Understanding JSX</h5>
                    <p>JSX is a syntax extension for JavaScript that allows you to write HTML-like code in your JavaScript files. It makes React components more readable and expressive by combining markup with logic.</p>

                    <h5>Basic JSX Syntax</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// JSX element
const element = &lt;h1&gt;Hello, World!&lt;/h1&gt;;

// JSX with expressions
const name = "John";
const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;

// JSX with function calls
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = { firstName: 'John', lastName: 'Doe' };
const element = &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;

// JSX with object properties
const element = &lt;img src={user.avatarUrl} alt={user.name} /&gt;;</code></pre>
                    {% endraw %}

                    <h5>JSX Rules and Best Practices</h5>
                    <div class="data-type-section">
                        <h6>1. Single Parent Element</h6>
                        <p>JSX expressions must have one parent element. Use React.Fragment to avoid adding extra nodes to the DOM.</p>
                        {% raw %}
                        <pre><button class="copy-button">Copy</button><code class="language-jsx">// Incorrect - Multiple parent elements
const element = (
  &lt;h1&gt;Hello&lt;/h1&gt;
  &lt;p&gt;World&lt;/p&gt;
);

// Correct - Single parent element
const element = (
  &lt;div&gt;
    &lt;h1&gt;Hello&lt;/h1&gt;
    &lt;p&gt;World&lt;/p&gt;
  &lt;/div&gt;
);

// Best - Using Fragment
const element = (
  &lt;React.Fragment&gt;
    &lt;h1&gt;Hello&lt;/h1&gt;
    &lt;p&gt;World&lt;/p&gt;
  &lt;/React.Fragment&gt;
);

// Shorthand Fragment syntax
const element = (
  &lt;&gt;
    &lt;h1&gt;Hello&lt;/h1&gt;
    &lt;p&gt;World&lt;/p&gt;
  &lt;/&gt;
);</code></pre>
                        {% endraw %}

                        <h6>2. Attribute Naming</h6>
                        <p>Use camelCase for attributes and className instead of class.</p>
                        {% raw %}
                        <pre><button class="copy-button">Copy</button><code class="language-jsx">// HTML
&lt;div class="container" onclick="handleClick()"&gt;

// JSX
&lt;div className="container" onClick={handleClick}&gt;</code></pre>
                        {% endraw %}

                        <h6>3. Self-Closing Tags</h6>
                        <p>All tags must be properly closed, including self-closing tags.</p>
                        {% raw %}
                        <pre><button class="copy-button">Copy</button><code class="language-jsx">// Correct
&lt;img src="logo.png" alt="Logo" /&gt;
&lt;br /&gt;
&lt;input type="text" /&gt;

// Incorrect
&lt;img src="logo.png" alt="Logo"&gt;
&lt;br&gt;
&lt;input type="text"&gt;</code></pre>
                        {% endraw %}
                    </div>

                    <h5>JavaScript Expressions in JSX</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Variables
const name = "John";
const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;

// Function calls
const element = &lt;h1&gt;{formatName(user)}&lt;/h1&gt;;

// Object properties
const element = &lt;img src={user.avatarUrl} /&gt;;

// Ternary operators
const element = &lt;div&gt;{isLoggedIn ? &lt;Profile /&gt; : &lt;Login /&gt;}&lt;/div&gt;;

// Logical operators
const element = &lt;div&gt;{unreadMessages.length > 0 && &lt;NewMessages /&gt;}&lt;/div&gt;;

// Map for lists
const items = ['Apple', 'Banana', 'Orange'];
const listItems = items.map((item, index) => 
  &lt;li key={index}&gt;{item}&lt;/li&gt;
);</code></pre>
                    {% endraw %}

                    <h5>JSX and TypeScript</h5>
                    <p>When using TypeScript with React (.tsx files):</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-tsx">interface User {
  name: string;
  age: number;
}

const UserCard: React.FC&lt;{ user: User }&gt; = ({ user }) => {
  return (
    &lt;div className="user-card"&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;Age: {user.age}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>
                    {% endraw %}

                    <h5>Common JSX Patterns</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Conditional rendering
function Greeting({ isLoggedIn }) {
  return (
    &lt;div&gt;
      {isLoggedIn ? (
        &lt;h1&gt;Welcome back!&lt;/h1&gt;
      ) : (
        &lt;h1&gt;Please sign in.&lt;/h1&gt;
      )}
    &lt;/div&gt;
  );
}

// List rendering
function TodoList({ todos }) {
  return (
    &lt;ul&gt;
      {todos.map(todo => (
        &lt;li key={todo.id}&gt;
          {todo.text}
          {todo.completed && &lt;span className="completed"&gt; ✓&lt;/span&gt;}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Spreading props
function App() {
  const props = { className: 'button', disabled: false };
  return &lt;button {...props}&gt;Click me&lt;/button&gt;;
}</code></pre>
                    {% endraw %}
                </div>
            </div>

            <!-- Module 4: Components -->
            <div class="content-card" id="module4">
                <div class="card-header">
                    <i class="fas fa-cube"></i> Module 4: Components
                </div>
                <div class="card-body">
                    <h5>Understanding Components</h5>
                    <p>Components are the fundamental building blocks of React applications. They are independent, reusable pieces of UI that can accept inputs (props) and return React elements describing what should appear on screen.</p>

                    <h5>Function Components</h5>
                    <p>Function components are the modern way to write React components. They are simpler and more concise than class components.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Basic function component
function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

// Arrow function component
const Welcome = (props) => {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
};

// Concise arrow function
const Welcome = ({ name }) => &lt;h1&gt;Hello, {name}&lt;/h1&gt;;

// Using the component
function App() {
  return (
    &lt;div&gt;
      &lt;Welcome name="Alice" /&gt;
      &lt;Welcome name="Bob" /&gt;
      &lt;Welcome name="Charlie" /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Class Components</h5>
                    <p>Class components are the traditional way to write React components. They have more features like lifecycle methods and state management.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React from 'react';

class Welcome extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}

// Class component with state and lifecycle
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  componentDidMount() {
    console.log('Component mounted');
  }

  componentDidUpdate() {
    console.log('Component updated');
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;Count: {this.state.count}&lt;/p&gt;
        &lt;button onClick={() => this.setState({ count: this.state.count + 1 })}&gt;
          Increment
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
                    {% endraw %}

                    <h5>Props (Properties)</h5>
                    <p>Props are read-only inputs passed to components. They allow components to be reusable and configurable.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Passing props
function App() {
  return &lt;UserCard name="John" age={30} isActive={true} /&gt;;
}

// Accessing props
function UserCard(props) {
  return (
    &lt;div&gt;
      &lt;h2&gt;{props.name}&lt;/h2&gt;
      &lt;p&gt;Age: {props.age}&lt;/p&gt;
      &lt;p&gt;Status: {props.isActive ? 'Active' : 'Inactive'}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Destructuring props
function UserCard({ name, age, isActive }) {
  return (
    &lt;div&gt;
      &lt;h2&gt;{name}&lt;/h2&gt;
      &lt;p&gt;Age: {age}&lt;/p&gt;
      &lt;p&gt;Status: {isActive ? 'Active' : 'Inactive'}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Default props
function UserCard({ name = 'Guest', age = 0, isActive = false }) {
  return (
    &lt;div&gt;
      &lt;h2&gt;{name}&lt;/h2&gt;
      &lt;p&gt;Age: {age}&lt;/p&gt;
      &lt;p&gt;Status: {isActive ? 'Active' : 'Inactive'}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// PropTypes for validation
import PropTypes from 'prop-types';

UserCard.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
  isActive: PropTypes.bool
};</code></pre>
                    {% endraw %}

                    <h5>Component Composition</h5>
                    <p>Components can be composed together to create complex UIs from simple building blocks.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Child components
function Avatar({ user, size }) {
  return (
    &lt;img
      className="avatar"
      src={user.avatarUrl}
      alt={user.name}
      width={size}
      height={size}
    /&gt;
  );
}

function UserInfo({ user }) {
  return (
    &lt;div className="user-info"&gt;
      &lt;Avatar user={user} size={50} /&gt;
      &lt;div className="user-details"&gt;
        &lt;h3&gt;{user.name}&lt;/h3&gt;
        &lt;p&gt;{user.email}&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Parent component
function ProfilePage() {
  const user = {
    name: 'John Doe',
    email: 'john@example.com',
    avatarUrl: 'https://example.com/avatar.jpg'
  };

  return (
    &lt;div className="profile-page"&gt;
      &lt;UserInfo user={user} /&gt;
      &lt;div className="profile-content"&gt;
        {/* Additional profile content */}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Children Prop</h5>
                    <p>The special children prop allows components to pass components or elements directly between their opening and closing tags.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Component that accepts children
function Card({ title, children }) {
  return (
    &lt;div className="card"&gt;
      &lt;h2 className="card-title"&gt;{title}&lt;/h2&gt;
      &lt;div className="card-content"&gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Using the component
function App() {
  return (
    &lt;Card title="User Profile"&gt;
      &lt;p&gt;This is the user profile card content.&lt;/p&gt;
      &lt;button&gt;Edit Profile&lt;/button&gt;
    &lt;/Card&gt;
  );
}

// Component that manipulates children
function List({ children }) {
  return (
    &lt;ul className="list"&gt;
      {React.Children.map(children, (child, index) => (
        &lt;li key={index} className="list-item"&gt;
          {child}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Component Best Practices</h5>
                    <div class="data-type-section">
                        <h6>Single Responsibility</h6>
                        <p>Each component should have one reason to change and do one thing well.</p>
                        
                        <h6>Keep Components Small</h6>
                        <p>Smaller components are easier to understand, test, and reuse.</p>
                        
                        <h6>Use Descriptive Names</h6>
                        <p>Component names should clearly describe what they do.</p>
                        
                        <h6>Avoid Inline Functions</h6>
                        <p>Define functions outside the render method when possible to avoid unnecessary re-renders.</p>
                    </div>
                </div>
            </div>

            <!-- Module 5: State -->
            <div class="content-card" id="module5">
                <div class="card-header">
                    <i class="fas fa-database"></i> Module 5: State
                </div>
                <div class="card-body">
                    <h5>Understanding State</h5>
                    <p>State is a built-in object that stores property values belonging to a component. When state changes, the component re-renders to reflect the new state. State is mutable and should be managed carefully.</p>

                    <h5>useState Hook</h5>
                    <p>The useState hook is the most common way to manage state in function components.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React, { useState } from 'react';

// Basic state usage
function Counter() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// Multiple state variables
function UserProfile() {
  const [name, setName] = useState('John Doe');
  const [age, setAge] = useState(30);
  const [email, setEmail] = useState('john@example.com');

  const handleNameChange = (e) => setName(e.target.value);
  const handleAgeChange = (e) => setAge(parseInt(e.target.value));
  const handleEmailChange = (e) => setEmail(e.target.value);

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={name}
        onChange={handleNameChange}
        placeholder="Name"
      /&gt;
      &lt;input
        type="number"
        value={age}
        onChange={handleAgeChange}
        placeholder="Age"
      /&gt;
      &lt;input
        type="email"
        value={email}
        onChange={handleEmailChange}
        placeholder="Email"
      /&gt;
      &lt;p&gt;Name: {name}, Age: {age}, Email: {email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>State Update Patterns</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Direct update (for simple values)
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(0);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+&lt;/button&gt;
      &lt;button onClick={decrement}&gt;-&lt;/button&gt;
      &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}

// Functional update (when new state depends on previous state)
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => setCount(prevCount => prevCount + 1);
  const decrement = () => setCount(prevCount => prevCount - 1);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+&lt;/button&gt;
      &lt;button onClick={decrement}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
}

// Updating objects in state
function UserForm() {
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setUser(prevUser => ({
      ...prevUser,
      [name]: value
    }));
  };

  return (
    &lt;form&gt;
      &lt;input
        name="name"
        value={user.name}
        onChange={handleChange}
        placeholder="Name"
      /&gt;
      &lt;input
        name="email"
        value={user.email}
        onChange={handleChange}
        placeholder="Email"
      /&gt;
      &lt;input
        name="age"
        value={user.age}
        onChange={handleChange}
        placeholder="Age"
      /&gt;
    &lt;/form&gt;
  );
}

// Updating arrays in state
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [inputValue, setInputValue] = useState('');

  const addTodo = () => {
    if (inputValue.trim()) {
      setTodos(prevTodos => [
        ...prevTodos,
        { id: Date.now(), text: inputValue, completed: false }
      ]);
      setInputValue('');
    }
  };

  const toggleTodo = (id) => {
    setTodos(prevTodos =>
      prevTodos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  };

  const deleteTodo = (id) => {
    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));
  };

  return (
    &lt;div&gt;
      &lt;input
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        placeholder="Add a todo"
      /&gt;
      &lt;button onClick={addTodo}&gt;Add&lt;/button&gt;
      &lt;ul&gt;
        {todos.map(todo => (
          &lt;li key={todo.id}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            /&gt;
            &lt;span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}&gt;
              {todo.text}
            &lt;/span&gt;
            &lt;button onClick={() => deleteTodo(todo.id)}&gt;Delete&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>State in Class Components</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
      name: 'Counter'
    };
  }

  // setState with object
  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  // setState with function (recommended)
  decrement = () => {
    this.setState(prevState => ({
      count: prevState.count - 1
    }));
  };

  // setState with callback
  updateName = () => {
    this.setState(
      { name: 'Updated Counter' },
      () => {
        console.log('State updated:', this.state.name);
      }
    );
  };

  render() {
    return (
      &lt;div&gt;
        &lt;h2&gt;{this.state.name}&lt;/h2&gt;
        &lt;p&gt;Count: {this.state.count}&lt;/p&gt;
        &lt;button onClick={this.increment}&gt;+&lt;/button&gt;
        &lt;button onClick={this.decrement}&gt;-&lt;/button&gt;
        &lt;button onClick={this.updateName}&gt;Update Name&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
                    {% endraw %}

                    <h5>State Management Best Practices</h5>
                    <div class="data-type-section">
                        <h6>Keep State Local</h6>
                        <p>Only lift state up when multiple components need to share it.</p>
                        
                        <h6>Use Multiple State Variables</h6>
                        <p>Separate unrelated state into different useState calls.</p>
                        
                        <h6>Average State Updates</h6>
                        <p>Use functional updates when the new state depends on the previous state.</p>
                        
                        <h6>Immutable Updates</h6>
                        <p>Always create new objects/arrays when updating state to avoid mutation.</p>
                    </div>

                    <h5>Common State Patterns</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Toggle pattern
function Toggle() {
  const [isOn, setIsOn] = useState(false);
  
  return (
    &lt;button onClick={() => setIsOn(!isOn)}&gt;
      {isOn ? 'ON' : 'OFF'}
    &lt;/button&gt;
  );
}

// Loading pattern
function DataLoader() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const loadData = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    &lt;div&gt;
      &lt;button onClick={loadData} disabled={loading}&gt;
        {loading ? 'Loading...' : 'Load Data'}
      &lt;/button&gt;
      {error && &lt;p&gt;Error: {error}&lt;/p&gt;}
      {data && &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;}
    &lt;/div&gt;
  );
}

// Form pattern
function Form() {
  const [formData, setFormData] = useState({
    username: '',
    password: '',
    rememberMe: false
  });

  const [errors, setErrors] = useState({});

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const validate = () => {
    const newErrors = {};
    if (!formData.username) newErrors.username = 'Username is required';
    if (!formData.password) newErrors.password = 'Password is required';
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (validate()) {
      console.log('Form submitted:', formData);
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        name="username"
        value={formData.username}
        onChange={handleChange}
        placeholder="Username"
      /&gt;
      {errors.username && &lt;span&gt;{errors.username}&lt;/span&gt;}
      
      &lt;input
        name="password"
        type="password"
        value={formData.password}
        onChange={handleChange}
        placeholder="Password"
      /&gt;
      {errors.password && &lt;span&gt;{errors.password}&lt;/span&gt;}
      
      &lt;label&gt;
        &lt;input
          name="rememberMe"
          type="checkbox"
          checked={formData.rememberMe}
          onChange={handleChange}
        /&gt;
        Remember me
      &lt;/label&gt;
      
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    {% endraw %}
                </div>
            </div>

            <!-- Module 6: React Hooks -->
            <div class="content-card" id="module6">
                <div class="card-header">
                    <i class="fas fa-link"></i> Module 6: React Hooks
                </div>
                <div class="card-body">
                    <h5>Introduction to Hooks</h5>
                    <p>Hooks are functions that let you "hook into" React state and lifecycle features from function components. They were introduced in React 16.8 and allow you to use state and other React features without writing a class.</p>

                    <h5>Rules of Hooks</h5>
                    <div class="data-type-section">
                        <h6>1. Only Call Hooks at the Top Level</h6>
                        <p>Don't call Hooks inside loops, conditions, or nested functions. Always use Hooks at the top level of your React function.</p>
                        
                        <h6>2. Only Call Hooks from React Functions</h6>
                        <p>Call Hooks from React function components or from custom Hooks (not from regular JavaScript functions).</p>
                    </div>

                    <h5>Built-in Hooks</h5>
                    
                    <h6>useState</h6>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('React');

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
      &lt;p&gt;Name: {name}&lt;/p&gt;
      &lt;input 
        value={name} 
        onChange={(e) => setName(e.target.value)} 
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h6>useEffect</h6>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  // Effect runs after every render
  useEffect(() => {
    console.log('Component rendered');
  });

  // Effect runs only once (on mount)
  useEffect(() => {
    console.log('Component mounted');
    return () => {
      console.log('Component will unmount');
    };
  }, []);

  // Effect runs when count changes
  useEffect(() => {
    console.log('Count changed');
  }, [count]);

  // Effect with cleanup
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('Timer tick');
    }, 1000);

    return () => {
      clearInterval(timer);
    };
  }, []);

  // Data fetching
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('https://api.example.com/data');
        const result = await response.json();
        setData(result);
      } catch (error) {
        console.error('Error fetching data:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;
}</code></pre>
                    {% endraw %}

                    <h6>useContext</h6>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { createContext, useContext } from 'react';

// Create context
const ThemeContext = createContext('light');

// Provider component
function App() {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };

  return (
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      &lt;Toolbar /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

// Consumer component
function ThemedButton() {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    &lt;button 
      onClick={toggleTheme}
      style={{
        background: theme === 'light' ? '#fff' : '#333',
        color: theme === 'light' ? '#333' : '#fff'
      }}
    &gt;
      Toggle Theme
    &lt;/button&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h6>useReducer</h6>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { useReducer } from 'react';

// Reducer function
const counterReducer = (state, action) => {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    default:
      return state;
  }
};

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {state.count}&lt;/p&gt;
      &lt;button onClick={() => dispatch({ type: 'increment' })}&gt;+&lt;/button&gt;
      &lt;button onClick={() => dispatch({ type: 'decrement' })}&gt;-&lt;/button&gt;
      &lt;button onClick={() => dispatch({ type: 'reset' })}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}

// Complex reducer with initialization
const initialState = {
  todos: [],
  filter: 'all'
};

const todoReducer = (state, action) => {
  switch (action.type) {
    case 'add_todo':
      return {
        ...state,
        todos: [...state.todos, { id: Date.now(), text: action.payload, completed: false }]
      };
    case 'toggle_todo':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo
        )
      };
    case 'set_filter':
      return { ...state, filter: action.payload };
    default:
      return state;
  }
};

function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, initialState);
  const [input, setInput] = useState('');

  const addTodo = () => {
    if (input.trim()) {
      dispatch({ type: 'add_todo', payload: input });
      setInput('');
    }
  };

  return (
    &lt;div&gt;
      &lt;input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && addTodo()}
        placeholder="Add a todo"
      /&gt;
      &lt;button onClick={addTodo}&gt;Add&lt;/button&gt;
      
      &lt;div&gt;
        &lt;button onClick={() => dispatch({ type: 'set_filter', payload: 'all' })}&gt;All&lt;/button&gt;
        &lt;button onClick={() => dispatch({ type: 'set_filter', payload: 'active' })}&gt;Active&lt;/button&gt;
        &lt;button onClick={() => dispatch({ type: 'set_filter', payload: 'completed' })}&gt;Completed&lt;/button&gt;
      &lt;/div&gt;
      
      &lt;ul&gt;
        {state.todos
          .filter(todo => {
            if (state.filter === 'active') return !todo.completed;
            if (state.filter === 'completed') return todo.completed;
            return true;
          })
          .map(todo => (
            &lt;li key={todo.id}&gt;
              &lt;input
                type="checkbox"
                checked={todo.completed}
                onChange={() => dispatch({ type: 'toggle_todo', payload: todo.id })}
              /&gt;
              {todo.text}
            &lt;/li&gt;
          ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h6>useCallback</h6>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { useState, useCallback } from 'react';

function Button({ onClick, children }) {
  console.log('Button rendered');
  return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;
}

function Counter() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');

  // Without useCallback - Button re-renders on every render
  const handleClickWithoutCallback = () => {
    setCount(count + 1);
  };

  // With useCallback - Button only re-renders when count changes
  const handleClick = useCallback(() => {
    setCount(count + 1);
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;Button onClick={handleClick}&gt;Increment&lt;/Button&gt;
      &lt;input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Name"
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h6>useMemo</h6>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { useState, useMemo } from 'react';

function ExpensiveCalculation({ numbers }) {
  const [filter, setFilter] = useState('');

  // Expensive calculation without memoization
  const expensiveSum = numbers.reduce((sum, num) => sum + num * num, 0);

  // With memoization - only recalculates when numbers change
  const memoizedSum = useMemo(() => {
    console.log('Calculating sum...');
    return numbers.reduce((sum, num) => sum + num * num, 0);
  }, [numbers]);

  // Filtered list with memoization
  const filteredNumbers = useMemo(() => {
    console.log('Filtering numbers...');
    return numbers.filter(num => num.toString().includes(filter));
  }, [numbers, filter]);

  return (
    &lt;div&gt;
      &lt;input
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        placeholder="Filter numbers"
      /&gt;
      &lt;p&gt;Sum of squares: {memoizedSum}&lt;/p&gt;
      &lt;ul&gt;
        {filteredNumbers.map((num, index) => (
          &lt;li key={index}&gt;{num}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h6>useRef</h6>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { useRef, useEffect } from 'react';

function TextInputWithFocusButton() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    &lt;div&gt;
      &lt;input ref={inputRef} type="text" /&gt;
      &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;
    &lt;/div&gt;
  );
}

// Storing previous value
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    &lt;div&gt;
      &lt;p&gt;Current: {count}&lt;/p&gt;
      &lt;p&gt;Previous: {prevCount}&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Custom Hooks</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Custom hook for local storage
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}

// Usage
function App() {
  const [name, setName] = useLocalStorage('name', 'Guest');

  return (
    &lt;div&gt;
      &lt;input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Name"
      /&gt;
      &lt;p&gt;Hello, {name}!&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Custom hook for API calls
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network response was not ok');
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useApi(`https://api.example.com/users/${userId}`);

  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  return &lt;div&gt;{user?.name}&lt;/div&gt;;
}

// Custom hook for debouncing
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// Usage
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      // Perform search with debounced term
      console.log('Searching for:', debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    &lt;input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search..."
    /&gt;
  );
}</code></pre>
                    {% endraw %}
                </div>
            </div>

            <!-- Module 7: Event Handling -->
            <div class="content-card" id="module7">
                <div class="card-header">
                    <i class="fas fa-hand-pointer"></i> Module 7: Event Handling
                </div>
                <div class="card-body">
                    <h5>Understanding Events in React</h5>
                    <p>React events are handled similarly to DOM events but with some syntax differences. React uses camelCase for event names and passes functions as event handlers rather than strings.</p>

                    <h5>Basic Event Handling</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function Button() {
  const handleClick = () => {
    alert('Button clicked!');
  };

  return &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;;
}

// Arrow function in JSX
function Button() {
  return (
    &lt;button onClick={() => alert('Button clicked!')}&gt;
      Click me
    &lt;/button&gt;
  );
}

// With parameters
function Button() {
  const handleClick = (name) => {
    alert(`Hello, ${name}!`);
  };

  return (
    &lt;button onClick={() => handleClick('John')}&gt;
      Say Hello
    &lt;/button&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Common React Events</h5>
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Category</th>
                                <th>Events</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Clipboard</td>
                                <td>onCopy, onCut, onPaste</td>
                            </tr>
                            <tr>
                                <td>Keyboard</td>
                                <td>onKeyDown, onKeyPress, onKeyUp</td>
                            </tr>
                            <tr>
                                <td>Focus</td>
                                <td>onFocus, onBlur</td>
                            </tr>
                            <tr>
                                <td>Form</td>
                                <td>onChange, onInput, onSubmit</td>
                            </tr>
                            <tr>
                                <td>Mouse</td>
                                <td>onClick, onContextMenu, onDoubleClick, onDrag, onMouseDown, onMouseEnter, onMouseLeave, onMouseMove, onMouseOut, onMouseOver, onMouseUp</td>
                            </tr>
                            <tr>
                                <td>Touch</td>
                                <td>onTouchCancel, onTouchEnd, onTouchMove, onTouchStart</td>
                            </tr>
                            <tr>
                                <td>UI</td>
                                <td>onScroll, onResize</td>
                            </tr>
                            <tr>
                                <td>Wheel</td>
                                <td>onWheel</td>
                            </tr>
                        </tbody>
                    </table>

                    <h5>Event Object</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function EventExample() {
  const handleClick = (event) => {
    console.log('Event type:', event.type);
    console.log('Target:', event.target);
    console.log('Current target:', event.currentTarget);
    console.log('Native event:', event.nativeEvent);
  };

  const handleChange = (event) => {
    console.log('Input value:', event.target.value);
    console.log('Input name:', event.target.name);
  };

  const handleSubmit = (event) => {
    event.preventDefault(); // Prevent default form submission
    console.log('Form submitted');
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;
      &lt;input onChange={handleChange} placeholder="Type something" /&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;button type="submit"&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Form Events</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function FormExample() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: ''
  });

  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData(prevData => ({
      ...prevData,
      [name]: value
    }));
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log('Form data:', formData);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label&gt;Username:&lt;/label&gt;
        &lt;input
          type="text"
          name="username"
          value={formData.username}
          onChange={handleChange}
          required
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          required
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;Password:&lt;/label&gt;
        &lt;input
          type="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
          required
        /&gt;
      &lt;/div&gt;
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Keyboard Events</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function KeyboardExample() {
  const [key, setKey] = useState('');
  const [keyCode, setKeyCode] = useState('');

  const handleKeyDown = (event) => {
    setKey(event.key);
    setKeyCode(event.keyCode);
    console.log('Key pressed:', event.key);
    console.log('Key code:', event.keyCode);
    console.log('Shift key:', event.shiftKey);
    console.log('Ctrl key:', event.ctrlKey);
    console.log('Alt key:', event.altKey);
  };

  const handleKeyPress = (event) => {
    console.log('Key pressed (character):', event.charCode);
  };

  const handleKeyUp = (event) => {
    console.log('Key released:', event.key);
  };

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        onKeyDown={handleKeyDown}
        onKeyPress={handleKeyPress}
        onKeyUp={handleKeyUp}
        placeholder="Press any key"
      /&gt;
      &lt;p&gt;Last key pressed: {key}&lt;/p&gt;
      &lt;p&gt;Key code: {keyCode}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Enter key submission
function SearchBox() {
  const [query, setQuery] = useState('');

  const handleKeyDown = (event) => {
    if (event.key === 'Enter') {
      handleSearch();
    }
  };

  const handleSearch = () => {
    console.log('Searching for:', query);
  };

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder="Search..."
      /&gt;
      &lt;button onClick={handleSearch}&gt;Search&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Mouse Events</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function MouseExample() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);

  const handleMouseMove = (event) => {
    setPosition({ x: event.clientX, y: event.clientY });
  };

  const handleMouseDown = () => {
    setIsDragging(true);
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  const handleMouseEnter = () => {
    console.log('Mouse entered');
  };

  const handleMouseLeave = () => {
    console.log('Mouse left');
  };

  return (
    &lt;div&gt;
      &lt;div
        style={{
          width: 200,
          height: 200,
          backgroundColor: isDragging ? 'red' : 'blue',
          cursor: isDragging ? 'grabbing' : 'grab'
        }}
        onMouseMove={handleMouseMove}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
      &gt;
        Drag me!
      &lt;/div&gt;
      &lt;p&gt;Position: {position.x}, {position.y}&lt;/p&gt;
      &lt;p&gt;Dragging: {isDragging ? 'Yes' : 'No'}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Event Delegation</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function EventDelegation() {
  const handleClick = (event) => {
    const buttonId = event.target.dataset.buttonId;
    if (buttonId) {
      console.log(`Button ${buttonId} clicked`);
    }
  };

  return (
    &lt;div onClick={handleClick}&gt;
      &lt;button data-button-id="1"&gt;Button 1&lt;/button&gt;
      &lt;button data-button-id="2"&gt;Button 2&lt;/button&gt;
      &lt;button data-button-id="3"&gt;Button 3&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Custom Events</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Custom event hook
function useCustomEvent(eventName, handler) {
  useEffect(() => {
    window.addEventListener(eventName, handler);
    return () => {
      window.removeEventListener(eventName, handler);
    };
  }, [eventName, handler]);
}

// Usage
function WindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });

  const handleResize = () => {
    setSize({
      width: window.innerWidth,
      height: window.innerHeight
    });
  };

  useCustomEvent('resize', handleResize);

  return (
    &lt;div&gt;
      &lt;p&gt;Window width: {size.width}px&lt;/p&gt;
      &lt;p&gt;Window height: {size.height}px&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Event Performance</h5>
                    <div class="data-type-section">
                        <h6>Throttling and Debouncing</h6>
                        <p>For performance-critical events like scroll or resize, use throttling or debouncing.</p>
                        
                        <h6>Passive Event Listeners</h6>
                        <p>Use passive event listeners for better scrolling performance.</p>
                        
                        <h6>Event Pooling</h6>
                        <p>React pools event objects for performance. Access event properties asynchronously with care.</p>
                    </div>
                </div>
            </div>

            <!-- Module 8: Conditional Rendering -->
            <div class="content-card" id="module8">
                <div class="card-header">
                    <i class="fas fa-code-branch"></i> Module 8: Conditional Rendering
                </div>
                <div class="card-body">
                    <h5>Understanding Conditional Rendering</h5>
                    <p>Conditional rendering in React allows you to render different components or elements based on certain conditions. This is similar to using conditional statements in JavaScript but applied to JSX.</p>

                    <h5>Using if Statements</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  
  if (isLoggedIn) {
    return &lt;h1&gt;Welcome back!&lt;/h1&gt;;
  }
  return &lt;h1&gt;Please sign in.&lt;/h1&gt;;
}

// Using if-else if-else
function getStatus(status) {
  if (status === 'loading') {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  } else if (status === 'success') {
    return &lt;div&gt;Success!&lt;/div&gt;;
  } else if (status === 'error') {
    return &lt;div&gt;Error occurred!&lt;/div&gt;;
  } else {
    return &lt;div&gt;Unknown status&lt;/div&gt;;
  }
}</code></pre>
                    {% endraw %}

                    <h5>Using Ternary Operators</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  return (
    &lt;div&gt;
      {isLoggedIn ? &lt;h1&gt;Welcome back!&lt;/h1&gt; : &lt;h1&gt;Please sign in.&lt;/h1&gt;}
    &lt;/div&gt;
  );
}

// Nested ternary
function Message({ type, text }) {
  return (
    &lt;div className={`message ${type}`}&gt;
      {type === 'success' ? 
        &lt;span&gt;✓ {text}&lt;/span&gt; : 
        type === 'error' ? 
        &lt;span&gt;✗ {text}&lt;/span&gt; : 
        &lt;span&gt;ℹ {text}&lt;/span&gt;
      }
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Using Logical AND Operator</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function Mailbox(props) {
  const unreadMessages = props.unreadMessages;
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello!&lt;/h1&gt;
      {unreadMessages.length > 0 &&
        &lt;h2&gt;
          You have {unreadMessages.length} unread messages.
        &lt;/h2&gt;
      }
    &lt;/div&gt;
  );
}

// Multiple conditions
function Notification({ notifications }) {
  return (
    &lt;div&gt;
      {notifications.length > 0 && (
        &lt;div className="notification-badge"&gt;
          {notifications.length}
        &lt;/div&gt;
      )}
      {notifications.length > 0 && notifications.some(n => n.urgent) && (
        &lt;div className="urgent-indicator"&gt;!&lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Element Variables</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  let button;
  
  if (isLoggedIn) {
    button = &lt;button&gt;Logout&lt;/button&gt;;
  } else {
    button = &lt;button&gt;Login&lt;/button&gt;;
  }
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome!&lt;/h1&gt;
      {button}
    &lt;/div&gt;
  );
}

// Complex conditional rendering
function UserCard({ user, showDetails }) {
  let detailsSection;
  
  if (showDetails) {
    detailsSection = (
      &lt;div className="user-details"&gt;
        &lt;p&gt;Email: {user.email}&lt;/p&gt;
        &lt;p&gt;Phone: {user.phone}&lt;/p&gt;
        &lt;p&gt;Address: {user.address}&lt;/p&gt;
      &lt;/div&gt;
    );
  }
  
  return (
    &lt;div className="user-card"&gt;
      &lt;h3&gt;{user.name}&lt;/h3&gt;
      &lt;p&gt;{user.bio}&lt;/p&gt;
      {detailsSection}
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Preventing Component Rendering</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function WarningBanner(props) {
  if (!props.warn) {
    return null;
  }
  
  return (
    &lt;div className="warning"&gt;
      Warning!
    &lt;/div&gt;
  );
}

// Usage
function App() {
  const [showWarning, setShowWarning] = useState(true);
  
  return (
    &lt;div&gt;
      &lt;WarningBanner warn={showWarning} /&gt;
      &lt;button onClick={() => setShowWarning(!showWarning)}&gt;
        {showWarning ? 'Hide' : 'Show'} Warning
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Conditional Rendering with Lists</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function TaskList({ tasks }) {
  return (
    &lt;ul&gt;
      {tasks.map(task => (
        &lt;li key={task.id} className={task.completed ? 'completed' : 'active'}&gt;
          &lt;span&gt;{task.text}&lt;/span&gt;
          {task.completed && &lt;span className="check-mark"&gt; ✓&lt;/span&gt;}
          {!task.completed && task.priority === 'high' && (
            &lt;span className="priority-indicator"&gt; High Priority&lt;/span&gt;
          )}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Conditional rendering with empty state
function ProductList({ products }) {
  if (products.length === 0) {
    return (
      &lt;div className="empty-state"&gt;
        &lt;h3&gt;No products found&lt;/h3&gt;
        &lt;p&gt;Try adjusting your filters or search criteria.&lt;/p&gt;
      &lt;/div&gt;
    );
  }
  
  return (
    &lt;div className="product-grid"&gt;
      {products.map(product => (
        &lt;ProductCard key={product.id} product={product} /&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Inline Conditional Styles</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function StatusIndicator({ status }) {
  const getStatusStyle = () => {
    switch (status) {
      case 'active':
        return { color: 'green', fontWeight: 'bold' };
      case 'inactive':
        return { color: 'red', fontWeight: 'bold' };
      case 'pending':
        return { color: 'orange', fontWeight: 'bold' };
      default:
        return { color: 'gray' };
    }
  };
  
  return (
    &lt;span style={getStatusStyle()}&gt;
      {status.toUpperCase()}
    &lt;/span&gt;
  );
}

// Conditional classes
function Button({ variant, size, disabled, children }) {
  const getButtonClasses = () => {
    let classes = ['btn'];
    
    if (variant) classes.push(`btn-${variant}`);
    if (size) classes.push(`btn-${size}`);
    if (disabled) classes.push('btn-disabled');
    
    return classes.join(' ');
  };
  
  return (
    &lt;button 
      className={getButtonClasses()}
      disabled={disabled}
    &gt;
      {children}
    &lt;/button&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Higher-Order Components for Conditional Rendering</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// HOC for conditional rendering
function withConditionalLoading(Component) {
  return function WithConditionalLoading({ isLoading, ...props }) {
    if (isLoading) {
      return &lt;div className="loading-spinner"&gt;Loading...&lt;/div&gt;;
    }
    return &lt;Component {...props} /&gt;;
  };
}

// Usage
const UserProfileWithLoading = withConditionalLoading(UserProfile);

function App() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUser().then(userData => {
      setUser(userData);
      setLoading(false);
    });
  }, []);
  
  return (
    &lt;UserProfileWithLoading 
      user={user} 
      isLoading={loading} 
    /&gt;
  );
}

// HOC for authentication
function withAuth(Component) {
  return function WithAuth({ isAuthenticated, ...props }) {
    if (!isAuthenticated) {
      return &lt;div&gt;Please log in to view this content.&lt;/div&gt;;
    }
    return &lt;Component {...props} /&gt;;
  };
}

const ProtectedComponent = withAuth(Dashboard);</code></pre>
                    {% endraw %}

                    <h5>Best Practices for Conditional Rendering</h5>
                    <div class="data-type-section">
                        <h6>Keep it Simple</h6>
                        <p>Use the simplest conditional rendering method that meets your needs.</p>
                        
                        <h6>Avoid Deep Nesting</h6>
                        <p>Extract complex conditions into separate variables or functions.</p>
                        
                        <h6>Use Early Returns</h6>
                        <p>Return early from components to avoid nested conditions.</p>
                        
                        <h6>Consider Performance</h6>
                        <p>Be mindful of expensive operations in conditional blocks.</p>
                    </div>
                </div>
            </div>

            <!-- Module 9: Lists and Keys -->
            <div class="content-card" id="module9">
                <div class="card-header">
                    <i class="fas fa-list"></i> Module 9: Lists and Keys
                </div>
                <div class="card-body">
                    <h5>Rendering Lists in React</h5>
                    <p>Lists are a common pattern in React for displaying collections of data. You can render lists using the JavaScript map() method to transform an array of data into an array of elements.</p>

                    <h5>Basic List Rendering</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function NumberList() {
  const numbers = [1, 2, 3, 4, 5];
  
  return (
    &lt;ul&gt;
      {numbers.map((number) => (
        &lt;li key={number.toString()}&gt;
          {number}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Rendering list of objects
function TodoList() {
  const todos = [
    { id: 1, text: 'Learn React', completed: false },
    { id: 2, text: 'Build a project', completed: true },
    { id: 3, text: 'Deploy to production', completed: false }
  ];
  
  return (
    &lt;ul&gt;
      {todos.map((todo) => (
        &lt;li key={todo.id}&gt;
          {todo.text}
          {todo.completed && &lt;span&gt; ✓&lt;/span&gt;}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Understanding Keys</h5>
                    <p>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity.</p>

                    <h6>Why Keys are Important</h6>
                    <ul>
                        <li>Helps React identify which items have changed</li>
                        <li>Enables efficient re-rendering</li>
                        <li>Preserves component state</li>
                        <li>Prevents unnecessary DOM manipulations</li>
                    </ul>

                    <h6>Choosing the Right Key</h6>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Good: Using unique IDs
function UserList({ users }) {
  return (
    &lt;ul&gt;
      {users.map(user => (
        &lt;li key={user.id}&gt;
          {user.name}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Acceptable: Using unique combinations
function UserList({ users }) {
  return (
    &lt;ul&gt;
      {users.map(user => (
        &lt;li key={`${user.id}-${user.name}`}&gt;
          {user.name}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Avoid: Using array index (only for static lists)
function NumberList({ numbers }) {
  return (
    &lt;ul&gt;
      {numbers.map((number, index) => (
        &lt;li key={index}&gt;
          {number}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Bad: Using random values or non-unique values
function BadExample({ items }) {
  return (
    &lt;ul&gt;
      {items.map(item => (
        &lt;li key={Math.random()}&gt; {/* Don't do this! */}
          {item.name}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Advanced List Patterns</h5>
                    
                    <h6>Filtered Lists</h6>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function FilteredList({ items, filter }) {
  const filteredItems = items.filter(item => 
    item.name.toLowerCase().includes(filter.toLowerCase())
  );
  
  return (
    &lt;ul&gt;
      {filteredItems.map(item => (
        &lt;li key={item.id}&gt;
          {item.name}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h6>Sorted Lists</h6>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function SortedList({ items }) {
  const sortedItems = [...items].sort((a, b) => 
    a.name.localeCompare(b.name)
  );
  
  return (
    &lt;ul&gt;
      {sortedItems.map(item => (
        &lt;li key={item.id}&gt;
          {item.name}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h6>Paginated Lists</h6>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function PaginatedList({ items, itemsPerPage, currentPage }) {
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const currentItems = items.slice(startIndex, endIndex);
  
  return (
    &lt;div&gt;
      &lt;ul&gt;
        {currentItems.map(item => (
          &lt;li key={item.id}&gt;
            {item.name}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;Pagination 
        totalItems={items.length}
        itemsPerPage={itemsPerPage}
        currentPage={currentPage}
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Lists with Forms</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function EditableList({ items, onChange }) {
  const handleItemChange = (index, field, value) => {
    const newItems = [...items];
    newItems[index] = { ...newItems[index], [field]: value };
    onChange(newItems);
  };
  
  const handleAddItem = () => {
    const newItems = [...items, { id: Date.now(), name: '', quantity: 0 }];
    onChange(newItems);
  };
  
  const handleRemoveItem = (index) => {
    const newItems = items.filter((_, i) => i !== index);
    onChange(newItems);
  };
  
  return (
    &lt;div&gt;
      {items.map((item, index) => (
        &lt;div key={item.id} className="list-item"&gt;
          &lt;input
            type="text"
            value={item.name}
            onChange={(e) => handleItemChange(index, 'name', e.target.value)}
            placeholder="Item name"
          /&gt;
          &lt;input
            type="number"
            value={item.quantity}
            onChange={(e) => handleItemChange(index, 'quantity', parseInt(e.target.value))}
            placeholder="Quantity"
          /&gt;
          &lt;button onClick={() => handleRemoveItem(index)}&gt;Remove&lt;/button&gt;
        &lt;/div&gt;
      ))}
      &lt;button onClick={handleAddItem}&gt;Add Item&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Virtual Lists</h5>
                    <p>For large lists, consider using virtualization to render only visible items:</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { FixedSizeList as List } from 'react-window';

function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    &lt;div style={style}&gt;
      {items[index].name}
    &lt;/div&gt;
  );
  
  return (
    &lt;List
      height={400}
      itemCount={items.length}
      itemSize={35}
      width="100%"
    &gt;
      {Row}
    &lt;/List&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Best Practices for Lists and Keys</h5>
                    <div class="data-type-section">
                        <h6>Use Stable Keys</h6>
                        <p>Keys should be stable, predictable, and unique among siblings.</p>
                        
                        <h6>Avoid Index as Key</h6>
                        <p>Don't use array index as key if the list can be reordered or filtered.</p>
                        
                        <h6>Key Scope</h6>
                        <p>Keys only need to be unique among siblings, not globally unique.</p>
                        
                        <h6>Performance</h6>
                        <p>For large lists, consider virtualization or pagination.</p>
                    </div>
                </div>
            </div>

            <!-- Module 10: Forms -->
            <div class="content-card" id="module10">
                <div class="card-header">
                    <i class="fas fa-edit"></i> Module 10: Forms
                </div>
                <div class="card-body">
                    <h5>Forms in React</h5>
                    <p>Forms in React can be either controlled or uncontrolled. Controlled components are recommended as they provide more control over form data and validation.</p>

                    <h5>Controlled Components</h5>
                    <p>In controlled components, React controls the form input's value through state.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function NameForm() {
  const [value, setValue] = useState('');
  
  const handleChange = (event) => {
    setValue(event.target.value);
  };
  
  const handleSubmit = (event) => {
    event.preventDefault();
    alert('A name was submitted: ' + value);
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label&gt;
        Name:
        &lt;input 
          type="text" 
          value={value}
          onChange={handleChange}
        /&gt;
      &lt;/label&gt;
      &lt;input type="submit" value="Submit" /&gt;
    &lt;/form&gt;
  );
}

// Multiple form fields
function RegistrationForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData(prevData => ({
      ...prevData,
      [name]: value
    }));
  };
  
  const handleSubmit = (event) => {
    event.preventDefault();
    console.log('Form submitted:', formData);
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label&gt;Username:&lt;/label&gt;
        &lt;input
          type="text"
          name="username"
          value={formData.username}
          onChange={handleChange}
          required
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          required
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;Password:&lt;/label&gt;
        &lt;input
          type="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
          required
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;Confirm Password:&lt;/label&gt;
        &lt;input
          type="password"
          name="confirmPassword"
          value={formData.confirmPassword}
          onChange={handleChange}
          required
        /&gt;
      &lt;/div&gt;
      &lt;button type="submit"&gt;Register&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Textarea Element</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function EssayForm() {
  const [value, setValue] = useState('Please write an essay about your favorite DOM element.');
  
  const handleChange = (event) => {
    setValue(event.target.value);
  };
  
  const handleSubmit = (event) => {
    event.preventDefault();
    alert('An essay was submitted: ' + value);
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label&gt;
        Essay:
        &lt;textarea 
          value={value}
          onChange={handleChange}
          rows={10}
          cols={50}
        /&gt;
      &lt;/label&gt;
      &lt;input type="submit" value="Submit" /&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Select Element</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function FlavorForm() {
  const [value, setValue] = useState('coconut');
  
  const handleChange = (event) => {
    setValue(event.target.value);
  };
  
  const handleSubmit = (event) => {
    event.preventDefault();
    alert('Your favorite flavor is: ' + value);
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label&gt;
        Pick your favorite flavor:
        &lt;select value={value} onChange={handleChange}&gt;
          &lt;option value="grapefruit"&gt;Grapefruit&lt;/option&gt;
          &lt;option value="lime"&gt;Lime&lt;/option&gt;
          &lt;option value="coconut"&gt;Coconut&lt;/option&gt;
          &lt;option value="mango"&gt;Mango&lt;/option&gt;
        &lt;/select&gt;
      &lt;/label&gt;
      &lt;input type="submit" value="Submit" /&gt;
    &lt;/form&gt;
  );
}

// Multiple select
function MultiSelectForm() {
  const [selectedFruits, setSelectedFruits] = useState([]);
  
  const handleChange = (event) => {
    const selectedOptions = Array.from(event.target.selectedOptions);
    const selectedValues = selectedOptions.map(option => option.value);
    setSelectedFruits(selectedValues);
  };
  
  return (
    &lt;form&gt;
      &lt;label&gt;
        Select fruits:
        &lt;select 
          multiple 
          value={selectedFruits}
          onChange={handleChange}
          size={4}
        &gt;
          &lt;option value="apple"&gt;Apple&lt;/option&gt;
          &lt;option value="banana"&gt;Banana&lt;/option&gt;
          &lt;option value="orange"&gt;Orange&lt;/option&gt;
          &lt;option value="grape"&gt;Grape&lt;/option&gt;
        &lt;/select&gt;
      &lt;/label&gt;
      &lt;p&gt;Selected: {selectedFruits.join(', ')}&lt;/p&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Checkbox and Radio Inputs</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function CheckboxForm() {
  const [isChecked, setIsChecked] = useState(false);
  const [hobbies, setHobbies] = useState([]);
  
  const handleSingleCheckbox = (event) => {
    setIsChecked(event.target.checked);
  };
  
  const handleMultipleCheckboxes = (event) => {
    const { value, checked } = event.target;
    if (checked) {
      setHobbies([...hobbies, value]);
    } else {
      setHobbies(hobbies.filter(hobby => hobby !== value));
    }
  };
  
  return (
    &lt;form&gt;
      &lt;div&gt;
        &lt;label&gt;
          &lt;input
            type="checkbox"
            checked={isChecked}
            onChange={handleSingleCheckbox}
          /&gt;
          I agree to the terms and conditions
        &lt;/label&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;Select your hobbies:&lt;/label&gt;
        &lt;label&gt;
          &lt;input
            type="checkbox"
            value="reading"
            checked={hobbies.includes('reading')}
            onChange={handleMultipleCheckboxes}
          /&gt;
          Reading
        &lt;/label&gt;
        &lt;label&gt;
          &lt;input
            type="checkbox"
            value="sports"
            checked={hobbies.includes('sports')}
            onChange={handleMultipleCheckboxes}
          /&gt;
          Sports
        &lt;/label&gt;
        &lt;label&gt;
          &lt;input
            type="checkbox"
            value="music"
            checked={hobbies.includes('music')}
            onChange={handleMultipleCheckboxes}
          /&gt;
          Music
        &lt;/label&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
}

function RadioForm() {
  const [selectedOption, setSelectedOption] = useState('option1');
  
  const handleChange = (event) => {
    setSelectedOption(event.target.value);
  };
  
  return (
    &lt;form&gt;
      &lt;label&gt;
        &lt;input
          type="radio"
          value="option1"
          checked={selectedOption === 'option1'}
          onChange={handleChange}
        /&gt;
        Option 1
      &lt;/label&gt;
      &lt;label&gt;
        &lt;input
          type="radio"
          value="option2"
          checked={selectedOption === 'option2'}
          onChange={handleChange}
        /&gt;
        Option 2
      &lt;/label&gt;
      &lt;label&gt;
        &lt;input
          type="radio"
          value="option3"
          checked={selectedOption === 'option3'}
          onChange={handleChange}
        /&gt;
        Option 3
      &lt;/label&gt;
      &lt;p&gt;Selected: {selectedOption}&lt;/p&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>File Input</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function FileInput() {
  const [file, setFile] = useState(null);
  const [preview, setPreview] = useState('');
  
  const handleFileChange = (event) => {
    const selectedFile = event.target.files[0];
    setFile(selectedFile);
    
    // Create preview for image files
    if (selectedFile && selectedFile.type.startsWith('image/')) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setPreview(reader.result);
      };
      reader.readAsDataURL(selectedFile);
    } else {
      setPreview('');
    }
  };
  
  return (
    &lt;div&gt;
      &lt;input
        type="file"
        onChange={handleFileChange}
        accept="image/*"
      /&gt;
      {file && (
        &lt;div&gt;
          &lt;p&gt;Selected file: {file.name}&lt;/p&gt;
          &lt;p&gt;File size: {file.size} bytes&lt;/p&gt;
          &lt;p&gt;File type: {file.type}&lt;/p&gt;
          {preview && (
            &lt;img 
              src={preview} 
              alt="Preview" 
              style={{ maxWidth: '200px', maxHeight: '200px' }}
            /&gt;
          )}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Form Validation</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function ValidatedForm() {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  
  const validate = () => {
    const newErrors = {};
    
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }
    
    if (!formData.confirmPassword) {
      newErrors.confirmPassword = 'Please confirm your password';
    } else if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    return newErrors;
  };
  
  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData(prevData => ({
      ...prevData,
      [name]: value
    }));
    
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prevErrors => ({
        ...prevErrors,
        [name]: ''
      }));
    }
  };
  
  const handleBlur = (event) => {
    const { name } = event.target;
    setTouched(prevTouched => ({
      ...prevTouched,
      [name]: true
    }));
  };
  
  const handleSubmit = (event) => {
    event.preventDefault();
    const newErrors = validate();
    
    if (Object.keys(newErrors).length === 0) {
      console.log('Form submitted:', formData);
    } else {
      setErrors(newErrors);
      setTouched({
        email: true,
        password: true,
        confirmPassword: true
      });
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          onBlur={handleBlur}
          className={touched.email && errors.email ? 'error' : ''}
        /&gt;
        {touched.email && errors.email && (
          &lt;span className="error-message"&gt;{errors.email}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;Password:&lt;/label&gt;
        &lt;input
          type="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
          onBlur={handleBlur}
          className={touched.password && errors.password ? 'error' : ''}
        /&gt;
        {touched.password && errors.password && (
          &lt;span className="error-message"&gt;{errors.password}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;Confirm Password:&lt;/label&gt;
        &lt;input
          type="password"
          name="confirmPassword"
          value={formData.confirmPassword}
          onChange={handleChange}
          onBlur={handleBlur}
          className={touched.confirmPassword && errors.confirmPassword ? 'error' : ''}
        /&gt;
        {touched.confirmPassword && errors.confirmPassword && (
          &lt;span className="error-message"&gt;{errors.confirmPassword}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Form Libraries</h5>
                    <p>For complex forms, consider using libraries like Formik or React Hook Form:</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Using React Hook Form
import { useForm } from 'react-hook-form';

function ReactHookFormExample() {
  const { register, handleSubmit, formState: { errors } } = useForm();
  
  const onSubmit = (data) => {
    console.log(data);
  };
  
  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;input
        {...register('firstName', { required: 'First name is required' })}
        placeholder="First name"
      /&gt;
      {errors.firstName && &lt;span&gt;{errors.firstName.message}&lt;/span&gt;}
      
      &lt;input
        {...register('lastName', { required: 'Last name is required' })}
        placeholder="Last name"
      /&gt;
      {errors.lastName && &lt;span&gt;{errors.lastName.message}&lt;/span&gt;}
      
      &lt;input
        type="email"
        {...register('email', { 
          required: 'Email is required',
          pattern: {
            value: /\S+@\S+\.\S+/,
            message: 'Invalid email address'
          }
        })}
        placeholder="Email"
      /&gt;
      {errors.email && &lt;span&gt;{errors.email.message}&lt;/span&gt;}
      
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    {% endraw %}
                </div>
            </div>

            <!-- Module 11: Routing with React Router -->
            <div class="content-card" id="module11">
                <div class="card-header">
                    <i class="fas fa-route"></i> Module 11: Routing with React Router
                </div>
                <div class="card-body">
                    <h5>Introduction to React Router</h5>
                    <p>React Router is the standard routing library for React. It enables navigation between different components in your application, allowing you to build single-page applications with multiple views.</p>

                    <h5>Installation</h5>
                    <pre><button class="copy-button">Copy</button><code class="language-bash"># Install React Router
npm install react-router-dom

# or with yarn
yarn add react-router-dom</code></pre>

                    <h5>Basic Routing Setup</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React from 'react';
import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';

// Page components
function Home() {
  return &lt;h2&gt;Home Page&lt;/h2&gt;;
}

function About() {
  return &lt;h2&gt;About Page&lt;/h2&gt;;
}

function Contact() {
  return &lt;h2&gt;Contact Page&lt;/h2&gt;;
}

// Navigation component
function Navigation() {
  return (
    &lt;nav&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;
        &lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt;
        &lt;li&gt;&lt;Link to="/contact"&gt;Contact&lt;/Link&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/nav&gt;
  );
}

// Main App component
function App() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;Navigation /&gt;
        &lt;Routes&gt;
          &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
          &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
          &lt;Route path="/contact" element={&lt;Contact /&gt;} /&gt;
        &lt;/Routes&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Route Parameters</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { useParams } from 'react-router-dom';

function User() {
  let { id } = useParams();
  return &lt;h2&gt;User ID: {id}&lt;/h2&gt;;
}

function Product() {
  let { id, category } = useParams();
  return (
    &lt;div&gt;
      &lt;h2&gt;Product Details&lt;/h2&gt;
      &lt;p&gt;Category: {category}&lt;/p&gt;
      &lt;p&gt;Product ID: {id}&lt;/p&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;Router&gt;
      &lt;Routes&gt;
        &lt;Route path="/user/:id" element={&lt;User /&gt;} /&gt;
        &lt;Route path="/product/:category/:id" element={&lt;Product /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/Router&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Query Parameters</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { useSearchParams } from 'react-router-dom';

function SearchResults() {
  const [searchParams] = useSearchParams();
  const query = searchParams.get('q');
  const page = searchParams.get('page');
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Search Results&lt;/h2&gt;
      &lt;p&gt;Query: {query}&lt;/p&gt;
      &lt;p&gt;Page: {page || '1'}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Navigation with query parameters
function SearchPage() {
  const navigate = useNavigate();
  
  const handleSearch = (query) => {
    navigate(`/search?q=${encodeURIComponent(query)}&page=1`);
  };
  
  return (
    &lt;div&gt;
      &lt;input
        type="text"
        placeholder="Search..."
        onKeyPress={(e) => {
          if (e.key === 'Enter') {
            handleSearch(e.target.value);
          }
        }}
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Nested Routes</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { Outlet } from 'react-router-dom';

function Layout() {
  return (
    &lt;div&gt;
      &lt;header&gt;
        &lt;h1&gt;My App&lt;/h1&gt;
        &lt;nav&gt;
          &lt;Link to="/"&gt;Home&lt;/Link&gt;
          &lt;Link to="/dashboard"&gt;Dashboard&lt;/Link&gt;
        &lt;/nav&gt;
      &lt;/header&gt;
      &lt;main&gt;
        &lt;Outlet /&gt;
      &lt;/main&gt;
      &lt;footer&gt;
        &lt;p&gt;&copy; 2023 My App&lt;/p&gt;
      &lt;/footer&gt;
    &lt;/div&gt;
  );
}

function Dashboard() {
  return (
    &lt;div&gt;
      &lt;h2&gt;Dashboard&lt;/h2&gt;
      &lt;nav&gt;
        &lt;Link to="overview"&gt;Overview&lt;/Link&gt;
        &lt;Link to="settings"&gt;Settings&lt;/Link&gt;
      &lt;/nav&gt;
      &lt;Outlet /&gt;
    &lt;/div&gt;
  );
}

function Overview() {
  return &lt;h3&gt;Dashboard Overview&lt;/h3&gt;;
}

function Settings() {
  return &lt;h3&gt;Dashboard Settings&lt;/h3&gt;;
}

function App() {
  return (
    &lt;Router&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Layout /&gt;}&gt;
          &lt;Route index element={&lt;Home /&gt;} /&gt;
          &lt;Route path="dashboard" element={&lt;Dashboard /&gt;}&gt;
            &lt;Route path="overview" element={&lt;Overview /&gt;} /&gt;
            &lt;Route path="settings" element={&lt;Settings /&gt;} /&gt;
          &lt;/Route&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/Router&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Programmatic Navigation</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { useNavigate, useLocation } from 'react-router-dom';

function Login() {
  const navigate = useNavigate();
  const location = useLocation();
  
  const handleLogin = () => {
    // Perform login logic
    // ...
    
    // Redirect to previous page or home
    const from = location.state?.from?.pathname || '/';
    navigate(from, { replace: true });
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Login&lt;/h2&gt;
      &lt;button onClick={handleLogin}&gt;Login&lt;/button&gt;
    &lt;/div&gt;
  );
}

function ProtectedRoute({ children }) {
  const navigate = useNavigate();
  const location = useLocation();
  const isAuthenticated = false; // Check authentication status
  
  useEffect(() => {
    if (!isAuthenticated) {
      navigate('/login', { state: { from: location } });
    }
  }, [isAuthenticated, navigate, location]);
  
  return isAuthenticated ? children : null;
}</code></pre>
                    {% endraw %}

                    <h5>Route Guards and Authentication</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">function useAuth() {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  
  const login = () => {
    setIsAuthenticated(true);
  };
  
  const logout = () => {
    setIsAuthenticated(false);
  };
  
  return { isAuthenticated, login, logout };
}

function PrivateRoute({ children }) {
  const { isAuthenticated } = useAuth();
  const location = useLocation();
  
  if (!isAuthenticated) {
    return &lt;Navigate to="/login" state={{ from: location }} replace /&gt;;
  }
  
  return children;
}

function App() {
  return (
    &lt;Router&gt;
      &lt;Routes&gt;
        &lt;Route path="/login" element={&lt;Login /&gt;} /&gt;
        &lt;Route
          path="/dashboard"
          element={
            &lt;PrivateRoute&gt;
              &lt;Dashboard /&gt;
            &lt;/PrivateRoute&gt;
          }
        /&gt;
      &lt;/Routes&gt;
    &lt;/Router&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Custom Routes</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Animated route transitions
import { AnimatePresence, motion } from 'framer-motion';

function AnimatedRoutes() {
  const location = useLocation();
  
  return (
    &lt;AnimatePresence mode="wait"&gt;
      &lt;Routes location={location} key={location.pathname}&gt;
        &lt;Route
          path="/"
          element={
            &lt;motion.div
              initial={{ opacity: 0, x: -100 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 100 }}
            &gt;
              &lt;Home /&gt;
            &lt;/motion.div&gt;
          }
        /&gt;
        &lt;Route
          path="/about"
          element={
            &lt;motion.div
              initial={{ opacity: 0, x: -100 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 100 }}
            &gt;
              &lt;About /&gt;
            &lt;/motion.div&gt;
          }
        /&gt;
      &lt;/Routes&gt;
    &lt;/AnimatePresence&gt;
  );
}

// Lazy loading routes
import { lazy, Suspense } from 'react';

const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Contact = lazy(() => import('./pages/Contact'));

function LazyRoutes() {
  return (
    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
        &lt;Route path="/contact" element={&lt;Contact /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/Suspense&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Best Practices</h5>
                    <div class="data-type-section">
                        <h6>Organize Routes</h6>
                        <p>Keep route definitions organized and consider splitting them into separate files.</p>
                        
                        <h6>Use Nested Routes</h6>
                        <p>Leverage nested routes for better code organization and shared layouts.</p>
                        
                        <h6>Handle 404</h6>
                        <p>Always include a catch-all route for 404 pages.</p>
                        
                        <h6>Lazy Load</h6>
                        <p>Use lazy loading for better performance in large applications.</p>
                    </div>
                </div>
            </div>

            <!-- Module 12: Performance Optimization -->
            <div class="content-card" id="module12">
                <div class="card-header">
                    <i class="fas fa-tachometer-alt"></i> Module 12: Performance Optimization
                </div>
                <div class="card-body">
                    <h5>React Performance Fundamentals</h5>
                    <p>React applications can become slow as they grow in complexity. Understanding React's rendering behavior and applying optimization techniques is crucial for maintaining smooth user experience.</p>

                    <h5>React.memo</h5>
                    <p>React.memo is a higher-order component that prevents re-rendering if props haven't changed.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React from 'react';

const ExpensiveComponent = React.memo(function ExpensiveComponent({ data, onUpdate }) {
  console.log('ExpensiveComponent rendered');
  
  // Expensive calculation
  const processedData = data.map(item => ({
    ...item,
    value: item.value * 2
  }));
  
  return (
    &lt;div&gt;
      {processedData.map(item => (
        &lt;ComplexItem key={item.id} item={item} /&gt;
      ))}
    &lt;/div&gt;
  );
});

// Custom comparison function
const CustomMemoComponent = React.memo(function CustomMemoComponent({ user, settings }) {
  return (
    &lt;div&gt;
      &lt;h3&gt;{user.name}&lt;/h3&gt;
      &lt;p&gt;Theme: {settings.theme}&lt;/p&gt;
    &lt;/div&gt;
  );
}, (prevProps, nextProps) => {
  // Only re-render if user.name or settings.theme changed
  return (
    prevProps.user.name === nextProps.user.name &&
    prevProps.settings.theme === nextProps.settings.theme
  );
});

// Usage
function Parent() {
  const [count, setCount] = useState(0);
  const [data, setData] = useState([{ id: 1, value: 10 }]);
  
  return (
    &lt;div&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        Count: {count}
      &lt;/button&gt;
      &lt;ExpensiveComponent 
        data={data} 
        onUpdate={() => console.log('Update')}
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>useMemo Hook</h5>
                    <p>useMemo memoizes expensive calculations and only recomputes when dependencies change.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { useMemo } from 'react';

function ExpensiveCalculation({ numbers, multiplier }) {
  const expensiveResult = useMemo(() => {
    console.log('Performing expensive calculation...');
    return numbers.reduce((sum, num) => sum + num * multiplier, 0);
  }, [numbers, multiplier]);
  
  return (
    &lt;div&gt;
      &lt;p&gt;Result: {expensiveResult}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Memoizing complex objects
function UserList({ users, filter }) {
  const filteredUsers = useMemo(() => {
    console.log('Filtering users...');
    return users.filter(user => 
      user.name.toLowerCase().includes(filter.toLowerCase())
    );
  }, [users, filter]);
  
  const userStats = useMemo(() => {
    return {
      total: filteredUsers.length,
      active: filteredUsers.filter(u => u.isActive).length,
      averageAge: filteredUsers.reduce((sum, u) => sum + u.age, 0) / filteredUsers.length || 0
    };
  }, [filteredUsers]);
  
  return (
    &lt;div&gt;
      &lt;div className="stats"&gt;
        &lt;p&gt;Total: {userStats.total}&lt;/p&gt;
        &lt;p&gt;Active: {userStats.active}&lt;/p&gt;
        &lt;p&gt;Average Age: {userStats.averageAge.toFixed(1)}&lt;/p&gt;
      &lt;/div&gt;
      &lt;ul&gt;
        {filteredUsers.map(user => (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>useCallback Hook</h5>
                    <p>useCallback memoizes functions and prevents unnecessary re-renders in child components.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { useCallback } from 'react';

function Button({ onClick, children }) {
  console.log('Button rendered');
  return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;
}

const MemoizedButton = React.memo(Button);

function Parent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  // Without useCallback - Button re-renders on every Parent render
  const handleClickWithoutCallback = () => {
    setCount(count + 1);
  };
  
  // With useCallback - Button only re-renders when count changes
  const handleClick = useCallback(() => {
    setCount(count + 1);
  }, [count]);
  
  // With dependencies - re-creates when dependencies change
  const handleReset = useCallback(() => {
    setCount(0);
    setName('');
  }, []);
  
  return (
    &lt;div&gt;
      &lt;MemoizedButton onClick={handleClick}&gt;
        Increment
      &lt;/MemoizedButton&gt;
      &lt;MemoizedButton onClick={handleReset}&gt;
        Reset
      &lt;/MemoizedButton&gt;
      &lt;input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Name"
      /&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Event handler optimization
function TodoList({ todos, onToggle, onDelete }) {
  const handleToggle = useCallback((id) => {
    onToggle(id);
  }, [onToggle]);
  
  const handleDelete = useCallback((id) => {
    onDelete(id);
  }, [onDelete]);
  
  return (
    &lt;ul&gt;
      {todos.map(todo => (
        &lt;TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}
          onDelete={handleDelete}
        /&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Code Splitting</h5>
                    <p>Code splitting reduces initial bundle size by loading components on demand.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { lazy, Suspense } from 'react';

// Lazy loading components
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));

function App() {
  return (
    &lt;Router&gt;
      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;Routes&gt;
          &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
          &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
          &lt;Route path="/dashboard" element={&lt;Dashboard /&gt;} /&gt;
        &lt;/Routes&gt;
      &lt;/Suspense&gt;
    &lt;/Router&gt;
  );
}

// Dynamic imports with loading states
function LazyComponent({ componentPath }) {
  const [Component, setComponent] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const loadComponent = async () => {
      try {
        setLoading(true);
        const module = await import(`./components/${componentPath}`);
        setComponent(() => module.default);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    
    loadComponent();
  }, [componentPath]);
  
  if (loading) return &lt;div&gt;Loading component...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error loading component&lt;/div&gt;;
  if (!Component) return &lt;div&gt;Component not found&lt;/div&gt;;
  
  return &lt;Component /&gt;;
}</code></pre>
                    {% endraw %}

                    <h5>Virtualization</h5>
                    <p>Virtualization renders only visible items for large lists, improving performance.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { FixedSizeList as List } from 'react-window';
import { FixedSizeGrid as Grid } from 'react-window';

// Virtual list
function VirtualList({ items }) {
  const Row = ({ index, style }) => (
    &lt;div style={style}&gt;
      {items[index].name}
    &lt;/div&gt;
  );
  
  return (
    &lt;List
      height={400}
      itemCount={items.length}
      itemSize={35}
      width="100%"
    &gt;
      {Row}
    &lt;/List&gt;
  );
}

// Virtual grid
function VirtualGrid({ items }) {
  const Cell = ({ columnIndex, rowIndex, style }) => {
    const item = items[rowIndex * 10 + columnIndex];
    return (
      &lt;div style={style}&gt;
        {item ? item.name : ''}
      &lt;/div&gt;
    );
  };
  
  return (
    &lt;Grid
      columnCount={10}
      columnWidth={100}
      height={400}
      rowCount={Math.ceil(items.length / 10)}
      rowHeight={35}
      width={1000}
    &gt;
      {Cell}
    &lt;/Grid&gt;
  );
}

// Custom virtual list implementation
function CustomVirtualList({ items, itemHeight, containerHeight }) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    startIndex + Math.ceil(containerHeight / itemHeight) + 1,
    items.length - 1
  );
  
  const visibleItems = items.slice(startIndex, endIndex + 1);
  
  const handleScroll = (e) => {
    setScrollTop(e.target.scrollTop);
  };
  
  return (
    &lt;div
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={handleScroll}
    &gt;
      &lt;div style={{ height: items.length * itemHeight, position: 'relative' }}&gt;
        {visibleItems.map((item, index) => (
          &lt;div
            key={startIndex + index}
            style={{
              position: 'absolute',
              top: (startIndex + index) * itemHeight,
              height: itemHeight,
              width: '100%'
            }}
          &gt;
            {item.name}
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>State Optimization</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// State colocation - keep state close to where it's used
function TodoItem({ todo, onToggle, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(todo.text);
  
  const handleSave = () => {
    onToggle(todo.id, editText);
    setIsEditing(false);
  };
  
  return (
    &lt;div&gt;
      {isEditing ? (
        &lt;input
          value={editText}
          onChange={(e) => setEditText(e.target.value)}
          onBlur={handleSave}
          onKeyPress={(e) => e.key === 'Enter' && handleSave()}
        /&gt;
      ) : (
        &lt;span onClick={() => setIsEditing(true)}&gt;
          {todo.text}
        &lt;/span&gt;
      )}
      &lt;button onClick={() => onDelete(todo.id)}&gt;Delete&lt;/button&gt;
    &lt;/div&gt;
  );
}

// State normalization for complex data
function useNormalizedState(initialData) {
  const [entities, setEntities] = useState({});
  const [ids, setIds] = useState([]);
  
  const normalize = (data) => {
    const newEntities = {};
    const newIds = [];
    
    data.forEach(item => {
      newEntities[item.id] = item;
      newIds.push(item.id);
    });
    
    setEntities(newEntities);
    setIds(newIds);
  };
  
  const updateEntity = (id, updates) => {
    setEntities(prev => ({
      ...prev,
      [id]: { ...prev[id], ...updates }
    }));
  };
  
  const deleteEntity = (id) => {
    setEntities(prev => {
      const newEntities = { ...prev };
      delete newEntities[id];
      return newEntities;
    });
    setIds(prev => prev.filter(existingId => existingId !== id));
  };
  
  return {
    entities,
    ids,
    normalize,
    updateEntity,
    deleteEntity
  };
}</code></pre>
                    {% endraw %}

                    <h5>Performance Monitoring</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// React DevTools Profiler
import { Profiler } from 'react';

function onRenderCallback(id, phase, actualDuration) {
  console.log('Component:', id);
  console.log('Phase:', phase);
  console.log('Duration:', actualDuration);
}

function App() {
  return (
    &lt;Profiler id="App" onRender={onRenderCallback}&gt;
      &lt;MyComponent /&gt;
    &lt;/Profiler&gt;
  );
}

// Custom performance hook
function usePerformanceMonitor(componentName) {
  const renderCount = useRef(0);
  const lastRenderTime = useRef(Date.now());
  
  useEffect(() => {
    renderCount.current += 1;
    const now = Date.now();
    const timeSinceLastRender = now - lastRenderTime.current;
    
    console.log(`${componentName} rendered ${renderCount.current} times`);
    console.log(`Time since last render: ${timeSinceLastRender}ms`);
    
    lastRenderTime.current = now;
  });
  
  return renderCount.current;
}

// Usage
function MyComponent() {
  const renderCount = usePerformanceMonitor('MyComponent');
  
  return (
    &lt;div&gt;
      &lt;p&gt;Render count: {renderCount}&lt;/p&gt;
      {/* Component content */}
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Performance Best Practices</h5>
                    <div class="data-type-section">
                        <h6>Avoid Unnecessary Renders</h6>
                        <p>Use React.memo, useMemo, and useCallback to prevent unnecessary re-renders.</p>
                        
                        <h6>Optimize State Updates</h6>
                        <p>Batch state updates and use functional updates when possible.</p>
                        
                        <h6>Virtualize Large Lists</h6>
                        <p>Use virtualization for lists with many items.</p>
                        
                        <h6>Code Split</h6>
                        <p>Split code into smaller chunks and load on demand.</p>
                        
                        <h6>Monitor Performance</h6>
                        <p>Use React DevTools Profiler to identify performance bottlenecks.</p>
                    </div>
                </div>
            </div>

            <!-- Module 13: Testing React Applications -->
            <div class="content-card" id="module13">
                <div class="card-header">
                    <i class="fas fa-vial"></i> Module 13: Testing React Applications
                </div>
                <div class="card-body">
                    <h5>Introduction to React Testing</h5>
                    <p>Testing is crucial for building reliable React applications. It helps catch bugs early, ensures code quality, and makes refactoring safer. React applications can be tested at multiple levels: unit tests, integration tests, and end-to-end tests.</p>

                    <h5>Setting Up Testing Environment</h5>
                    <pre><button class="copy-button">Copy</button><code class="language-bash"># Install testing libraries
npm install --save-dev @testing-library/react @testing-library/jest-dom @testing-library/user-event jest

# Install additional testing utilities
npm install --save-dev @testing-library/jest-environment-jsdom msw

# For TypeScript
npm install --save-dev @types/jest</code></pre>

                    <h5>Component Testing</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';

// Component to test
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;p data-testid="count"&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;Increment&lt;/button&gt;
      &lt;button onClick={() => setCount(count - 1)}&gt;Decrement&lt;/button&gt;
    &lt;/div&gt;
  );
}

// Test file
describe('Counter Component', () => {
  test('renders initial count', () => {
    render(&lt;Counter /&gt;);
    
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 0');
  });
  
  test('increments count when increment button is clicked', async () => {
    const user = userEvent.setup();
    render(&lt;Counter /&gt;);
    
    const incrementButton = screen.getByText('Increment');
    await user.click(incrementButton);
    
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 1');
  });
  
  test('decrements count when decrement button is clicked', async () => {
    const user = userEvent.setup();
    render(&lt;Counter /&gt;);
    
    const decrementButton = screen.getByText('Decrement');
    await user.click(decrementButton);
    
    expect(screen.getByTestId('count')).toHaveTextContent('Count: -1');
  });
  
  test('multiple clicks update count correctly', async () => {
    const user = userEvent.setup();
    render(&lt;Counter /&gt;);
    
    const incrementButton = screen.getByText('Increment');
    await user.click(incrementButton);
    await user.click(incrementButton);
    await user.click(incrementButton);
    
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 3');
  });
});</code></pre>
                    {% endraw %}

                    <h5>Testing Forms</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Form component
function LoginForm({ onSubmit }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    if (!email || !password) {
      setError('Please fill in all fields');
      return;
    }
    
    setError('');
    onSubmit({ email, password });
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          data-testid="email-input"
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;Password:&lt;/label&gt;
        &lt;input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          data-testid="password-input"
        /&gt;
      &lt;/div&gt;
      {error && &lt;div data-testid="error"&gt;{error}&lt;/div&gt;}
      &lt;button type="submit" data-testid="submit-button"&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  );
}

// Test file
describe('LoginForm Component', () => {
  const mockSubmit = jest.fn();
  
  beforeEach(() => {
    mockSubmit.mockClear();
  });
  
  test('renders form elements', () => {
    render(&lt;LoginForm onSubmit={mockSubmit} /&gt;);
    
    expect(screen.getByTestId('email-input')).toBeInTheDocument();
    expect(screen.getByTestId('password-input')).toBeInTheDocument();
    expect(screen.getByTestId('submit-button')).toBeInTheDocument();
  });
  
  test('shows error when submitting empty form', async () => {
    const user = userEvent.setup();
    render(&lt;LoginForm onSubmit={mockSubmit} /&gt;);
    
    const submitButton = screen.getByTestId('submit-button');
    await user.click(submitButton);
    
    expect(screen.getByTestId('error')).toHaveTextContent('Please fill in all fields');
    expect(mockSubmit).not.toHaveBeenCalled();
  });
  
  test('submits form with valid data', async () => {
    const user = userEvent.setup();
    render(&lt;LoginForm onSubmit={mockSubmit} /&gt;);
    
    const emailInput = screen.getByTestId('email-input');
    const passwordInput = screen.getByTestId('password-input');
    const submitButton = screen.getByTestId('submit-button');
    
    await user.type(emailInput, 'test@example.com');
    await user.type(passwordInput, 'password123');
    await user.click(submitButton);
    
    expect(screen.queryByTestId('error')).not.toBeInTheDocument();
    expect(mockSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123'
    });
  });
  
  test('clears error when user starts typing', async () => {
    const user = userEvent.setup();
    render(&lt;LoginForm onSubmit={mockSubmit} /&gt;);
    
    const submitButton = screen.getByTestId('submit-button');
    const emailInput = screen.getByTestId('email-input');
    
    await user.click(submitButton);
    expect(screen.getByTestId('error')).toBeInTheDocument();
    
    await user.type(emailInput, 'test@example.com');
    expect(screen.queryByTestId('error')).not.toBeInTheDocument();
  });
});</code></pre>
                    {% endraw %}

                    <h5>Testing Async Components</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Async component
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchUser = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) throw new Error('Failed to fetch user');
        const userData = await response.json();
        setUser(userData);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUser();
  }, [userId]);
  
  if (loading) return &lt;div data-testid="loading"&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div data-testid="error"&gt;Error: {error}&lt;/div&gt;;
  if (!user) return &lt;div data-testid="no-user"&gt;No user found&lt;/div&gt;;
  
  return (
    &lt;div data-testid="user-profile"&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Test file with mocking
describe('UserProfile Component', () => {
  const mockFetch = jest.fn();
  
  beforeEach(() => {
    mockFetch.mockClear();
    global.fetch = mockFetch;
  });
  
  afterEach(() => {
    delete global.fetch;
  });
  
  test('shows loading state initially', () => {
    render(&lt;UserProfile userId="1" /&gt;);
    
    expect(screen.getByTestId('loading')).toBeInTheDocument();
    expect(screen.queryByTestId('user-profile')).not.toBeInTheDocument();
  });
  
  test('displays user data after successful fetch', async () => {
    const mockUser = { id: 1, name: 'John Doe', email: 'john@example.com' };
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockUser
    });
    
    render(&lt;UserProfile userId="1" /&gt;);
    
    expect(screen.getByTestId('loading')).toBeInTheDocument();
    
    await waitFor(() => {
      expect(screen.getByTestId('user-profile')).toBeInTheDocument();
      expect(screen.getByText('John Doe')).toBeInTheDocument();
      expect(screen.getByText('john@example.com')).toBeInTheDocument();
    });
    
    expect(mockFetch).toHaveBeenCalledWith('/api/users/1');
  });
  
  test('displays error message when fetch fails', async () => {
    mockFetch.mockResolvedValueOnce({
      ok: false,
      statusText: 'Not Found'
    });
    
    render(&lt;UserProfile userId="999" /&gt;);
    
    await waitFor(() => {
      expect(screen.getByTestId('error')).toBeInTheDocument();
      expect(screen.getByText(/Failed to fetch user/)).toBeInTheDocument();
    });
  });
  
  test('refetches when userId changes', async () => {
    const mockUser1 = { id: 1, name: 'John Doe', email: 'john@example.com' };
    const mockUser2 = { id: 2, name: 'Jane Smith', email: 'jane@example.com' };
    
    mockFetch
      .mockResolvedValueOnce({ ok: true, json: async () => mockUser1 })
      .mockResolvedValueOnce({ ok: true, json: async () => mockUser2 });
    
    const { rerender } = render(&lt;UserProfile userId="1" /&gt;);
    
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
    });
    
    rerender(&lt;UserProfile userId="2" /&gt;);
    
    expect(screen.getByTestId('loading')).toBeInTheDocument();
    
    await waitFor(() => {
      expect(screen.getByText('Jane Smith')).toBeInTheDocument();
    });
    
    expect(mockFetch).toHaveBeenCalledTimes(2);
  });
});</code></pre>
                    {% endraw %}

                    <h5>Testing Custom Hooks</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { renderHook, act } from '@testing-library/react';

// Custom hook
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(initialValue);
  
  return { count, increment, decrement, reset };
}

// Test file
describe('useCounter Hook', () => {
  test('returns initial count', () => {
    const { result } = renderHook(() => useCounter());
    
    expect(result.current.count).toBe(0);
  });
  
  test('returns custom initial count', () => {
    const { result } = renderHook(() => useCounter(5));
    
    expect(result.current.count).toBe(5);
  });
  
  test('increments count', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });
  
  test('decrements count', () => {
    const { result } = renderHook(() => useCounter(10));
    
    act(() => {
      result.current.decrement();
    });
    
    expect(result.current.count).toBe(9);
  });
  
  test('resets count to initial value', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.increment();
      result.current.increment();
    });
    
    expect(result.current.count).toBe(7);
    
    act(() => {
      result.current.reset();
    });
    
    expect(result.current.count).toBe(5);
  });
  
  test('handles multiple updates', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
      result.current.increment();
      result.current.decrement();
      result.current.increment();
    });
    
    expect(result.current.count).toBe(2);
  });
});</code></pre>
                    {% endraw %}

                    <h5>Mocking API Calls</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { setupServer } from 'msw/node';
import { rest } from 'msw';

// Mock server setup
const server = setupServer(
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.json([
        { id: 1, name: 'John Doe', email: 'john@example.com' },
        { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
      ])
    );
  }),
  rest.post('/api/users', (req, res, ctx) => {
    return res(
      ctx.status(201),
      ctx.json({ id: 3, name: 'New User', email: 'new@example.com' })
    );
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

// Component that uses API
function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetch('/api/users')
      .then(response => response.json())
      .then(data => {
        setUsers(data);
        setLoading(false);
      });
  }, []);
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  
  return (
    &lt;ul&gt;
      {users.map(user => (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Test file
describe('UserList with MSW', () => {
  test('displays users from API', async () => {
    render(&lt;UserList /&gt;);
    
    expect(screen.getByText('Loading...')).toBeInTheDocument();
    
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
      expect(screen.getByText('Jane Smith')).toBeInTheDocument();
    });
  });
  
  test('handles API error', async () => {
    server.use(
      rest.get('/api/users', (req, res, ctx) => {
        return res(ctx.status(500));
      })
    );
    
    render(&lt;UserList /&gt;);
    
    await waitFor(() => {
      expect(screen.getByText(/Error/)).toBeInTheDocument();
    });
  });
});</code></pre>
                    {% endraw %}

                    <h5>Integration Testing</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Integration test for user flow
describe('User Registration Flow', () => {
  test('user can register and see profile', async () => {
    const user = userEvent.setup();
    
    render(&lt;App /&gt;);
    
    // Navigate to registration
    const registerLink = screen.getByText('Register');
    await user.click(registerLink);
    
    // Fill registration form
    const nameInput = screen.getByLabelText('Name');
    const emailInput = screen.getByLabelText('Email');
    const passwordInput = screen.getByLabelText('Password');
    const submitButton = screen.getByText('Register');
    
    await user.type(nameInput, 'John Doe');
    await user.type(emailInput, 'john@example.com');
    await user.type(passwordInput, 'password123');
    await user.click(submitButton);
    
    // Verify registration success
    await waitFor(() => {
      expect(screen.getByText('Registration successful!')).toBeInTheDocument();
    });
    
    // Verify redirect to profile
    await waitFor(() => {
      expect(screen.getByText('Welcome, John Doe')).toBeInTheDocument();
      expect(screen.getByText('john@example.com')).toBeInTheDocument();
    });
  });
});</code></pre>
                    {% endraw %}

                    <h5>Testing Best Practices</h5>
                    <div class="data-type-section">
                        <h6>Test Behavior, Not Implementation</h6>
                        <p>Focus on what the component does, not how it does it.</p>
                        
                        <h6>Use Meaningful Queries</h6>
                        <p>Use getByRole, getByLabelText, and other accessible queries.</p>
                        
                        <h6>Mock External Dependencies</h6>
                        <p>Mock API calls, timers, and other external dependencies.</p>
                        
                        <h6>Test Edge Cases</h6>
                        <p>Test error states, empty states, and boundary conditions.</p>
                        
                        <h6>Keep Tests Simple</h6>
                        <p>Each test should focus on one specific behavior.</p>
                    </div>
                </div>
            </div>

            <!-- Module 14: React Best Practices -->
            <div class="content-card" id="module14">
                <div class="card-header">
                    <i class="fas fa-star"></i> Module 14: React Best Practices
                </div>
                <div class="card-body">
                    <h5>Component Architecture</h5>
                    <p>Building maintainable React applications requires following established patterns and best practices for component design and organization.</p>

                    <h5>Single Responsibility Principle</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Good: Component with single responsibility
function UserAvatar({ user, size }) {
  return (
    &lt;img
      src={user.avatarUrl}
      alt={user.name}
      width={size}
      height={size}
      className="user-avatar"
    /&gt;
  );
}

function UserInfo({ user }) {
  return (
    &lt;div className="user-info"&gt;
      &lt;UserAvatar user={user} size={50} /&gt;
      &lt;div className="user-details"&gt;
        &lt;h3&gt;{user.name}&lt;/h3&gt;
        &lt;p&gt;{user.email}&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Bad: Component doing too much
function UserCard({ user }) {
  const [isEditing, setIsEditing] = useState(false);
  const [editName, setEditName] = useState(user.name);
  
  const handleSave = async () => {
    await fetch(`/api/users/${user.id}`, {
      method: 'PUT',
      body: JSON.stringify({ name: editName })
    });
    setIsEditing(false);
  };
  
  return (
    &lt;div&gt;
      &lt;img src={user.avatarUrl} alt={user.name} /&gt;
      {isEditing ? (
        &lt;input
          value={editName}
          onChange={(e) => setEditName(e.target.value)}
        /&gt;
      ) : (
        &lt;h3&gt;{user.name}&lt;/h3&gt;
      )}
      &lt;p&gt;{user.email}&lt;/p&gt;
      &lt;button onClick={() => setIsEditing(true)}&gt;Edit&lt;/button&gt;
      &lt;button onClick={handleSave}&gt;Save&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Composition over Inheritance</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Good: Using composition
function Card({ children, className, ...props }) {
  return (
    &lt;div className={`card ${className}`} {...props}&gt;
      {children}
    &lt;/div&gt;
  );
}

function CardHeader({ children }) {
  return &lt;div className="card-header"&gt;{children}&lt;/div&gt;;
}

function CardBody({ children }) {
  return &lt;div className="card-body"&gt;{children}&lt;/div&gt;;
}

function CardFooter({ children }) {
  return &lt;div className="card-footer"&gt;{children}&lt;/div&gt;;
}

// Usage
function ProductCard({ product }) {
  return (
    &lt;Card className="product-card"&gt;
      &lt;CardHeader&gt;
        &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;/CardHeader&gt;
      &lt;CardBody&gt;
        &lt;p&gt;{product.description}&lt;/p&gt;
        &lt;p&gt;${product.price}&lt;/p&gt;
      &lt;/CardBody&gt;
      &lt;CardFooter&gt;
        &lt;button&gt;Add to Cart&lt;/button&gt;
      &lt;/CardFooter&gt;
    &lt;/Card&gt;
  );
}

// Bad: Using inheritance (not recommended in React)
class BaseCard extends React.Component {
  render() {
    return (
      &lt;div className={`card ${this.props.className}`}&gt;
        {this.props.children}
      &lt;/div&gt;
    );
  }
}

class ProductCard extends BaseCard {
  render() {
    return (
      &lt;super&gt;
        &lt;h3&gt;{this.props.product.name}&lt;/h3&gt;
        &lt;p&gt;{this.props.product.description}&lt;/p&gt;
      &lt;/super&gt;
    );
  }
}</code></pre>
                    {% endraw %}

                    <h5>State Management Patterns</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Good: Lifting state up when needed
function Parent() {
  const [sharedState, setSharedState] = useState('initial');
  
  return (
    &lt;div&gt;
      &lt;ChildA value={sharedState} onChange={setSharedState} /&gt;
      &lt;ChildB value={sharedState} /&gt;
    &lt;/div&gt;
  );
}

// Good: Using context for truly global state
const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };
  
  return (
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// Good: Keeping state local when possible
function TodoItem({ todo, onToggle, onDelete }) {
  const [isEditing, setIsEditing] = useState(false); // Local state
  
  return (
    &lt;div&gt;
      {isEditing ? (
        &lt;TodoEditForm
          todo={todo}
          onSave={() => setIsEditing(false)}
        /&gt;
      ) : (
        &lt;TodoDisplay
          todo={todo}
          onEdit={() => setIsEditing(true)}
          onToggle={onToggle}
          onDelete={onDelete}
        /&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Prop Drilling Solutions</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Problem: Prop drilling
function App() {
  const [user, setUser] = useState(null);
  
  return (
    &lt;div&gt;
      &lt;Header user={user} /&gt;
      &lt;Main&gt;
        &lt;Dashboard user={user} /&gt;
        &lt;Sidebar&gt;
          &lt;UserProfile user={user} /&gt;
        &lt;/Sidebar&gt;
      &lt;/Main&gt;
    &lt;/div&gt;
  );
}

// Solution 1: Context API
const UserContext = createContext();

function App() {
  const [user, setUser] = useState(null);
  
  return (
    &lt;UserContext.Provider value={{ user, setUser }}&gt;
      &lt;div&gt;
        &lt;Header /&gt;
        &lt;Main&gt;
          &lt;Dashboard /&gt;
          &lt;Sidebar&gt;
            &lt;UserProfile /&gt;
          &lt;/Sidebar&gt;
        &lt;/Main&gt;
      &lt;/div&gt;
    &lt;/UserContext.Provider&gt;
  );
}

// Solution 2: Component composition
function App() {
  const [user, setUser] = useState(null);
  
  return (
    &lt;div&gt;
      &lt;Header /&gt;
      &lt;Main&gt;
        &lt;UserProvider user={user}&gt;
          &lt;Dashboard /&gt;
          &lt;Sidebar&gt;
            &lt;UserProfile /&gt;
          &lt;/Sidebar&gt;
        &lt;/UserProvider&gt;
      &lt;/Main&gt;
    &lt;/div&gt;
  );
}

function UserProvider({ user, children }) {
  return (
    &lt;div&gt;
      {React.Children.map(children, child => 
        React.cloneElement(child, { user })
      )}
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Custom Hooks for Logic Reuse</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Good: Custom hook for API calls
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network response was not ok');
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [url]);
  
  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useApi(`/api/users/${userId}`);
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  return &lt;div&gt;{user?.name}&lt;/div&gt;;
}

// Good: Custom hook for local storage
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  const setValue = (value) => {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  };
  
  return [storedValue, setValue];
}</code></pre>
                    {% endraw %}

                    <h5>Performance Best Practices</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Good: Using React.memo for expensive components
const ExpensiveComponent = React.memo(function ExpensiveComponent({ data }) {
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      computed: expensiveCalculation(item)
    }));
  }, [data]);
  
  return (
    &lt;div&gt;
      {processedData.map(item => (
        &lt;ComplexItem key={item.id} item={item} /&gt;
      ))}
    &lt;/div&gt;
  );
});

// Good: Using useCallback for stable function references
function Parent({ items }) {
  const [selectedId, setSelectedId] = useState(null);
  
  const handleSelect = useCallback((id) => {
    setSelectedId(id);
  }, []);
  
  return (
    &lt;div&gt;
      {items.map(item => (
        &lt;Item
          key={item.id}
          item={item}
          onSelect={handleSelect}
          isSelected={selectedId === item.id}
        /&gt;
      ))}
    &lt;/div&gt;
  );
}

// Good: Code splitting for large components
const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  const [showHeavy, setShowHeavy] = useState(false);
  
  return (
    &lt;div&gt;
      &lt;button onClick={() => setShowHeavy(true)}&gt;
        Load Heavy Component
      &lt;/button&gt;
      {showHeavy && (
        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
          &lt;HeavyComponent /&gt;
        &lt;/Suspense&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Code Organization</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Good: Feature-based organization
src/
├── components/
│   ├── common/
│   │   ├── Button/
│   │   │   ├── Button.jsx
│   │   │   ├── Button.module.css
│   │   │   ├── Button.test.jsx
│   │   │   └── index.js
│   │   └── Input/
│   └── features/
│       ├── UserProfile/
│       │   ├── UserProfile.jsx
│       │   ├── UserProfile.module.css
│       │   ├── UserProfile.test.jsx
│       │   └── index.js
│       └── TodoList/
├── hooks/
│   ├── useApi.js
│   ├── useLocalStorage.js
│   └── index.js
├── context/
│   ├── ThemeContext.js
│   └── index.js
├── utils/
│   ├── helpers.js
│   └── constants.js
└── services/
    ├── api.js
    └── auth.js

// Good: Barrel exports
// components/common/Button/index.js
export { default } from './Button';
export { ButtonSizes } from './Button.constants';

// Good: Index files for clean imports
// components/index.js
export { default as Button } from './common/Button';
export { default as Input } from './common/Input';
export { default as UserProfile } from './features/UserProfile';</code></pre>
                    {% endraw %}

                    <h5>Error Handling</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Good: Error boundaries for class components
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // Send error to logging service
  }
  
  render() {
    if (this.state.hasError) {
      return (
        &lt;div className="error-fallback"&gt;
          &lt;h2&gt;Something went wrong.&lt;/h2&gt;
          &lt;details&gt;
            {this.state.error && this.state.error.toString()}
          &lt;/details&gt;
        &lt;/div&gt;
      );
    }
    
    return this.props.children;
  }
}

// Good: Error handling with hooks
function useErrorHandler() {
  const [error, setError] = useState(null);
  
  const resetError = () => setError(null);
  
  const catchError = (error) => {
    setError(error);
  };
  
  useEffect(() => {
    if (error) {
      throw error;
    }
  }, [error]);
  
  return { catchError, resetError };
}

function ErrorBoundary({ children }) {
  const { catchError, resetError } = useErrorHandler();
  
  return (
    &lt;div&gt;
      {children}
      &lt;button onClick={resetError}&gt;Reset Error&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Security Best Practices</h5>
                    <div class="data-type-section">
                        <h6>Sanitize User Input</h6>
                        <p>Always sanitize user input to prevent XSS attacks.</p>
                        
                        <h6>Use HTTPS</h6>
                        <p>Always use HTTPS in production to encrypt data in transit.</p>
                        
                        <h6>Validate Data</h6>
                        <p>Validate all data on both client and server side.</p>
                        
                        <h6>Secure API Keys</h6>
                        <p>Never expose API keys or sensitive data in client-side code.</p>
                        
                        <h6>Use CSP Headers</h6>
                        <p>Implement Content Security Policy headers for additional security.</p>
                    </div>
                </div>
            </div>

            <!-- Module 15: Advanced React Patterns -->
            <div class="content-card" id="module15">
                <div class="card-header">
                    <i class="fas fa-project-diagram"></i> Module 15: Advanced React Patterns
                </div>
                <div class="card-body">
                    <h5>Compound Components</h5>
                    <p>Compound components are a pattern where multiple components work together to share implicit state through a context.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React, { createContext, useContext } from 'react';

const ToggleContext = createContext();

function Toggle({ children, onToggle }) {
  const [on, setOn] = useState(false);
  
  const toggle = () => {
    const newOn = !on;
    setOn(newOn);
    onToggle?.(newOn);
  };
  
  return (
    &lt;ToggleContext.Provider value={{ on, toggle }}&gt;
      {children}
    &lt;/ToggleContext.Provider&gt;
  );
}

function useToggle() {
  const context = useContext(ToggleContext);
  if (!context) {
    throw new Error('useToggle must be used within a Toggle');
  }
  return context;
}

// Compound components
Toggle.On = function ToggleOn({ children }) {
  const { on } = useToggle();
  return on ? children : null;
};

Toggle.Off = function ToggleOff({ children }) {
  const { on } = useToggle();
  return on ? null : children;
};

Toggle.Button = function ToggleButton(props) {
  const { on, toggle } = useToggle();
  return (
    &lt;button onClick={toggle} {...props}&gt;
      {on ? 'Turn Off' : 'Turn On'}
    &lt;/button&gt;
  );
};

// Usage
function App() {
  return (
    &lt;Toggle onToggle={(on) => console.log('Toggle is:', on)}&gt;
      &lt;Toggle.On&gt;The button is ON&lt;/Toggle.On&gt;
      &lt;Toggle.Off&gt;The button is OFF&lt;/Toggle.Off&gt;
      &lt;Toggle.Button /&gt;
    &lt;/Toggle&gt;
  );
}

// More complex example: Menu component
const MenuContext = createContext();

function Menu({ children }) {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    &lt;MenuContext.Provider value={{ isOpen, setIsOpen }}&gt;
      &lt;div className="menu"&gt;{children}&lt;/div&gt;
    &lt;/MenuContext.Provider&gt;
  );
}

function useMenu() {
  const context = useContext(MenuContext);
  if (!context) {
    throw new Error('useMenu must be used within a Menu');
  }
  return context;
}

Menu.Button = function MenuButton({ children }) {
  const { isOpen, setIsOpen } = useMenu();
  
  return (
    &lt;button onClick={() => setIsOpen(!isOpen)}&gt;
      {children} {isOpen ? '▲' : '▼'}
    &lt;/button&gt;
  );
};

Menu.List = function MenuList({ children }) {
  const { isOpen } = useMenu();
  
  return isOpen ? &lt;ul className="menu-list"&gt;{children}&lt;/ul&gt; : null;
};

Menu.Item = function MenuItem({ children, onClick }) {
  const { setIsOpen } = useMenu();
  
  const handleClick = () => {
    onClick?.();
    setIsOpen(false);
  };
  
  return (
    &lt;li onClick={handleClick}&gt;
      {children}
    &lt;/li&gt;
  );
};

// Usage
function DropdownMenu() {
  return (
    &lt;Menu&gt;
      &lt;Menu.Button&gt;Options&lt;/Menu.Button&gt;
      &lt;Menu.List&gt;
        &lt;Menu.Item onClick={() => console.log('Edit')}&gt;Edit&lt;/Menu.Item&gt;
        &lt;Menu.Item onClick={() => console.log('Delete')}&gt;Delete&lt;/Menu.Item&gt;
        &lt;Menu.Item onClick={() => console.log('Share')}&gt;Share&lt;/Menu.Item&gt;
      &lt;/Menu.List&gt;
    &lt;/Menu&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Render Props Pattern</h5>
                    <p>Render props is a technique for sharing code between components using a prop whose value is a function.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Mouse tracker with render prop
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  const handleMouseMove = (event) => {
    setPosition({
      x: event.clientX,
      y: event.clientY
    });
  };
  
  return (
    &lt;div onMouseMove={handleMouseMove} style={{ height: '100vh' }}&gt;
      {render(position)}
    &lt;/div&gt;
  );
}

// Usage
function App() {
  return (
    &lt;MouseTracker
      render={({ x, y }) => (
        &lt;h1&gt;
          Mouse position: ({x}, {y})
        &lt;/h1&gt;
      )}
    /&gt;
  );
}

// Using children as render prop
function MouseTracker({ children }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  const handleMouseMove = (event) => {
    setPosition({
      x: event.clientX,
      y: event.clientY
    });
  };
  
  return (
    &lt;div onMouseMove={handleMouseMove} style={{ height: '100vh' }}&gt;
      {children(position)}
    &lt;/div&gt;
  );
}

// Usage
function App() {
  return (
    &lt;MouseTracker&gt;
      {({ x, y }) => (
        &lt;h1&gt;
          Mouse position: ({x}, {y})
        &lt;/h1&gt;
      )}
    &lt;/MouseTracker&gt;
  );
}

// More complex example: Data provider
function DataProvider({ url, render }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network response was not ok');
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [url]);
  
  return render({ data, loading, error });
}

// Usage
function UserList() {
  return (
    &lt;DataProvider
      url="/api/users"
      render={({ data, loading, error }) =&gt; {
        if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
        if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
        if (!data) return &lt;div&gt;No data&lt;/div&gt;;
        
        return (
          &lt;ul&gt;
            {data.map(user => (
              &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
            ))}
          &lt;/ul&gt;
        );
      }}
    /&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Higher-Order Components (HOC)</h5>
                    <p>HOCs are functions that take a component and return a new component with additional props or behavior.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Simple HOC for adding props
function withExtraProps(Component) {
  return function WithExtraProps(props) {
    const extraProps = {
      timestamp: new Date().toISOString(),
      version: '1.0.0'
    };
    
    return &lt;Component {...props} {...extraProps} /&gt;;
  };
}

// HOC for loading state
function withLoading(Component) {
  return function WithLoading({ isLoading, ...props }) {
    if (isLoading) {
      return &lt;div className="loading-spinner"&gt;Loading...&lt;/div&gt;;
    }
    return &lt;Component {...props} /&gt;;
  };
}

// HOC for error handling
function withErrorBoundary(Component) {
  return class WithErrorBoundary extends React.Component {
    constructor(props) {
      super(props);
      this.state = { hasError: false, error: null };
    }
    
    static getDerivedStateFromError(error) {
      return { hasError: true, error };
    }
    
    componentDidCatch(error, errorInfo) {
      console.error('Error in component:', error, errorInfo);
    }
    
    render() {
      if (this.state.hasError) {
        return (
          &lt;div className="error-boundary"&gt;
            &lt;h2&gt;Something went wrong.&lt;/h2&gt;
            &lt;p&gt;{this.state.error?.message}&lt;/p&gt;
          &lt;/div&gt;
        );
      }
      
      return &lt;Component {...this.props} /&gt;;
    }
  };
}

// HOC for authentication
function withAuth(Component) {
  return function WithAuth({ isAuthenticated, ...props }) {
    if (!isAuthenticated) {
      return &lt;div&gt;Please log in to view this content.&lt;/div&gt;;
    }
    return &lt;Component {...props} /&gt;;
  };
}

// Combining HOCs
function enhance(Component) {
  return withErrorBoundary(
    withAuth(
      withLoading(Component)
    )
  );
}

// Usage
const EnhancedUserProfile = enhance(UserProfile);

function UserProfile({ user }) {
  return (
    &lt;div&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// HOC with configuration
function withLogger(Component, options = {}) {
  const { logProps = false, logRender = false } = options;
  
  return function WithLogger(props) {
    if (logProps) {
      console.log('Props:', props);
    }
    
    if (logRender) {
      console.log('Rendering:', Component.name);
    }
    
    return &lt;Component {...props} /&gt;;
  };
}

// Usage
const LoggedComponent = withLogger(MyComponent, {
  logProps: true,
  logRender: true
});</code></pre>
                    {% endraw %}

                    <h5>Custom Hooks Pattern</h5>
                    <p>Custom hooks allow you to extract component logic into reusable functions.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Hook for managing window size
function useWindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return windowSize;
}

// Hook for managing online/offline status
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  return isOnline;
}

// Hook for managing local storage with sync
function useStorageSync(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  const setValue = (value) => {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  };
  
  // Sync with storage changes from other tabs
  useEffect(() => {
    const handleStorageChange = (e) => {
      if (e.key === key) {
        setStoredValue(e.newValue ? JSON.parse(e.newValue) : initialValue);
      }
    };
    
    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, [key, initialValue]);
  
  return [storedValue, setValue];
}

// Hook for debouncing values
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// Hook for async operations
function useAsync(asyncFunction, dependencies = []) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  const execute = useCallback(async (...args) => {
    try {
      setLoading(true);
      setError(null);
      const result = await asyncFunction(...args);
      setData(result);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }, [asyncFunction]);
  
  useEffect(() => {
    execute();
  }, dependencies);
  
  return { data, loading, error, execute };
}

// Usage examples
function ResponsiveComponent() {
  const { width, height } = useWindowSize();
  
  return (
    &lt;div&gt;
      &lt;p&gt;Window width: {width}px&lt;/p&gt;
      &lt;p&gt;Window height: {height}px&lt;/p&gt;
      {width &lt; 768 ? &lt;MobileView /&gt; : &lt;DesktopView /&gt;}
    &lt;/div&gt;
  );
}

function OnlineStatusIndicator() {
  const isOnline = useOnlineStatus();
  
  return (
    &lt;div className={`status ${isOnline ? 'online' : 'offline'}`}&gt;
      {isOnline ? '🟢 Online' : '🔴 Offline'}
    &lt;/div&gt;
  );
}

function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  
  const { data, loading, error } = useAsync(
    async (term) => {
      if (!term) return [];
      const response = await fetch(`/api/search?q=${term}`);
      return response.json();
    },
    [debouncedSearchTerm]
  );
  
  return (
    &lt;div&gt;
      &lt;input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      /&gt;
      {loading && &lt;div&gt;Searching...&lt;/div&gt;}
      {error && &lt;div&gt;Error: {error.message}&lt;/div&gt;}
      {data && (
        &lt;ul&gt;
          {data.map(item => (
            &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>State Reducer Pattern</h5>
                    <p>Using useReducer for complex state logic makes state updates more predictable and easier to test.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Complex form state with reducer
const formReducer = (state, action) => {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        [action.field]: action.value,
        errors: {
          ...state.errors,
          [action.field]: null
        }
      };
    
    case 'SET_ERROR':
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.field]: action.error
        }
      };
    
    case 'SET_ERRORS':
      return {
        ...state,
        errors: action.errors
      };
    
    case 'RESET_FORM':
      return action.initialState;
    
    case 'SUBMIT_START':
      return {
        ...state,
        isSubmitting: true,
        submitError: null
      };
    
    case 'SUBMIT_SUCCESS':
      return {
        ...state,
        isSubmitting: false,
        submitSuccess: true
      };
    
    case 'SUBMIT_ERROR':
      return {
        ...state,
        isSubmitting: false,
        submitError: action.error
      };
    
    default:
      return state;
  }
};

function useForm(initialState, validationSchema, onSubmit) {
  const [state, dispatch] = useReducer(formReducer, initialState);
  
  const setField = (field, value) => {
    dispatch({ type: 'SET_FIELD', field, value });
    
    // Validate field if schema provided
    if (validationSchema?.[field]) {
      const error = validateField(value, validationSchema[field]);
      if (error) {
        dispatch({ type: 'SET_ERROR', field, error });
      }
    }
  };
  
  const setError = (field, error) => {
    dispatch({ type: 'SET_ERROR', field, error });
  };
  
  const setErrors = (errors) => {
    dispatch({ type: 'SET_ERRORS', errors });
  };
  
  const validateForm = () => {
    if (!validationSchema) return true;
    
    const errors = {};
    let isValid = true;
    
    Object.keys(validationSchema).forEach(field => {
      const error = validateField(state[field], validationSchema[field]);
      if (error) {
        errors[field] = error;
        isValid = false;
      }
    });
    
    setErrors(errors);
    return isValid;
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) return;
    
    dispatch({ type: 'SUBMIT_START' });
    
    try {
      await onSubmit(state);
      dispatch({ type: 'SUBMIT_SUCCESS' });
    } catch (error) {
      dispatch({ type: 'SUBMIT_ERROR', error: error.message });
    }
  };
  
  const resetForm = () => {
    dispatch({ type: 'RESET_FORM', initialState });
  };
  
  return {
    ...state,
    setField,
    setError,
    setErrors,
    handleSubmit,
    resetForm,
    validateForm
  };
}

// Usage
function RegistrationForm() {
  const initialState = {
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    errors: {},
    isSubmitting: false,
    submitSuccess: false,
    submitError: null
  };
  
  const validationSchema = {
    username: {
      required: true,
      minLength: 3
    },
    email: {
      required: true,
      pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    },
    password: {
      required: true,
      minLength: 6
    },
    confirmPassword: {
      required: true,
      validate: (value, allValues) => value === allValues.password
    }
  };
  
  const {
    values,
    errors,
    isSubmitting,
    submitSuccess,
    submitError,
    setField,
    handleSubmit,
    resetForm
  } = useForm(initialState, validationSchema, async (values) => {
    const response = await fetch('/api/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(values)
    });
    
    if (!response.ok) throw new Error('Registration failed');
    
    return response.json();
  });
  
  if (submitSuccess) {
    return (
      &lt;div&gt;
        &lt;h2&gt;Registration successful!&lt;/h2&gt;
        &lt;button onClick={resetForm}&gt;Register another user&lt;/button&gt;
      &lt;/div&gt;
    );
  }
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label&gt;Username:&lt;/label&gt;
        &lt;input
          value={values.username}
          onChange={(e) => setField('username', e.target.value)}
        /&gt;
        {errors.username && &lt;span className="error"&gt;{errors.username}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          value={values.email}
          onChange={(e) => setField('email', e.target.value)}
        /&gt;
        {errors.email && &lt;span className="error"&gt;{errors.email}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;Password:&lt;/label&gt;
        &lt;input
          type="password"
          value={values.password}
          onChange={(e) => setField('password', e.target.value)}
        /&gt;
        {errors.password && &lt;span className="error"&gt;{errors.password}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;Confirm Password:&lt;/label&gt;
        &lt;input
          type="password"
          value={values.confirmPassword}
          onChange={(e) => setField('confirmPassword', e.target.value)}
        /&gt;
        {errors.confirmPassword && &lt;span className="error"&gt;{errors.confirmPassword}&lt;/span&gt;}
      &lt;/div&gt;
      
      {submitError && &lt;div className="error"&gt;{submitError}&lt;/div&gt;}
      
      &lt;button type="submit" disabled={isSubmitting}&gt;
        {isSubmitting ? 'Registering...' : 'Register'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Provider Pattern</h5>
                    <p>The Provider pattern uses React's Context API to provide values to a tree of components.</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Theme provider
const ThemeContext = createContext();

function ThemeProvider({ children, theme = 'light' }) {
  const [currentTheme, setCurrentTheme] = useState(theme);
  
  const toggleTheme = () => {
    setCurrentTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const themeValues = useMemo(() => ({
    theme: currentTheme,
    toggleTheme,
    colors: currentTheme === 'light' ? {
      background: '#ffffff',
      text: '#000000',
      primary: '#007bff'
    } : {
      background: '#1a1a1a',
      text: '#ffffff',
      primary: '#0d6efd'
    }
  }), [currentTheme]);
  
  return (
    &lt;ThemeContext.Provider value={themeValues}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}

// Auth provider
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check for existing session
    const token = localStorage.getItem('token');
    if (token) {
      // Validate token and get user info
      validateToken(token).then(userData => {
        setUser(userData);
        setLoading(false);
      }).catch(() => {
        localStorage.removeItem('token');
        setLoading(false);
      });
    } else {
      setLoading(false);
    }
  }, []);
  
  const login = async (credentials) => {
    const response = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials)
    });
    
    if (!response.ok) throw new Error('Login failed');
    
    const { token, user } = await response.json();
    localStorage.setItem('token', token);
    setUser(user);
  };
  
  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };
  
  const value = {
    user,
    login,
    logout,
    isAuthenticated: !!user,
    loading
  };
  
  return (
    &lt;AuthContext.Provider value={value}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
}

function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// Combined providers
function AppProviders({ children }) {
  return (
    &lt;AuthProvider&gt;
      &lt;ThemeProvider&gt;
        &lt;Router&gt;
          {children}
        &lt;/Router&gt;
      &lt;/ThemeProvider&gt;
    &lt;/AuthProvider&gt;
  );
}

// Usage
function App() {
  return (
    &lt;AppProviders&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/profile" element={&lt;ProtectedRoute&gt;&lt;Profile /&gt;&lt;/ProtectedRoute&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/AppProviders&gt;
  );
}

function ProtectedRoute({ children }) {
  const { isAuthenticated } = useAuth();
  const location = useLocation();
  
  if (!isAuthenticated) {
    return &lt;Navigate to="/login" state={{ from: location }} replace /&gt;;
  }
  
  return children;
}</code></pre>
                    {% endraw %}
                </div>
            </div>

            <!-- Module 16: Error Boundaries -->
            <div class="content-card" id="module16">
                <div class="card-header">
                    <i class="fas fa-bug"></i> Module 16: Error Boundaries
                </div>
                <div class="card-body">
                    <h5>Understanding Error Boundaries</h5>
                    <p>Error boundaries are React components that catch JavaScript errors in their child component tree, log those errors, and display a fallback UI instead of the crashed component tree. They prevent the entire app from crashing due to errors in individual components.</p>

                    <h5>Class Component Error Boundaries</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false, 
      error: null, 
      errorInfo: null 
    };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log the error to an error reporting service
    console.error('Error caught by boundary:', error, errorInfo);
    
    // You can also send the error to a service like Sentry
    // Sentry.captureException(error, { contexts: { react: { componentStack: errorInfo.componentStack } } });
    
    this.setState({
      error: error,
      errorInfo: errorInfo
    });
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return (
        &lt;div className="error-boundary"&gt;
          &lt;h2&gt;Something went wrong.&lt;/h2&gt;
          &lt;details style={{ whiteSpace: 'pre-wrap' }}&gt;
            &lt;summary&gt;Error details&lt;/summary&gt;
            {this.state.error && this.state.error.toString()}
            &lt;br /&gt;
            {this.state.errorInfo.componentStack}
          &lt;/details&gt;
          &lt;button onClick={() => this.setState({ hasError: false, error: null, errorInfo: null })}&gt;
            Try again
          &lt;/button&gt;
        &lt;/div&gt;
      );
    }

    return this.props.children;
  }
}

// Usage
function App() {
  return (
    &lt;ErrorBoundary&gt;
      &lt;MyComponent /&gt;
    &lt;/ErrorBoundary&gt;
  );
}

// Component that throws an error
function BuggyComponent() {
  const [shouldThrow, setShouldThrow] = useState(false);
  
  if (shouldThrow) {
    throw new Error('I crashed!');
  }
  
  return (
    &lt;div&gt;
      &lt;p&gt;I'm working fine!&lt;/p&gt;
      &lt;button onClick={() => setShouldThrow(true)}&gt;
        Break me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Functional Error Boundary Pattern</h5>
                    <p>While React doesn't support functional error boundaries directly, we can create a pattern using hooks:</p>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React, { useState, useEffect } from 'react';

function useErrorHandler() {
  const [error, setError] = useState(null);
  
  const resetError = () => setError(null);
  
  const catchError = (error) => {
    setError(error);
  };
  
  useEffect(() => {
    if (error) {
      throw error;
    }
  }, [error]);
  
  return { catchError, resetError };
}

function ErrorBoundary({ children, fallback }) {
  const { catchError, resetError } = useErrorHandler();
  
  return (
    &lt;div&gt;
      {children}
      {error && (
        &lt;div className="error-boundary"&gt;
          {fallback || &lt;h2&gt;Something went wrong.&lt;/h2&gt;}
          &lt;button onClick={resetError}&gt;Try again&lt;/button&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}

// Usage
function MyComponent() {
  const { catchError } = useErrorHandler();
  
  const handleClick = () => {
    try {
      // Code that might throw an error
      throw new Error('Something went wrong!');
    } catch (error) {
      catchError(error);
    }
  };
  
  return (
    &lt;div&gt;
      &lt;button onClick={handleClick}&gt;Trigger Error&lt;/button&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;ErrorBoundary fallback={&lt;CustomErrorFallback /&gt;}&gt;
      &lt;MyComponent /&gt;
    &lt;/ErrorBoundary&gt;
  );
}

function CustomErrorFallback() {
  return (
    &lt;div className="custom-error"&gt;
      &lt;h2&gt;Oops! Something went wrong&lt;/h2&gt;
      &lt;p&gt;We're sorry, but something unexpected happened.&lt;/p&gt;
      &lt;button onClick={() => window.location.reload()}&gt;
        Refresh Page
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Advanced Error Boundary with Error Reporting</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false, 
      error: null, 
      errorInfo: null,
      errorId: null
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    const errorId = Date.now().toString();
    
    // Generate error report
    const errorReport = {
      id: errorId,
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      },
      componentStack: errorInfo.componentStack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    // Log to console
    console.error('Error caught by boundary:', errorReport);
    
    // Send to error reporting service
    this.reportError(errorReport);
    
    this.setState({
      error: error,
      errorInfo: errorInfo,
      errorId: errorId
    });
  }

  reportError = async (errorReport) => {
    try {
      // Send to your error reporting service
      await fetch('/api/errors', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(errorReport)
      });
    } catch (reportingError) {
      console.error('Failed to report error:', reportingError);
    }
  }

  handleRetry = () => {
    this.setState({ 
      hasError: false, 
      error: null, 
      errorInfo: null,
      errorId: null 
    });
  }

  render() {
    if (this.state.hasError) {
      const isDevelopment = process.env.NODE_ENV === 'development';
      
      return (
        &lt;div className="error-boundary"&gt;
          &lt;div className="error-content"&gt;
            &lt;h2&gt;Something went wrong&lt;/h2&gt;
            &lt;p&gt;We're sorry, but something unexpected happened.&lt;/p&gt;
            
            {this.state.errorId && (
              &lt;p className="error-id"&gt;Error ID: {this.state.errorId}&lt;/p&gt;
            )}
            
            &lt;div className="error-actions"&gt;
              &lt;button onClick={this.handleRetry} className="retry-button"&gt;
                Try Again
              &lt;/button&gt;
              &lt;button onClick={() => window.location.reload()} className="reload-button"&gt;
                Reload Page
              &lt;/button&gt;
            &lt;/div&gt;
            
            {isDevelopment && (
              &lt;details className="error-details"&gt;
                &lt;summary&gt;Error Details (Development Only)&lt;/summary&gt;
                &lt;div className="error-info"&gt;
                  &lt;h4&gt;Error:&lt;/h4&gt;
                  &lt;pre&gt;{this.state.error && this.state.error.toString()}&lt;/pre&gt;
                  
                  &lt;h4&gt;Component Stack:&lt;/h4&gt;
                  &lt;pre&gt;{this.state.errorInfo.componentStack}&lt;/pre&gt;
                &lt;/div&gt;
              &lt;/details&gt;
            )}
          &lt;/div&gt;
        &lt;/div&gt;
      );
    }

    return this.props.children;
  }
}

// Error boundary with different fallbacks for different error types
class SmartErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false, 
      error: null, 
      errorType: null 
    };
  }

  static getDerivedStateFromError(error) {
    let errorType = 'unknown';
    
    if (error.name === 'ChunkLoadError') {
      errorType = 'chunk-load';
    } else if (error.message.includes('Network')) {
      errorType = 'network';
    } else if (error.message.includes('Permission')) {
      errorType = 'permission';
    }
    
    return { 
      hasError: true, 
      errorType 
    };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({ error });
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      const { fallbacks } = this.props;
      const fallback = fallbacks?.[this.state.errorType] || fallbacks?.default || &lt;DefaultErrorFallback /&gt;;
      
      return React.cloneElement(fallback, {
        error: this.state.error,
        errorType: this.state.errorType,
        onRetry: () => this.setState({ hasError: false, error: null, errorType: null })
      });
    }

    return this.props.children;
  }
}

// Usage with custom fallbacks
function App() {
  const customFallbacks = {
    'chunk-load': &lt;ChunkLoadErrorFallback /&gt;,
    'network': &lt;NetworkErrorFallback /&gt;,
    'permission': &lt;PermissionErrorFallback /&gt;,
    'default': &lt;DefaultErrorFallback /&gt;
  };
  
  return (
    &lt;SmartErrorBoundary fallbacks={customFallbacks}&gt;
      &lt;MyApp /&gt;
    &lt;/SmartErrorBoundary&gt;
  );
}

function ChunkLoadErrorFallback({ onRetry }) {
  return (
    &lt;div className="error-boundary"&gt;
      &lt;h2&gt;Failed to load application&lt;/h2&gt;
      &lt;p&gt;Please check your internet connection and try again.&lt;/p&gt;
      &lt;button onClick={onRetry}&gt;Retry&lt;/button&gt;
    &lt;/div&gt;
  );
}

function NetworkErrorFallback({ onRetry }) {
  return (
    &lt;div className="error-boundary"&gt;
      &lt;h2&gt;Network Error&lt;/h2&gt;
      &lt;p&gt;Unable to connect to the server. Please check your connection.&lt;/p&gt;
      &lt;button onClick={onRetry}&gt;Retry&lt;/button&gt;
    &lt;/div&gt;
  );
}

function PermissionErrorFallback({ onRetry }) {
  return (
    &lt;div className="error-boundary"&gt;
      &lt;h2&gt;Permission Denied&lt;/h2&gt;
      &lt;p&gt;You don't have permission to access this resource.&lt;/p&gt;
      &lt;button onClick={() => window.location.href = '/login'}&gt;
        Login
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

function DefaultErrorFallback({ onRetry }) {
  return (
    &lt;div className="error-boundary"&gt;
      &lt;h2&gt;Something went wrong&lt;/h2&gt;
      &lt;p&gt;An unexpected error occurred. Please try again.&lt;/p&gt;
      &lt;button onClick={onRetry}&gt;Retry&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Error Boundary Best Practices</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// 1. Place error boundaries strategically
function App() {
  return (
    &lt;div&gt;
      {/* Top-level error boundary for critical errors */}
      &lt;ErrorBoundary&gt;
        &lt;Header /&gt;
        
        {/* Error boundary for main content */}
        &lt;ErrorBoundary&gt;
          &lt;MainContent /&gt;
        &lt;/ErrorBoundary&gt;
        
        {/* Error boundary for less critical sections */}
        &lt;ErrorBoundary&gt;
          &lt;Sidebar /&gt;
          &lt;Footer /&gt;
        &lt;/ErrorBoundary&gt;
      &lt;/ErrorBoundary&gt;
    &lt;/div&gt;
  );
}

// 2. Create reusable error boundary components
class FormErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Form error:', error, errorInfo);
    this.setState({ error });
  }

  render() {
    if (this.state.hasError) {
      return (
        &lt;div className="form-error"&gt;
          &lt;p&gt;There was an error with the form. Please try again.&lt;/p&gt;
          &lt;button onClick={() => this.setState({ hasError: false, error: null })}&gt;
            Retry
          &lt;/button&gt;
        &lt;/div&gt;
      );
    }

    return this.props.children;
  }
}

// Usage
function ContactForm() {
  return (
    &lt;FormErrorBoundary&gt;
      &lt;form&gt;
        {/* Form fields */}
      &lt;/form&gt;
    &lt;/FormErrorBoundary&gt;
  );
}

// 3. Error boundary for async operations
class AsyncErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Handle async errors differently
    if (error.name === 'ChunkLoadError') {
      // Handle code splitting errors
      console.error('Chunk load error:', error);
    } else {
      console.error('Async error:', error, errorInfo);
    }
    
    this.setState({ error });
  }

  render() {
    if (this.state.hasError) {
      return (
        &lt;div className="async-error"&gt;
          &lt;h2&gt;Loading Error&lt;/h2&gt;
          &lt;p&gt;Failed to load content. Please refresh the page.&lt;/p&gt;
        &lt;/div&gt;
      );
    }

    return this.props.children;
  }
}

// 4. Error boundary with recovery mechanisms
class RecoverableErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false, 
      error: null,
      retryCount: 0
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught:', error, errorInfo);
    this.setState({ error });
  }

  handleRetry = () => {
    const { retryCount } = this.state;
    const { maxRetries = 3 } = this.props;
    
    if (retryCount &lt; maxRetries) {
      this.setState(prevState => ({
        hasError: false,
        error: null,
        retryCount: prevState.retryCount + 1
      }));
    } else {
      // Max retries reached, show different message
      console.error('Max retries reached');
    }
  }

  render() {
    if (this.state.hasError) {
      const { retryCount } = this.state;
      const { maxRetries = 3 } = this.props;
      
      return (
        &lt;div className="recoverable-error"&gt;
          &lt;h2&gt;Something went wrong&lt;/h2&gt;
          &lt;p&gt;
            {retryCount &lt; maxRetries 
              ? `Attempt ${retryCount + 1} of ${maxRetries}`
              : 'Maximum retry attempts reached'
            }
          &lt;/p&gt;
          
          {retryCount &lt; maxRetries && (
            &lt;button onClick={this.handleRetry}&gt;
              Retry ({maxRetries - retryCount} attempts left)
            &lt;/button&gt;
          )}
          
          {retryCount >= maxRetries && (
            &lt;button onClick={() => window.location.reload()}&gt;
              Reload Page
            &lt;/button&gt;
          )}
        &lt;/div&gt;
      );
    }

    return this.props.children;
  }
}

// 5. Error boundary for specific components
function withErrorBoundary(WrappedComponent, fallback) {
  return class WithErrorBoundary extends React.Component {
    render() {
      return (
        &lt;ErrorBoundary fallback={fallback}&gt;
          &lt;WrappedComponent {...this.props} /&gt;
        &lt;/ErrorBoundary&gt;
      );
    }
  };
}

// Usage
const SafeUserProfile = withErrorBoundary(UserProfile, &lt;UserProfileErrorFallback /&gt;);

// 6. Error boundary HOC for multiple components
function withErrorBoundary(options = {}) {
  return function WrappedComponent {
    return class extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true };
      }

      componentDidCatch(error, errorInfo) {
        options.onError?.(error, errorInfo);
        this.setState({ error });
      }

      render() {
        if (this.state.hasError) {
          return options.fallback || &lt;DefaultErrorFallback error={this.state.error} /&gt;;
        }

        return &lt;WrappedComponent {...this.props} /&gt;;
      }
    };
  };
}

// Usage
const SafeComponent = withErrorBoundary({
  fallback: &lt;CustomErrorFallback /&gt;,
  onError: (error, errorInfo) => {
    console.error('Component error:', error, errorInfo);
    // Send to error reporting service
  }
})(MyComponent);</code></pre>
                    {% endraw %}

                    <h5>Error Boundary Limitations</h5>
                    <div class="data-type-section">
                        <h6>Does Not Catch Errors In</h6>
                        <ul>
                            <li>Event handlers</li>
                            <li>Asynchronous code (setTimeout, requestAnimationFrame)</li>
                            <li>Server-side rendering</li>
                            <li>Errors thrown in the error boundary itself</li>
                        </ul>
                        
                        <h6>Workarounds</h6>
                        <ul>
                            <li>Use try-catch in event handlers</li>
                            <li>Use error boundaries with async/await</li>
                            <li>Wrap error-prone code in separate components</li>
                        </ul>
                    </div>

                    <h5>Testing Error Boundaries</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';

// Component that throws an error
function BuggyComponent({ shouldThrow }) {
  if (shouldThrow) {
    throw new Error('Test error');
  }
  return &lt;div&gt;No error&lt;/div&gt;;
}

// Test file
describe('ErrorBoundary', () => {
  // Suppress console.error for these tests
  const originalError = console.error;
  beforeEach(() => {
    console.error = jest.fn();
  });
  
  afterEach(() => {
    console.error = originalError;
  });

  test('renders children when there is no error', () => {
    render(
      &lt;ErrorBoundary&gt;
        &lt;BuggyComponent shouldThrow={false} /&gt;
      &lt;/ErrorBoundary&gt;
    );
    
    expect(screen.getByText('No error')).toBeInTheDocument();
    expect(screen.queryByText('Something went wrong')).not.toBeInTheDocument();
  });

  test('catches errors and renders fallback UI', () => {
    render(
      &lt;ErrorBoundary&gt;
        &lt;BuggyComponent shouldThrow={true} /&gt;
      &lt;/ErrorBoundary&gt;
    );
    
    expect(screen.queryByText('No error')).not.toBeInTheDocument();
    expect(screen.getByText('Something went wrong')).toBeInTheDocument();
  });

  test('calls componentDidCatch when error occurs', () => {
    const MockErrorBoundary = class extends ErrorBoundary {
      componentDidCatch(error, errorInfo) {
        super.componentDidCatch(error, errorInfo);
        this.props.onError?.(error, errorInfo);
      }
    };
    
    const onError = jest.fn();
    
    render(
      &lt;MockErrorBoundary onError={onError}&gt;
        &lt;BuggyComponent shouldThrow={true} /&gt;
      &lt;/MockErrorBoundary&gt;
    );
    
    expect(onError).toHaveBeenCalled();
    expect(onError.mock.calls[0][0]).toBeInstanceOf(Error);
    expect(onError.mock.calls[0][1]).toHaveProperty('componentStack');
  });

  test('can recover from error', () => {
    const { rerender } = render(
      &lt;ErrorBoundary&gt;
        &lt;BuggyComponent shouldThrow={true} /&gt;
      &lt;/ErrorBoundary&gt;
    );
    
    expect(screen.getByText('Something went wrong')).toBeInTheDocument();
    
    rerender(
      &lt;ErrorBoundary&gt;
        &lt;BuggyComponent shouldThrow={false} /&gt;
      &lt;/ErrorBoundary&gt;
    );
    
    expect(screen.getByText('No error')).toBeInTheDocument();
    expect(screen.queryByText('Something went wrong')).not.toBeInTheDocument();
  });
});</code></pre>
                    {% endraw %}
                </div>
            </div>

            <!-- Module 17: Portals -->
            <div class="content-card" id="module17">
                <div class="card-header">
                    <i class="fas fa-door-open"></i> Module 17: Portals
                </div>
                <div class="card-body">
                    <h5>Understanding React Portals</h5>
                    <p>Portals provide a way to render children into a DOM node that exists outside the hierarchy of the parent component. This is useful for modals, tooltips, popovers, and other UI elements that need to break out of their container's visual constraints.</p>

                    <h5>Basic Portal Usage</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React, { createPortal } from 'react';
import ReactDOM from 'react-dom';

function Modal({ children, isOpen, onClose }) {
  if (!isOpen) return null;
  
  return createPortal(
    &lt;div className="modal-overlay"&gt;
      &lt;div className="modal"&gt;
        &lt;button className="modal-close" onClick={onClose}&gt;
          ×
        &lt;/button&gt;
        &lt;div className="modal-content"&gt;
          {children}
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;,
    document.getElementById('modal-root')
  );
}

// Usage
function App() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  
  return (
    &lt;div&gt;
      &lt;h1&gt;My App&lt;/h1&gt;
      &lt;button onClick={() => setIsModalOpen(true)}&gt;
        Open Modal
      &lt;/button&gt;
      
      &lt;Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}&gt;
        &lt;h2&gt;Modal Content&lt;/h2&gt;
        &lt;p&gt;This is rendered outside the main app DOM!&lt;/p&gt;
      &lt;/Modal&gt;
    &lt;/div&gt;
  );
}

// HTML structure needed
// &lt;div id="root"&gt;&lt;/div&gt;
// &lt;div id="modal-root"&gt;&lt;/div&gt;</code></pre>
                    {% endraw %}

                    <h5>Advanced Modal with Portal</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React, { createPortal, useEffect } from 'react';
import ReactDOM from 'react-dom';

function Modal({ 
  children, 
  isOpen, 
  onClose, 
  title, 
  size = 'medium',
  closeOnOverlayClick = true,
  closeOnEscape = true 
}) {
  useEffect(() => {
    const handleEscape = (e) => {
      if (e.key === 'Escape' && closeOnEscape) {
        onClose();
      }
    };
    
    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }
    
    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose, closeOnEscape]);
  
  if (!isOpen) return null;
  
  const handleOverlayClick = (e) => {
    if (e.target === e.currentTarget && closeOnOverlayClick) {
      onClose();
    }
  };
  
  const modalSizeClass = `modal-${size}`;
  
  return createPortal(
    &lt;div className="modal-overlay" onClick={handleOverlayClick}&gt;
      &lt;div 
        className={`modal ${modalSizeClass}`}
        onClick={(e) => e.stopPropagation()}
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
      &gt;
        &lt;div className="modal-header"&gt;
          &lt;h2 id="modal-title"&gt;{title}&lt;/h2&gt;
          &lt;button 
            className="modal-close"
            onClick={onClose}
            aria-label="Close modal"
          &gt;
            ×
          &lt;/button&gt;
        &lt;/div&gt;
        
        &lt;div className="modal-body"&gt;
          {children}
        &lt;/div&gt;
        
        &lt;div className="modal-footer"&gt;
          &lt;button className="btn btn-secondary" onClick={onClose}&gt;
            Cancel
          &lt;/button&gt;
          &lt;button className="btn btn-primary" onClick={onClose}&gt;
            Save
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;,
    document.getElementById('modal-root')
  );
}

// Usage examples
function ConfirmModal({ isOpen, onClose, onConfirm, message }) {
  const handleConfirm = () => {
    onConfirm();
    onClose();
  };
  
  return (
    &lt;Modal isOpen={isOpen} onClose={onClose} title="Confirm" size="small"&gt;
      &lt;p&gt;{message}&lt;/p&gt;
      &lt;div className="modal-footer"&gt;
        &lt;button className="btn btn-secondary" onClick={onClose}&gt;
          Cancel
        &lt;/button&gt;
        &lt;button className="btn btn-danger" onClick={handleConfirm}&gt;
          Confirm
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/Modal&gt;
  );
}

function ImageModal({ isOpen, onClose, image }) {
  return (
    &lt;Modal isOpen={isOpen} onClose={onClose} title={image.title} size="large"&gt;
      &lt;img 
        src={image.url} 
        alt={image.title} 
        style={{ maxWidth: '100%', height: 'auto' }}
      /&gt;
      &lt;p&gt;{image.description}&lt;/p&gt;
    &lt;/Modal&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Tooltip Portal</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React, { useState, useRef, useEffect } from 'react';
import { createPortal } from 'react-dom';

function Tooltip({ text, children, placement = 'top' }) {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const containerRef = useRef(null);
  const tooltipRef = useRef(null);
  
  const showTooltip = () => {
    if (containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const tooltipRect = tooltipRef.current?.getBoundingClientRect();
      
      let top, left;
      
      switch (placement) {
        case 'top':
          top = rect.top - (tooltipRect?.height || 0) - 10;
          left = rect.left + rect.width / 2 - (tooltipRect?.width || 0) / 2;
          break;
        case 'bottom':
          top = rect.bottom + 10;
          left = rect.left + rect.width / 2 - (tooltipRect?.width || 0) / 2;
          break;
        case 'left':
          top = rect.top + rect.height / 2 - (tooltipRect?.height || 0) / 2;
          left = rect.left - (tooltipRect?.width || 0) - 10;
          break;
        case 'right':
          top = rect.top + rect.height / 2 - (tooltipRect?.height || 0) / 2;
          left = rect.right + 10;
          break;
      }
      
      setPosition({ top, left });
      setIsVisible(true);
    }
  };
  
  const hideTooltip = () => {
    setIsVisible(false);
  };
  
  // Adjust position if tooltip goes out of viewport
  useEffect(() => {
    if (isVisible && tooltipRef.current) {
      const tooltipRect = tooltipRef.current.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      let adjustedPosition = { ...position };
      
      // Adjust horizontal position
      if (position.left &lt; 0) {
        adjustedPosition.left = 10;
      } else if (position.left + tooltipRect.width > viewportWidth) {
        adjustedPosition.left = viewportWidth - tooltipRect.width - 10;
      }
      
      // Adjust vertical position
      if (position.top &lt; 0) {
        adjustedPosition.top = 10;
      } else if (position.top + tooltipRect.height > viewportHeight) {
        adjustedPosition.top = viewportHeight - tooltipRect.height - 10;
      }
      
      setPosition(adjustedPosition);
    }
  }, [isVisible, position]);
  
  return (
    &lt;&gt;
      &lt;div
        ref={containerRef}
        onMouseEnter={showTooltip}
        onMouseLeave={hideTooltip}
        style={{ display: 'inline-block' }}
      &gt;
        {children}
      &lt;/div&gt;
      
      {isVisible && createPortal(
        &lt;div
          ref={tooltipRef}
          className="tooltip"
          style={{
            position: 'absolute',
            top: `${position.top}px`,
            left: `${position.left}px`,
            zIndex: 1000,
            backgroundColor: '#333',
            color: 'white',
            padding: '8px 12px',
            borderRadius: '4px',
            fontSize: '14px',
            whiteSpace: 'nowrap',
            pointerEvents: 'none'
          }}
        &gt;
          {text}
          &lt;div 
            className="tooltip-arrow"
            style={{
              position: 'absolute',
              width: 0,
              height: 0,
              borderStyle: 'solid',
              borderWidth: placement === 'top' || placement === 'bottom' ? '5px 5px 0 5px' : '5px 0 5px 5px',
              borderColor: placement === 'top' ? '#333 transparent transparent transparent' : 
                           placement === 'bottom' ? 'transparent transparent #333 transparent' :
                           placement === 'left' ? 'transparent #333 transparent transparent' :
                           'transparent transparent transparent #333',
              bottom: placement === 'top' ? '-5px' : 'auto',
              top: placement === 'bottom' ? '-5px' : 'auto',
              right: placement === 'left' ? '-5px' : 'auto',
              left: placement === 'right' ? '-5px' : 'auto'
            }}
          /&gt;
        &lt;/div&gt;,
        document.body
      )}
    &lt;/&gt;
  );
}

// Usage
function App() {
  return (
    &lt;div&gt;
      &lt;Tooltip text="This is a helpful tooltip"&gt;
        &lt;button&gt;Hover me&lt;/button&gt;
      &lt;/Tooltip&gt;
      
      &lt;Tooltip text="Tooltip on the right side" placement="right"&gt;
        &lt;input type="text" placeholder="Right tooltip" /&gt;
      &lt;/Tooltip&gt;
      
      &lt;Tooltip text="Tooltip on the bottom" placement="bottom"&gt;
        &lt;span&gt;Bottom tooltip&lt;/span&gt;
      &lt;/Tooltip&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Notification System with Portal</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React, { useState, useEffect, createPortal } from 'react';
import ReactDOM from 'react-dom';

let notificationId = 0;

function NotificationContainer() {
  const [notifications, setNotifications] = useState([]);
  
  const addNotification = (message, type = 'info', duration = 5000) => {
    const id = notificationId++;
    const notification = {
      id,
      message,
      type,
      duration,
      timestamp: Date.now()
    };
    
    setNotifications(prev => [...prev, notification]);
    
    // Auto remove after duration
    if (duration > 0) {
      setTimeout(() => {
        removeNotification(id);
      }, duration);
    }
  };
  
  const removeNotification = (id) => {
    setNotifications(prev => prev.filter(n => n.id !== id));
  };
  
  // Expose addNotification globally
  useEffect(() => {
    window.showNotification = addNotification;
    window.hideNotification = removeNotification;
    
    return () => {
      delete window.showNotification;
      delete window.hideNotification;
    };
  }, []);
  
  return createPortal(
    &lt;div className="notification-container"&gt;
      {notifications.map(notification => (
        &lt;NotificationItem
          key={notification.id}
          notification={notification}
          onClose={() => removeNotification(notification.id)}
        /&gt;
      ))}
    &lt;/div&gt;,
    document.getElementById('notification-root')
  );
}

function NotificationItem({ notification, onClose }) {
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    // Trigger entrance animation
    setIsVisible(true);
    
    // Trigger exit animation before removal
    const timer = setTimeout(() => {
      setIsVisible(false);
    }, notification.duration - 300); // Leave 300ms for exit animation
    
    return () => clearTimeout(timer);
  }, [notification.duration]);
  
  const getIcon = () => {
    switch (notification.type) {
      case 'success':
        return '✓';
      case 'error':
        return '✗';
      case 'warning':
        return '⚠';
      default:
        return 'ℹ';
    }
  };
  
  return (
    &lt;div 
      className={`notification notification-${notification.type} ${isVisible ? 'visible' : ''}`}
      onClick={onClose}
    &gt;
      &lt;div className="notification-icon"&gt;
        {getIcon()}
      &lt;/div&gt;
      &lt;div className="notification-content"&gt;
        {notification.message}
      &lt;/div&gt;
      &lt;button 
        className="notification-close"
        onClick={(e) => {
          e.stopPropagation();
          onClose();
        }}
      &gt;
        ×
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// Usage
function App() {
  const showSuccess = () => {
    window.showNotification('Operation completed successfully!', 'success');
  };
  
  const showError = () => {
    window.showNotification('An error occurred. Please try again.', 'error');
  };
  
  const showWarning = () => {
    window.showNotification('Please save your changes before leaving.', 'warning');
  };
  
  const showPersistent = () => {
    window.showNotification('This notification will stay until you close it.', 'info', 0);
  };
  
  return (
    &lt;div&gt;
      &lt;NotificationContainer /&gt;
      
      &lt;h1&gt;Notification Demo&lt;/h1&gt;
      
      &lt;div className="button-group"&gt;
        &lt;button onClick={showSuccess}&gt;Show Success&lt;/button&gt;
        &lt;button onClick={showError}&gt;Show Error&lt;/button&gt;
        &lt;button onClick={showWarning}&gt;Show Warning&lt;/button&gt;
        &lt;button onClick={showPersistent}&gt;Show Persistent&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Dropdown Menu with Portal</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React, { useState, useRef, useEffect } from 'react';
import { createPortal } from 'react-dom';

function Dropdown({ trigger, children, placement = 'bottom-left' }) {
  const [isOpen, setIsOpen] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const triggerRef = useRef(null);
  const dropdownRef = useRef(null);
  
  const toggleDropdown = () => {
    setIsOpen(!isOpen);
  };
  
  const closeDropdown = () => {
    setIsOpen(false);
  };
  
  // Calculate position when dropdown opens
  useEffect(() => {
    if (isOpen && triggerRef.current && dropdownRef.current) {
      const triggerRect = triggerRef.current.getBoundingClientRect();
      const dropdownRect = dropdownRef.current.getBoundingClientRect();
      
      let top, left;
      
      switch (placement) {
        case 'bottom-left':
          top = triggerRect.bottom + 5;
          left = triggerRect.left;
          break;
        case 'bottom-right':
          top = triggerRect.bottom + 5;
          left = triggerRect.right - dropdownRect.width;
          break;
        case 'top-left':
          top = triggerRect.top - dropdownRect.height - 5;
          left = triggerRect.left;
          break;
        case 'top-right':
          top = triggerRect.top - dropdownRect.height - 5;
          left = triggerRect.right - dropdownRect.width;
          break;
      }
      
      setPosition({ top, left });
    }
  }, [isOpen, placement]);
  
  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        isOpen && 
        dropdownRef.current && 
        !dropdownRef.current.contains(event.target) &&
        triggerRef.current && 
        !triggerRef.current.contains(event.target)
      ) {
        closeDropdown();
      }
    };
    
    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }
    
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen]);
  
  // Close dropdown on escape key
  useEffect(() => {
    const handleEscape = (event) => {
      if (event.key === 'Escape' && isOpen) {
        closeDropdown();
      }
    };
    
    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
    }
    
    return () => {
      document.removeEventListener('keydown', handleEscape);
    };
  }, [isOpen]);
  
  return (
    &lt;&gt;
      &lt;div 
        ref={triggerRef}
        onClick={toggleDropdown}
        className="dropdown-trigger"
      &gt;
        {trigger}
      &lt;/div&gt;
      
      {isOpen && createPortal(
        &lt;div
          ref={dropdownRef}
          className="dropdown-menu"
          style={{
            position: 'absolute',
            top: `${position.top}px`,
            left: `${position.left}px`,
            zIndex: 1000,
            backgroundColor: 'white',
            border: '1px solid #ccc',
            borderRadius: '4px',
            boxShadow: '0 2px 10px rgba(0,0,0,0.1)',
            minWidth: '200px'
          }}
        &gt;
          {children}
        &lt;/div&gt;,
        document.body
      )}
    &lt;/&gt;
  );
}

// Usage
function UserMenu() {
  const handleProfile = () => {
    console.log('Navigate to profile');
  };
  
  const handleSettings = () => {
    console.log('Navigate to settings');
  };
  
  const handleLogout = () => {
    console.log('Logout user');
  };
  
  return (
    &lt;Dropdown 
      trigger={
        &lt;button className="user-menu-button"&gt;
          &lt;img src="/avatar.jpg" alt="User" className="avatar" /&gt;
          &lt;span&gt;John Doe&lt;/span&gt;
          &lt;span className="dropdown-arrow"&gt;▼&lt;/span&gt;
        &lt;/button&gt;
      }
      placement="bottom-right"
    &gt;
      &lt;div className="dropdown-item" onClick={handleProfile}&gt;
        &lt;i className="icon-user"&gt;&lt;/i&gt;
        Profile
      &lt;/div&gt;
      &lt;div className="dropdown-item" onClick={handleSettings}&gt;
        &lt;i className="icon-settings"&gt;&lt;/i&gt;
        Settings
      &lt;/div&gt;
      &lt;hr className="dropdown-divider" /&gt;
      &lt;div className="dropdown-item" onClick={handleLogout}&gt;
        &lt;i className="icon-logout"&gt;&lt;/i&gt;
        Logout
      &lt;/div&gt;
    &lt;/Dropdown&gt;
  );
}

// Context menu with portal
function useContextMenu() {
  const [contextMenu, setContextMenu] = useState(null);
  
  const showContextMenu = (event, menuItems) => {
    event.preventDefault();
    
    setContextMenu({
      x: event.clientX,
      y: event.clientY,
      items: menuItems
    });
  };
  
  const hideContextMenu = () => {
    setContextMenu(null);
  };
  
  useEffect(() => {
    const handleClick = () => {
      hideContextMenu();
    };
    
    if (contextMenu) {
      document.addEventListener('click', handleClick);
    }
    
    return () => {
      document.removeEventListener('click', handleClick);
    };
  }, [contextMenu]);
  
  const ContextMenuComponent = () => {
    if (!contextMenu) return null;
    
    return createPortal(
      &lt;div
        className="context-menu"
        style={{
          position: 'fixed',
          top: `${contextMenu.y}px`,
          left: `${contextMenu.x}px`,
          zIndex: 1000
        }}
      &gt;
        {contextMenu.items.map((item, index) => (
          &lt;div
            key={index}
            className="context-menu-item"
            onClick={() => {
              item.onClick();
              hideContextMenu();
            }}
          &gt;
            {item.icon && &lt;span className="context-menu-icon"&gt;{item.icon}&lt;/span&gt;}
            {item.label}
          &lt;/div&gt;
        ))}
      &lt;/div&gt;,
      document.body
    );
  };
  
  return { showContextMenu, hideContextMenu, ContextMenuComponent };
}

// Usage
function App() {
  const { showContextMenu, hideContextMenu, ContextMenuComponent } = useContextMenu();
  
  const handleContextMenu = (e) => {
    showContextMenu(e, [
      {
        label: 'Cut',
        icon: '✂',
        onClick: () => console.log('Cut')
      },
      {
        label: 'Copy',
        icon: '📋',
        onClick: () => console.log('Copy')
      },
      {
        label: 'Paste',
        icon: '📄',
        onClick: () => console.log('Paste')
      },
      {
        label: 'Delete',
        icon: '🗑',
        onClick: () => console.log('Delete')
      }
    ]);
  };
  
  return (
    &lt;div&gt;
      &lt;ContextMenuComponent /&gt;
      
      &lt;div 
        className="context-area"
        onContextMenu={handleContextMenu}
        style={{
          width: '300px',
          height: '200px',
          border: '1px solid #ccc',
          padding: '20px',
          backgroundColor: '#f5f5f5'
        }}
      &gt;
        Right-click here for context menu
      &lt;/div&gt;
      
      &lt;UserMenu /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Portal Best Practices</h5>
                    <div class="data-type-section">
                        <h6>Clean Up Effects</h6>
                        <p>Always clean up event listeners and timeouts when using portals.</p>
                        
                        <h6>Handle Escape Key</h6>
                        <p>Implement keyboard navigation and escape key handling for accessibility.</p>
                        
                        <h6>Position Carefully</h6>
                        <p>Calculate positions carefully to avoid elements going off-screen.</p>
                        
                        <h6>Focus Management</h6>
                        <p>Properly manage focus when opening/closing portal elements.</p>
                        
                        <h6>Z-index Management</h6>
                        <p>Use appropriate z-index values to ensure proper layering.</p>
                    </div>
                </div>
            </div>

            <!-- Module 18: Advanced Context API -->
            <div class="content-card" id="module18">
                <div class="card-header">
                    <i class="fas fa-layer-group"></i> Module 18: Advanced Context API
                </div>
                <div class="card-body">
                    <h5>Advanced Context Patterns</h5>
                    <p>Context API is a powerful feature in React for sharing data between components without prop drilling. Advanced patterns can help optimize performance, organize code better, and create more maintainable applications.</p>

                    <h5>Optimized Context with Selectors</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">import React, { createContext, useContext, useMemo, useCallback } from 'react';

// Create context with optimized selectors
const AppContext = createContext();

function AppProvider({ children }) {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  // Memoize context value to prevent unnecessary re-renders
  const contextValue = useMemo(() => ({
    state,
    dispatch
  }), [state]);
  
  return (
    &lt;AppContext.Provider value={contextValue}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  );
}

// Custom hook with selector for optimized subscriptions
function useContextSelector(selector) {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useContextSelector must be used within AppProvider');
  }
  
  // Memoize the selected value to prevent unnecessary re-renders
  return useMemo(() => selector(context.state), [context.state, selector]);
}

// Custom hook with action creators
function useContextActions() {
  const { dispatch } = useContext(AppContext);
  if (!dispatch) {
    throw new Error('useContextActions must be used within AppProvider');
  }
  
  // Memoize action creators to prevent unnecessary re-renders
  return useMemo(() => ({
    setUser: useCallback((user) => dispatch({ type: 'SET_USER', payload: user }), [dispatch]),
    setTheme: useCallback((theme) => dispatch({ type: 'SET_THEME', payload: theme }), [dispatch]),
    addNotification: useCallback((notification) => dispatch({ type: 'ADD_NOTIFICATION', payload: notification }), [dispatch]),
    removeNotification: useCallback((id) => dispatch({ type: 'REMOVE_NOTIFICATION', payload: id }), [dispatch])
  }), [dispatch]);
}

// Usage examples
function UserName() {
  const userName = useContextSelector(state => state.user?.name);
  return &lt;span&gt;{userName || 'Guest'}&lt;/span&gt;;
}

function UserAvatar() {
  const userAvatar = useContextSelector(state => state.user?.avatar);
  return &lt;img src={userAvatar || '/default-avatar.png'} alt="User" /&gt;;
}

function ThemeToggle() {
  const theme = useContextSelector(state => state.theme);
  const { setTheme } = useContextActions();
  
  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
  };
  
  return (
    &lt;button onClick={toggleTheme}&gt;
      Current theme: {theme}
    &lt;/button&gt;
  );
}

// This component only re-renders when notifications change
function NotificationList() {
  const notifications = useContextSelector(state => state.notifications);
  const { removeNotification } = useContextActions();
  
  return (
    &lt;div&gt;
      {notifications.map(notification => (
        &lt;div key={notification.id}&gt;
          {notification.message}
          &lt;button onClick={() => removeNotification(notification.id)}&gt;
            Dismiss
          &lt;/button&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Multiple Contexts with Composition</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Separate contexts for different concerns
const UserContext = createContext();
const ThemeContext = createContext();
const NotificationContext = createContext();

// User context provider
function UserProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Load user from localStorage or API
    const loadUser = async () => {
      try {
        const token = localStorage.getItem('token');
        if (token) {
          const userData = await validateToken(token);
          setUser(userData);
        }
      } catch (error) {
        console.error('Failed to load user:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadUser();
  }, []);
  
  const login = async (credentials) => {
    setLoading(true);
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) throw new Error('Login failed');
      
      const { token, user } = await response.json();
      localStorage.setItem('token', token);
      setUser(user);
    } catch (error) {
      console.error('Login error:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  };
  
  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };
  
  const value = useMemo(() => ({
    user,
    loading,
    login,
    logout,
    isAuthenticated: !!user
  }), [user, loading, login, logout]);
  
  return (
    &lt;UserContext.Provider value={value}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
}

// Theme context provider
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const value = useMemo(() => ({
    theme,
    setTheme,
    toggleTheme,
    colors: theme === 'light' ? {
      background: '#ffffff',
      text: '#000000',
      primary: '#007bff'
    } : {
      background: '#1a1a1a',
      text: '#ffffff',
      primary: '#0d6efd'
    }
  }), [theme, setTheme, toggleTheme]);
  
  return (
    &lt;ThemeContext.Provider value={value}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// Notification context provider
function NotificationProvider({ children }) {
  const [notifications, setNotifications] = useState([]);
  
  const addNotification = useCallback((notification) => {
    const id = Date.now();
    const newNotification = { ...notification, id };
    setNotifications(prev => [...prev, newNotification]);
    
    // Auto-remove after duration
    if (notification.duration) {
      setTimeout(() => {
        setNotifications(prev => prev.filter(n => n.id !== id));
      }, notification.duration);
    }
  }, []);
  
  const removeNotification = useCallback((id) => {
    setNotifications(prev => prev.filter(n => n.id !== id));
  }, []);
  
  const clearNotifications = useCallback(() => {
    setNotifications([]);
  }, []);
  
  const value = useMemo(() => ({
    notifications,
    addNotification,
    removeNotification,
    clearNotifications
  }), [notifications, addNotification, removeNotification, clearNotifications]);
  
  return (
    &lt;NotificationContext.Provider value={value}&gt;
      {children}
    &lt;/NotificationContext.Provider&gt;
  );
}

// Custom hooks for each context
function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within UserProvider');
  }
  return context;
}

function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

function useNotifications() {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotifications must be used within NotificationProvider');
  }
  return context;
}

// Combined provider
function AppProviders({ children }) {
  return (
    &lt;UserProvider&gt;
      &lt;ThemeProvider&gt;
        &lt;NotificationProvider&gt;
          {children}
        &lt;/NotificationProvider&gt;
      &lt;/ThemeProvider&gt;
    &lt;/UserProvider&gt;
  );
}

// Usage
function App() {
  return (
    &lt;AppProviders&gt;
      &lt;Router&gt;
        &lt;Routes&gt;
          &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
          &lt;Route path="/profile" element={&lt;ProtectedRoute&gt;&lt;Profile /&gt;&lt;/ProtectedRoute&gt;} /&gt;
        &lt;/Routes&gt;
      &lt;/Router&gt;
    &lt;/AppProviders&gt;
  );
}

function Profile() {
  const { user } = useUser();
  const { theme, colors } = useTheme();
  const { addNotification } = useNotifications();
  
  const handleSave = async () => {
    try {
      await saveProfile(user);
      addNotification({
        message: 'Profile saved successfully!',
        type: 'success',
        duration: 3000
      });
    } catch (error) {
      addNotification({
        message: 'Failed to save profile',
        type: 'error',
        duration: 5000
      });
    }
  };
  
  return (
    &lt;div style={{ backgroundColor: colors.background, color: colors.text }}&gt;
      &lt;h1&gt;Profile&lt;/h1&gt;
      &lt;p&gt;Welcome, {user?.name}!&lt;/p&gt;
      &lt;p&gt;Current theme: {theme}&lt;/p&gt;
      &lt;button onClick={handleSave}&gt;Save Profile&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Context with Middleware Pattern</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Context middleware pattern for logging, persistence, etc.
function createContextWithMiddleware(reducer, initialState, middleware = []) {
  const Context = createContext();
  
  function Provider({ children }) {
    const [state, dispatch] = useReducer(reducer, initialState);
    
    // Apply middleware to dispatch
    const enhancedDispatch = useMemo(() => {
      return middleware.reduceRight((acc, middleware) => {
        return middleware(acc, dispatch);
      }, dispatch);
    }, [dispatch]);
    
    const value = useMemo(() => ({
      state,
      dispatch: enhancedDispatch
    }), [state, enhancedDispatch]);
    
    return (
      &lt;Context.Provider value={value}&gt;
        {children}
      &lt;/Context.Provider&gt;
    );
  }
  
  return { Context, Provider };
}

// Logging middleware
const loggingMiddleware = (dispatch, originalDispatch) => (action) => {
  console.log('Dispatching action:', action);
  const result = dispatch(action);
  console.log('State after action:', result);
  return result;
};

// Persistence middleware
const persistenceMiddleware = (dispatch, originalDispatch) => (action) => {
  const result = dispatch(action);
  
  // Save state to localStorage
  if (action.type !== 'LOAD_FROM_STORAGE') {
    try {
      localStorage.setItem('appState', JSON.stringify(result));
    } catch (error) {
      console.error('Failed to save state:', error);
    }
  }
  
  return result;
};

// Analytics middleware
const analyticsMiddleware = (dispatch, originalDispatch) => (action) => {
  // Track user actions
  if (typeof gtag !== 'undefined') {
    gtag('event', 'user_action', {
      action_type: action.type,
      action_payload: JSON.stringify(action.payload)
    });
  }
  
  return dispatch(action);
};

// Create context with middleware
const { Context: AppContext, Provider: AppProvider } = createContextWithMiddleware(
  appReducer,
  initialState,
  [loggingMiddleware, persistenceMiddleware, analyticsMiddleware]
);

// Usage
function App() {
  return (
    &lt;AppProvider&gt;
      &lt;MyApp /&gt;
    &lt;/AppProvider&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Context with State Machines</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// State machine pattern for complex state logic
function createStateMachine(config) {
  const { initialState, states } = config;
  
  return (state = initialState, event) => {
    const currentState = states[state];
    if (!currentState) {
      throw new Error(`Invalid state: ${state}`);
    }
    
    const transition = currentState.on?.[event.type];
    if (!transition) {
      return state;
    }
    
    if (transition.guard && !transition.guard(event.payload)) {
      return state;
    }
    
    const nextState = transition.target || state;
    
    // Execute actions
    if (transition.action) {
      transition.action(event.payload);
    }
    
    return nextState;
  };
}

// Form state machine
const formStateMachine = createStateMachine({
  initialState: 'idle',
  states: {
    idle: {
      on: {
        SUBMIT: {
          target: 'submitting',
          guard: (payload) => payload.isValid,
          action: (payload) => console.log('Submitting form:', payload)
        }
      }
    },
    submitting: {
      on: {
        SUCCESS: {
          target: 'success',
          action: (payload) => console.log('Form submitted successfully:', payload)
        },
        ERROR: {
          target: 'error',
          action: (payload) => console.log('Form submission failed:', payload)
        }
      }
    },
    success: {
      on: {
        RESET: {
          target: 'idle',
          action: () => console.log('Form reset')
        }
      }
    },
    error: {
      on: {
        RETRY: {
          target: 'submitting'
        },
        RESET: {
          target: 'idle'
        }
      }
    }
  }
});

function useFormMachine(initialData, validationSchema) {
  const [state, dispatch] = useReducer(formStateMachine, 'idle');
  const [formData, setFormData] = useState(initialData);
  const [errors, setErrors] = useState({});
  
  const submit = async () => {
    // Validate form
    const validationErrors = validateForm(formData, validationSchema);
    setErrors(validationErrors);
    
    if (Object.keys(validationErrors).length > 0) {
      return;
    }
    
    dispatch({ type: 'SUBMIT', payload: { isValid: true, data: formData } });
    
    try {
      const response = await fetch('/api/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });
      
      if (!response.ok) throw new Error('Submission failed');
      
      const result = await response.json();
      dispatch({ type: 'SUCCESS', payload: result });
    } catch (error) {
      dispatch({ type: 'ERROR', payload: { error: error.message } });
    }
  };
  
  const reset = () => {
    setFormData(initialData);
    setErrors({});
    dispatch({ type: 'RESET' });
  };
  
  const retry = () => {
    dispatch({ type: 'RETRY' });
  };
  
  return {
    state,
    formData,
    errors,
    setFormData,
    submit,
    reset,
    retry
  };
}

// Usage
function ContactForm() {
  const formMachine = useFormMachine(
    { name: '', email: '', message: '' },
    {
      name: { required: true },
      email: { required: true, pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ },
      message: { required: true, minLength: 10 }
    }
  );
  
  const { state, formData, errors, setFormData, submit, reset, retry } = formMachine;
  
  return (
    &lt;form onSubmit={(e) => { e.preventDefault(); submit(); }}&gt;
      &lt;div&gt;
        &lt;label&gt;Name:&lt;/label&gt;
        &lt;input
          value={formData.name}
          onChange={(e) => setFormData({ ...formData, name: e.target.value })}
        /&gt;
        {errors.name && &lt;span className="error"&gt;{errors.name}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          value={formData.email}
          onChange={(e) => setFormData({ ...formData, email: e.target.value })}
        /&gt;
        {errors.email && &lt;span className="error"&gt;{errors.email}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;Message:&lt;/label&gt;
        &lt;textarea
          value={formData.message}
          onChange={(e) => setFormData({ ...formData, message: e.target.value })}
        /&gt;
        {errors.message && &lt;span className="error"&gt;{errors.message}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;button type="submit" disabled={state === 'submitting'}&gt;
          {state === 'submitting' ? 'Submitting...' : 'Submit'}
        &lt;/button&gt;
        
        {state === 'error' && (
          &lt;&gt;
            &lt;button type="button" onClick={retry}&gt;
              Retry
            &lt;/button&gt;
            &lt;button type="button" onClick={reset}&gt;
              Reset
            &lt;/button&gt;
          &lt;/&gt;
        )}
        
        {state === 'success' && (
          &lt;button type="button" onClick={reset}&gt;
            Submit Another
          &lt;/button&gt;
        )}
      &lt;/div&gt;
      
      {state === 'success' && (
        &lt;div className="success-message"&gt;
          Form submitted successfully!
        &lt;/div&gt;
      )}
      
      {state === 'error' && (
        &lt;div className="error-message"&gt;
          Submission failed. Please try again.
        &lt;/div&gt;
      )}
    &lt;/form&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Context with Performance Optimization</h5>
                    {% raw %}
                    <pre><button class="copy-button">Copy</button><code class="language-jsx">// Optimized context with subscription management
function createOptimizedContext(defaultValue) {
  const Context = createContext(defaultValue);
  
  function Provider({ value, children }) {
    // Use a ref to store the current value to avoid re-renders
    const valueRef = useRef(value);
    
    // Update ref when value changes
    useEffect(() => {
      valueRef.current = value;
    }, [value]);
    
    // Create a subscription map
    const subscriptions = useRef(new Map());
    
    // Subscribe to context changes
    const subscribe = (callback, selector) => {
      const id = Symbol();
      const subscription = { callback, selector };
      
      subscriptions.current.set(id, subscription);
      
      // Call callback immediately with current value
      const currentValue = selector ? selector(valueRef.current) : valueRef.current;
      callback(currentValue);
      
      // Return unsubscribe function
      return () => {
        subscriptions.current.delete(id);
      };
    };
    
    // Notify subscribers when value changes
    useEffect(() => {
      subscriptions.current.forEach(({ callback, selector }) => {
        const currentValue = selector ? selector(valueRef.current) : valueRef.current;
        callback(currentValue);
      });
    }, [value]);
    
    const contextValue = useMemo(() => ({
      value: valueRef.current,
      subscribe
    }), []);
    
    return (
      &lt;Context.Provider value={contextValue}&gt;
        {children}
      &lt;/Context.Provider&gt;
    );
  }
  
  // Custom hook for optimized subscriptions
  function useContextSubscription(selector, equalityFn = Object.is) {
    const context = useContext(Context);
    if (!context) {
      throw new Error('useContextSubscription must be used within Provider');
    }
    
    const [selectedValue, setSelectedValue] = useState(() => 
      selector ? selector(context.value) : context.value
    );
    
    const selectorRef = useRef(selector);
    const equalityFnRef = useRef(equalityFn);
    const selectedValueRef = useRef(selectedValue);
    
    useEffect(() => {
      return context.subscribe((newValue) => {
        const newSelectedValue = selectorRef.current ? selectorRef.current(newValue) : newValue;
        
        if (!equalityFnRef.current(selectedValueRef.current, newSelectedValue)) {
          selectedValueRef.current = newSelectedValue;
          setSelectedValue(newSelectedValue);
        }
      }, selectorRef.current);
    }, [context.subscribe]);
    
    return selectedValue;
  }
  
  return { Context, Provider, useContextSubscription };
}

// Usage
const { Context: UserContext, Provider: UserProvider, useContextSubscription: useUserSubscription } = createOptimizedContext({
  user: null,
  loading: false,
  error: null
});

function App() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  
  const value = useMemo(() => ({
    user,
    loading,
    error: null,
    setUser,
    setLoading
  }), [user, loading]);
  
  return (
    &lt;UserProvider value={value}&gt;
      &lt;Dashboard /&gt;
      &lt;Sidebar /&gt;
    &lt;/UserProvider&gt;
  );
}

// Component that only re-renders when user.name changes
function UserName() {
  const userName = useUserSubscription(
    state => state.user?.name,
    (prev, next) => prev === next
  );
  
  return &lt;span&gt;{userName || 'Guest'}&lt;/span&gt;;
}

// Component that only re-renders when loading state changes
function LoadingIndicator() {
  const isLoading = useUserSubscription(
    state => state.loading,
    (prev, next) => prev === next
  );
  
  return isLoading ? &lt;div&gt;Loading...&lt;/div&gt; : null;
}

// Component that subscribes to multiple values
function UserInfo() {
  const userInfo = useUserSubscription(
    state => ({
      name: state.user?.name,
      email: state.user?.email,
      loading: state.loading
    }),
    (prev, next) => 
      prev.name === next.name && 
      prev.email === next.email && 
      prev.loading === next.loading
  );
  
  if (userInfo.loading) {
    return &lt;div&gt;Loading user info...&lt;/div&gt;;
  }
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{userInfo.name}&lt;/h2&gt;
      &lt;p&gt;{userInfo.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    {% endraw %}

                    <h5>Context Best Practices</h5>
                    <div class="data-type-section">
                        <h6>Split Contexts</h6>
                        <p>Split contexts by domain rather than having one large context.</p>
                        
                        <h6>Use Selectors</h6>
                        <p>Use selectors to prevent unnecessary re-renders.</p>
                        
                        <h6>Avoid Context for Everything</h6>
                        <p>Don't use context for props that don't change often or are only needed by few components.</p>
                        
                        <h6>Optimize Provider Value</h6>
                        <p>Memoize the context value to prevent unnecessary re-renders.</p>
                        
                        <h6>Consider State Management Libraries</h6>
                        <p>For complex state management, consider libraries like Redux, Zustand, or Jotai.</p>
                    </div>
                </div>
            </div>

            <div class="mt-5 text-center">
                <a href="/practice" class="btn btn-primary btn-lg">Take Practice Test</a>
            </div>

            <div id="animation-container-docs" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1;"></div>
        </div>
    </div>

    <script>
        // Smooth scrolling for sidebar navigation
        document.querySelectorAll('.sidebar .nav-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth' });
                }
                // Update active state
                document.querySelectorAll('.sidebar .nav-link').forEach(l => l.classList.remove('active'));
                this.classList.add('active');
            });
        });

        // Search functionality
        document.getElementById('search-input').addEventListener('input', function() {
            const query = this.value.toLowerCase();
            const content = document.getElementById('content');
            const elements = content.querySelectorAll('h2, h3, h4, h5, h6, p, pre, .card');
            
            elements.forEach(element => {
                const text = element.textContent.toLowerCase();
                if (query === '' || text.includes(query)) {
                    element.style.display = '';
                } else {
                    element.style.display = 'none';
                }
            });
        });

        // Clear search function
        function clearSearch() {
            document.getElementById('search-input').value = '';
            const content = document.getElementById('content');
            const elements = content.querySelectorAll('h2, h3, h4, h5, h6, p, pre, .card');
            elements.forEach(element => {
                element.style.display = '';
            });
        }

        // Copy to clipboard functionality
        const copyButtons = document.querySelectorAll('.copy-button');
        copyButtons.forEach(button => {
            button.addEventListener('click', function() {
                const code = this.parentNode.querySelector('code').textContent;
                navigator.clipboard.writeText(code);
                this.textContent = 'Copied!';
                setTimeout(() => {
                    this.textContent = 'Copy';
                }, 2000);
            });
        });

        // Highlight active section in sidebar based on scroll position
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('[id]');
            const navLinks = document.querySelectorAll('.sidebar .nav-link');

            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (pageYOffset >= sectionTop - 100) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        });

        // Initialize all elements to be visible on page load
        document.addEventListener('DOMContentLoaded', function() {
            const content = document.getElementById('content');
            const elements = content.querySelectorAll('h2, h3, h4, h5, h6, p, pre, .card');
            elements.forEach(element => {
                element.style.display = '';
            });
        });
    </script>
{% endblock %}