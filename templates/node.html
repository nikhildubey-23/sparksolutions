{% extends 'base.html' %}

{% block title %}Node.js Docs - SN VERSE{% endblock %}

{% block head %}
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.3/purify.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
{% endblock %}

{% block content %}
    <!-- Node.js Docs Page -->
    <section class="docs-page py-5">
        <div class="container-fluid">
            <div class="row">
                <!-- Documentation Content -->
                <div class="col-md-12">
                    <!-- Search Box -->
                    <div class="search-container mb-4">
                        <input type="text" id="search-input" class="form-control" placeholder="Search documentation...">
                    </div>
                    <div id="content">
                        <h2 class="mb-4">Node.js Documentation</h2>
                        <p>Welcome to the comprehensive Node.js documentation. Here, you'll find detailed guides and tutorials for building server-side applications with Node.js.</p>

                        <h3 id="introduction" class="mt-5">Introduction to Node.js</h3>
                        <p>Node.js is an open-source, cross-platform JavaScript runtime environment that executes JavaScript code outside a web browser. It allows developers to use JavaScript to write command line tools and for server-side scripting.</p>
                        <p>Key features of Node.js:</p>
                        <ul>
                            <li><strong>Asynchronous and Event-Driven</strong> - All APIs are asynchronous and non-blocking</li>
                            <li><strong>Single-Threaded</strong> - Uses a single thread with event looping for scalability</li>
                            <li><strong>High Performance</strong> - Built on Google Chrome's V8 JavaScript engine</li>
                            <li><strong>NPM Ecosystem</strong> - Largest ecosystem of open-source libraries</li>
                            <li><strong>Cross-Platform</strong> - Runs on Windows, macOS, and Linux</li>
                        </ul>

                        <h3 id="setup" class="mt-5">Setup and Installation</h3>
                        <p>There are several ways to install Node.js on your system:</p>

                        <h4>Official Installer</h4>
                        <p>Download the installer from the official website: <a href="https://nodejs.org/" target="_blank">nodejs.org</a></p>

                        <h4>Using Version Manager (Recommended)</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install NVM (Node Version Manager)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash

# Reload your shell
source ~/.bashrc

# Install latest LTS version
nvm install --lts

# Use specific version
nvm use 18.17.0

# List installed versions
nvm ls

# Switch between versions
nvm use 16.20.0
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Verify Installation</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Check Node.js version
node --version

# Check npm version
npm --version

# Check npx version
npx --version
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="core-concepts" class="mt-5">Core Concepts</h3>

                        <h4>Event Loop</h4>
                        <p>The event loop is what allows Node.js to perform non-blocking I/O operations despite being single-threaded.</p>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
// Example of event loop behavior
console.log('Start');

setTimeout(() => {
    console.log('Timeout 1');
}, 0);

setTimeout(() => {
    console.log('Timeout 2');
}, 0);

Promise.resolve().then(() => {
    console.log('Promise 1');
});

Promise.resolve().then(() => {
    console.log('Promise 2');
});

console.log('End');

// Output order:
// Start
// End
// Promise 1
// Promise 2
// Timeout 1
// Timeout 2
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Modules</h4>
                        <p>Node.js uses the CommonJS module system by default. Each file is treated as a separate module.</p>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
// math.js - Exporting functions
function add(a, b) {
    return a + b;
}

function subtract(a, b) {
    return a - b;
}

// Export individual functions
exports.add = add;
exports.subtract = subtract;

// Or export an object
module.exports = {
    add,
    subtract,
    multiply: (a, b) => a * b
};

// app.js - Importing modules
const math = require('./math');
const { add, subtract } = require('./math');

console.log(add(5, 3));        // 8
console.log(subtract(5, 3));   // 2
console.log(math.multiply(5, 3)); // 15

// ES Modules (package.json: "type": "module")
// utils.mjs
export const helper = () => {
    return 'Helper function';
};

export default class Utility {
    static log(message) {
        console.log(message);
    }
};

// app.mjs
import Utility, { helper } from './utils.mjs';
import fs from 'fs';

Utility.log(helper());
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Global Objects</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
// Global objects available in Node.js
console.log(__filename);  // Current file path
console.log(__dirname);    // Directory path of current file
console.log(process.cwd()); // Current working directory

// Process object
console.log(process.env.NODE_ENV); // Environment variables
console.log(process.argv);        // Command line arguments
console.log(process.pid);         // Process ID
console.log(process.platform);    // Operating system platform

// Global functions
setTimeout(() => {
    console.log('Delayed execution');
}, 1000);

setInterval(() => {
    console.log('Repeated execution');
}, 1000);

// Buffer (Node.js specific)
const buf = Buffer.from('Hello World');
console.log(buf.toString()); // Hello World
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="file-system" class="mt-5">File System Operations</h3>
                        <p>Node.js provides a built-in fs module for file system operations.</p>

                        <h4>Synchronous vs Asynchronous</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const fs = require('fs');
const path = require('path');

// Asynchronous operations (recommended)
fs.readFile('example.txt', 'utf8', (err, data) => {
    if (err) {
        console.error('Error reading file:', err);
        return;
    }
    console.log('File content:', data);
});

// Synchronous operations (blocking)
try {
    const data = fs.readFileSync('example.txt', 'utf8');
    console.log('File content:', data);
} catch (err) {
    console.error('Error reading file:', err);
}

// Promise-based operations (fs.promises)
const fsPromises = require('fs').promises;

async function readFileAsync() {
    try {
        const data = await fsPromises.readFile('example.txt', 'utf8');
        console.log('File content:', data);
    } catch (err) {
        console.error('Error reading file:', err);
    }
}

readFileAsync();
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>File Operations</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const fs = require('fs');
const path = require('path');

// Create directory
const dirPath = path.join(__dirname, 'new-directory');
fs.mkdir(dirPath, { recursive: true }, (err) => {
    if (err) throw err;
    console.log('Directory created');
});

// Write file
const filePath = path.join(dirPath, 'test.txt');
const content = 'Hello, Node.js!';

fs.writeFile(filePath, content, 'utf8', (err) => {
    if (err) throw err;
    console.log('File written');
});

// Append to file
fs.appendFile(filePath, '\nAppended content', 'utf8', (err) => {
    if (err) throw err;
    console.log('Content appended');
});

// Read file
fs.readFile(filePath, 'utf8', (err, data) => {
    if (err) throw err;
    console.log('File content:', data);
});

// Check if file exists
fs.access(filePath, fs.constants.F_OK, (err) => {
    if (err) {
        console.log('File does not exist');
    } else {
        console.log('File exists');
    }
});

// Get file stats
fs.stat(filePath, (err, stats) => {
    if (err) throw err;
    console.log('File size:', stats.size);
    console.log('Is file:', stats.isFile());
    console.log('Is directory:', stats.isDirectory());
    console.log('Created:', stats.birthtime);
    console.log('Modified:', stats.mtime);
});

// Delete file
fs.unlink(filePath, (err) => {
    if (err) throw err;
    console.log('File deleted');
});

// Remove directory
fs.rmdir(dirPath, (err) => {
    if (err) throw err;
    console.log('Directory removed');
});
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Working with Directories</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const fs = require('fs');
const path = require('path');

// Read directory contents
fs.readdir(__dirname, (err, files) => {
    if (err) throw err;
    console.log('Directory contents:', files);
    
    // Filter only JavaScript files
    const jsFiles = files.filter(file => path.extname(file) === '.js');
    console.log('JavaScript files:', jsFiles);
});

// Create directory recursively
const createDirRecursive = (dirPath) => {
    fs.mkdir(dirPath, { recursive: true }, (err) => {
        if (err) throw err;
        console.log(`Directory created: ${dirPath}`);
    });
};

createDirRecursive(path.join(__dirname, 'nested', 'directory'));

// Watch directory for changes
fs.watch(__dirname, (eventType, filename) => {
    console.log(`Event type: ${eventType}`);
    console.log(`Filename: ${filename}`);
});
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="http-module" class="mt-5">HTTP Module and Web Servers</h3>
                        <p>Node.js has a built-in HTTP module to create HTTP servers and clients.</p>

                        <h4>Creating a Basic HTTP Server</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const http = require('http');
const url = require('url');

// Create HTTP server
const server = http.createServer((req, res) => {
    // Parse URL
    const parsedUrl = url.parse(req.url, true);
    const path = parsedUrl.pathname;
    const method = req.method;

    // Set response headers
    res.setHeader('Content-Type', 'application/json');

    // Basic routing
    if (path === '/' && method === 'GET') {
        res.writeHead(200);
        res.end(JSON.stringify({ message: 'Welcome to Node.js Server!' }));
    } else if (path === '/api/users' && method === 'GET') {
        res.writeHead(200);
        res.end(JSON.stringify([
            { id: 1, name: 'John Doe', email: 'john@example.com' },
            { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
        ]));
    } else if (path === '/api/users' && method === 'POST') {
        let body = '';
        
        req.on('data', chunk => {
            body += chunk.toString();
        });
        
        req.on('end', () => {
            try {
                const userData = JSON.parse(body);
                res.writeHead(201);
                res.end(JSON.stringify({ 
                    message: 'User created', 
                    user: userData 
                }));
            } catch (error) {
                res.writeHead(400);
                res.end(JSON.stringify({ error: 'Invalid JSON' }));
            }
        });
    } else {
        res.writeHead(404);
        res.end(JSON.stringify({ error: 'Route not found' }));
    }
});

// Start server
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});

// Handle server errors
server.on('error', (err) => {
    if (err.code === 'EADDRINUSE') {
        console.error(`Port ${PORT} is already in use`);
    } else {
        console.error('Server error:', err);
    }
});
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>HTTP Client</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const http = require('http');
const https = require('https');

// Making GET request
const options = {
    hostname: 'jsonplaceholder.typicode.com',
    path: '/posts/1',
    method: 'GET'
};

const req = http.request(options, (res) => {
    let data = '';
    
    res.on('data', (chunk) => {
        data += chunk;
    });
    
    res.on('end', () => {
        console.log('Response:', JSON.parse(data));
    });
});

req.on('error', (err) => {
    console.error('Request error:', err);
});

req.end();

// Making POST request
const postData = JSON.stringify({
    title: 'foo',
    body: 'bar',
    userId: 1
});

const postOptions = {
    hostname: 'jsonplaceholder.typicode.com',
    path: '/posts',
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(postData)
    }
};

const postReq = http.request(postOptions, (res) => {
    let data = '';
    
    res.on('data', (chunk) => {
        data += chunk;
    });
    
    res.on('end', () => {
        console.log('Response:', JSON.parse(data));
    });
});

postReq.on('error', (err) => {
    console.error('Request error:', err);
});

postReq.write(postData);
postReq.end();
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="express" class="mt-5">Express.js Framework</h3>
                        <p>Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.</p>

                        <h4>Setting up Express</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Initialize npm project
npm init -y

# Install Express
npm install express

# Install additional useful packages
npm install cors helmet morgan dotenv
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Basic Express Server</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');

// Initialize Express app
const app = express();

// Middleware
app.use(helmet()); // Security headers
app.use(cors());   // Enable CORS
app.use(morgan('dev')); // Logging
app.use(express.json()); // Parse JSON bodies
app.use(express.urlencoded({ extended: true })); // Parse URL-encoded bodies

// Routes
app.get('/', (req, res) => {
    res.json({ message: 'Welcome to Express Server!' });
});

app.get('/api/users', (req, res) => {
    const users = [
        { id: 1, name: 'John Doe', email: 'john@example.com' },
        { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
    ];
    res.json(users);
});

app.get('/api/users/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const users = [
        { id: 1, name: 'John Doe', email: 'john@example.com' },
        { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
    ];
    const user = users.find(u => u.id === id);
    
    if (user) {
        res.json(user);
    } else {
        res.status(404).json({ error: 'User not found' });
    }
});

app.post('/api/users', (req, res) => {
    const { name, email } = req.body;
    
    if (!name || !email) {
        return res.status(400).json({ error: 'Name and email are required' });
    }
    
    const newUser = {
        id: Date.now(),
        name,
        email
    };
    
    res.status(201).json(newUser);
});

// Error handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Something went wrong!' });
});

// 404 handler
app.use((req, res) => {
    res.status(404).json({ error: 'Route not found' });
});

// Start server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Express server running on port ${PORT}`);
});
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Route Parameters and Query Strings</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const express = require('express');
const app = express();

// Route parameters
app.get('/users/:userId/posts/:postId', (req, res) => {
    const { userId, postId } = req.params;
    res.json({ userId, postId });
});

// Query parameters
app.get('/search', (req, res) => {
    const { q, page = 1, limit = 10 } = req.query;
    res.json({ query: q, page: parseInt(page), limit: parseInt(limit) });
});

// Wildcard routes
app.get('/files/*', (req, res) => {
    const filePath = req.params[0];
    res.json({ filePath });
});

// Multiple route handlers
app.get('/api/data', 
    (req, res, next) => {
        console.log('First handler');
        next();
    },
    (req, res) => {
        console.log('Second handler');
        res.json({ message: 'Data from multiple handlers' });
    }
);
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Middleware</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const express = require('express');
const app = express();

// Application-level middleware
app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);
    next();
});

// Route-specific middleware
const requireAuth = (req, res, next) => {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || authHeader !== 'Bearer secret-token') {
        return res.status(401).json({ error: 'Unauthorized' });
    }
    
    next();
};

app.get('/protected', requireAuth, (req, res) => {
    res.json({ message: 'Protected data' });
});

// Error-handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Internal server error' });
});

// Custom middleware factory
const validateBody = (requiredFields) => {
    return (req, res, next) => {
        const missingFields = requiredFields.filter(field => !req.body[field]);
        
        if (missingFields.length > 0) {
            return res.status(400).json({ 
                error: 'Missing required fields', 
                fields: missingFields 
            });
        }
        
        next();
    };
};

app.post('/api/users', 
    validateBody(['name', 'email']), 
    (req, res) => {
        res.json({ message: 'User created', user: req.body });
    }
);
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Static Files</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const express = require('express');
const path = require('path');
const app = express();

// Serve static files from 'public' directory
app.use(express.static(path.join(__dirname, 'public')));

// Serve static files with custom URL prefix
app.use('/assets', express.static(path.join(__dirname, 'public')));

// Virtual path prefix
app.use('/static', express.static(path.join(__dirname, 'public'), {
    maxAge: '1d', // Cache for 1 day
    etag: true   // Enable ETag
}));

// Example: Access files
// http://localhost:3000/styles.css
// http://localhost:3000/assets/images/logo.png
// http://localhost:3000/static/js/app.js
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="database" class="mt-5">Database Integration</h3>

                        <h4>MongoDB with Mongoose</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install Mongoose
npm install mongoose
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const mongoose = require('mongoose');

// Connect to MongoDB
mongoose.connect('mongodb://localhost:27017/myapp', {
    useNewUrlParser: true,
    useUnifiedTopology: true
});

// Define schema
const userSchema = new mongoose.Schema({
    name: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    age: { type: Number, min: 0 },
    createdAt: { type: Date, default: Date.now }
});

// Create model
const User = mongoose.model('User', userSchema);

// CRUD Operations
async function createUser(userData) {
    try {
        const user = new User(userData);
        await user.save();
        return user;
    } catch (error) {
        throw error;
    }
}

async function getAllUsers() {
    try {
        const users = await User.find();
        return users;
    } catch (error) {
        throw error;
    }
}

async function getUserById(id) {
    try {
        const user = await User.findById(id);
        return user;
    } catch (error) {
        throw error;
    }
}

async function updateUser(id, updateData) {
    try {
        const user = await User.findByIdAndUpdate(
            id, 
            updateData, 
            { new: true, runValidators: true }
        );
        return user;
    } catch (error) {
        throw error;
    }
}

async function deleteUser(id) {
    try {
        const user = await User.findByIdAndDelete(id);
        return user;
    } catch (error) {
        throw error;
    }
}

// Express routes with Mongoose
const express = require('express');
const router = express.Router();

router.post('/users', async (req, res) => {
    try {
        const user = await createUser(req.body);
        res.status(201).json(user);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

router.get('/users', async (req, res) => {
    try {
        const users = await getAllUsers();
        res.json(users);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

module.exports = router;
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>MySQL with Sequelize</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install Sequelize and MySQL driver
npm install sequelize mysql2
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const { Sequelize, DataTypes } = require('sequelize');

// Initialize Sequelize
const sequelize = new Sequelize('myapp', 'username', 'password', {
    host: 'localhost',
    dialect: 'mysql'
});

// Define model
const User = sequelize.define('User', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    name: {
        type: DataTypes.STRING,
        allowNull: false
    },
    email: {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true
    },
    age: {
        type: DataTypes.INTEGER,
        validate: {
            min: 0
        }
    }
});

// Sync database
sequelize.sync({ force: false }).then(() => {
    console.log('Database synchronized');
});

// CRUD Operations
async function createUser(userData) {
    try {
        const user = await User.create(userData);
        return user;
    } catch (error) {
        throw error;
    }
}

async function getAllUsers() {
    try {
        const users = await User.findAll();
        return users;
    } catch (error) {
        throw error;
    }
}

async function getUserById(id) {
    try {
        const user = await User.findByPk(id);
        return user;
    } catch (error) {
        throw error;
    }
}

async function updateUser(id, updateData) {
    try {
        const user = await User.update(updateData, {
            where: { id }
        });
        return user;
    } catch (error) {
        throw error;
    }
}

async function deleteUser(id) {
    try {
        const result = await User.destroy({
            where: { id }
        });
        return result;
    } catch (error) {
        throw error;
    }
}

// Query examples
async function findUsersByAge(minAge) {
    try {
        const users = await User.findAll({
            where: {
                age: {
                    [Sequelize.Op.gte]: minAge
                }
            },
            order: [['age', 'ASC']]
        });
        return users;
    } catch (error) {
        throw error;
    }
}
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="authentication" class="mt-5">Authentication and Security</h3>

                        <h4>JWT Authentication</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install JWT and bcrypt
npm install jsonwebtoken bcryptjs
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

// JWT Secret
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Hash password
async function hashPassword(password) {
    const saltRounds = 10;
    return await bcrypt.hash(password, saltRounds);
}

// Compare password
async function comparePassword(password, hashedPassword) {
    return await bcrypt.compare(password, hashedPassword);
}

// Generate JWT token
function generateToken(payload) {
    return jwt.sign(payload, JWT_SECRET, { expiresIn: '24h' });
}

// Verify JWT token
function verifyToken(token) {
    return jwt.verify(token, JWT_SECRET);
}

// Middleware to protect routes
function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        return res.status(401).json({ error: 'Access token required' });
    }

    try {
        const decoded = verifyToken(token);
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(403).json({ error: 'Invalid token' });
    }
}

// Express routes for authentication
const express = require('express');
const router = express.Router();

// Register
router.post('/register', async (req, res) => {
    try {
        const { name, email, password } = req.body;
        
        // Check if user already exists
        const existingUser = await User.findOne({ where: { email } });
        if (existingUser) {
            return res.status(400).json({ error: 'User already exists' });
        }
        
        // Hash password
        const hashedPassword = await hashPassword(password);
        
        // Create user
        const user = await User.create({
            name,
            email,
            password: hashedPassword
        });
        
        // Generate token
        const token = generateToken({ id: user.id, email: user.email });
        
        res.status(201).json({
            message: 'User created successfully',
            token,
            user: { id: user.id, name: user.name, email: user.email }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Login
router.post('/login', async (req, res) => {
    try {
        const { email, password } = req.body;
        
        // Find user
        const user = await User.findOne({ where: { email } });
        if (!user) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }
        
        // Check password
        const isValidPassword = await comparePassword(password, user.password);
        if (!isValidPassword) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }
        
        // Generate token
        const token = generateToken({ id: user.id, email: user.email });
        
        res.json({
            message: 'Login successful',
            token,
            user: { id: user.id, name: user.name, email: user.email }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Protected route
router.get('/profile', authenticateToken, async (req, res) => {
    try {
        const user = await User.findByPk(req.user.id);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        res.json({
            user: { id: user.id, name: user.name, email: user.email }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

module.exports = router;
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Rate Limiting</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install express-rate-limit
npm install express-rate-limit
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const rateLimit = require('express-rate-limit');

// General rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
    message: 'Too many requests from this IP, please try again later.',
    standardHeaders: true,
    legacyHeaders: false,
});

app.use(limiter);

// Strict rate limiting for auth routes
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // Limit each IP to 5 requests per windowMs
    message: 'Too many authentication attempts, please try again later.',
    standardHeaders: true,
    legacyHeaders: false,
});

app.post('/api/login', authLimiter, (req, res) => {
    // Login logic
});

// Create rate limiter for different endpoints
const createRateLimiter = (windowMs, max, message) => {
    return rateLimit({
        windowMs,
        max,
        message,
        standardHeaders: true,
        legacyHeaders: false,
    });
};

const apiLimiter = createRateLimiter(15 * 60 * 1000, 100, 'Too many API requests');
const uploadLimiter = createRateLimiter(60 * 60 * 1000, 10, 'Too many upload requests');

app.use('/api/', apiLimiter);
app.use('/api/upload', uploadLimiter);
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="rest-api" class="mt-5">Building RESTful APIs</h3>

                        <h4>RESTful API Structure</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const express = require('express');
const router = express.Router();

// RESTful routes for users resource
// GET /api/users - Get all users
router.get('/users', async (req, res) => {
    try {
        const { page = 1, limit = 10, sort = 'createdAt', order = 'desc' } = req.query;
        
        const offset = (page - 1) * limit;
        const users = await User.findAndCountAll({
            limit: parseInt(limit),
            offset: parseInt(offset),
            order: [[sort, order.toUpperCase()]]
        });
        
        res.json({
            users: users.rows,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: users.count,
                pages: Math.ceil(users.count / limit)
            }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/users/:id - Get user by ID
router.get('/users/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const user = await User.findByPk(id);
        
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        res.json(user);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// POST /api/users - Create new user
router.post('/users', async (req, res) => {
    try {
        const { name, email, age } = req.body;
        
        // Validation
        if (!name || !email) {
            return res.status(400).json({ 
                error: 'Name and email are required' 
            });
        }
        
        // Check if user already exists
        const existingUser = await User.findOne({ where: { email } });
        if (existingUser) {
            return res.status(409).json({ 
                error: 'User with this email already exists' 
            });
        }
        
        const user = await User.create({ name, email, age });
        
        res.status(201).json({
            message: 'User created successfully',
            user
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// PUT /api/users/:id - Update user
router.put('/users/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const { name, email, age } = req.body;
        
        const user = await User.findByPk(id);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        // Check if email is being changed and if it already exists
        if (email && email !== user.email) {
            const existingUser = await User.findOne({ where: { email } });
            if (existingUser) {
                return res.status(409).json({ 
                    error: 'User with this email already exists' 
                });
            }
        }
        
        await user.update({ name, email, age });
        
        res.json({
            message: 'User updated successfully',
            user
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// PATCH /api/users/:id - Partially update user
router.patch('/users/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const updates = req.body;
        
        const user = await User.findByPk(id);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        await user.update(updates);
        
        res.json({
            message: 'User updated successfully',
            user
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// DELETE /api/users/:id - Delete user
router.delete('/users/:id', async (req, res) => {
    try {
        const { id } = req.params;
        
        const user = await User.findByPk(id);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        await user.destroy();
        
        res.json({
            message: 'User deleted successfully'
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

module.exports = router;
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>API Versioning</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const express = require('express');
const app = express();

// Version 1 API
const v1Router = express.Router();
v1Router.get('/users', (req, res) => {
    res.json({ version: 'v1', users: [] });
});

// Version 2 API
const v2Router = express.Router();
v2Router.get('/users', (req, res) => {
    res.json({ version: 'v2', users: [], metadata: {} });
});

// Mount versioned routes
app.use('/api/v1', v1Router);
app.use('/api/v2', v2Router);

// Alternative: Header-based versioning
app.use('/api/users', (req, res, next) => {
    const version = req.headers['api-version'] || 'v1';
    
    if (version === 'v1') {
        return v1UsersHandler(req, res);
    } else if (version === 'v2') {
        return v2UsersHandler(req, res);
    }
    
    next();
});

// URL parameter versioning
app.use('/api/:version/users', (req, res, next) => {
    const { version } = req.params;
    
    if (version === 'v1') {
        return v1UsersHandler(req, res);
    } else if (version === 'v2') {
        return v2UsersHandler(req, res);
    }
    
    res.status(400).json({ error: 'Invalid version' });
});
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="error-handling" class="mt-5">Error Handling</h3>

                        <h4>Centralized Error Handling</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const express = require('express');
const app = express();

// Custom error classes
class AppError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
        this.isOperational = true;
        
        Error.captureStackTrace(this, this.constructor);
    }
}

class ValidationError extends AppError {
    constructor(message) {
        super(message, 400);
    }
}

class NotFoundError extends AppError {
    constructor(message = 'Resource not found') {
        super(message, 404);
    }
}

class UnauthorizedError extends AppError {
    constructor(message = 'Unauthorized') {
        super(message, 401);
    }
}

// Async error wrapper
const asyncHandler = (fn) => {
    return (req, res, next) => {
        Promise.resolve(fn(req, res, next)).catch(next);
    };
};

// Error handling middleware
const errorHandler = (err, req, res, next) => {
    let error = { ...err };
    error.message = err.message;

    // Log error
    console.error(err);

    // Mongoose bad ObjectId
    if (err.name === 'CastError') {
        const message = 'Resource not found';
        error = new AppError(message, 404);
    }

    // Mongoose duplicate key
    if (err.code === 11000) {
        const message = 'Duplicate field value entered';
        error = new AppError(message, 400);
    }

    // Mongoose validation error
    if (err.name === 'ValidationError') {
        const message = Object.values(err.errors).map(val => val.message);
        error = new AppError(message, 400);
    }

    // JWT error
    if (err.name === 'JsonWebTokenError') {
        const message = 'Invalid token';
        error = new UnauthorizedError(message);
    }

    // JWT expired error
    if (err.name === 'TokenExpiredError') {
        const message = 'Token expired';
        error = new UnauthorizedError(message);
    }

    res.status(error.statusCode || 500).json({
        success: false,
        error: error.message || 'Server Error',
        ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
    });
};

// 404 handler
const notFound = (req, res, next) => {
    const error = new NotFoundError(`Not found - ${req.originalUrl}`);
    next(error);
};

// Usage in routes
app.get('/users/:id', asyncHandler(async (req, res, next) => {
    const user = await User.findById(req.params.id);
    
    if (!user) {
        return next(new NotFoundError('User not found'));
    }
    
    res.json(user);
}));

// Register error handlers
app.use(notFound);
app.use(errorHandler);

// Example route with error handling
app.post('/users', asyncHandler(async (req, res, next) => {
    const { name, email } = req.body;
    
    if (!name || !email) {
        return next(new ValidationError('Name and email are required'));
    }
    
    try {
        const user = await User.create({ name, email });
        res.status(201).json(user);
    } catch (error) {
        next(error);
    }
}));
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="testing" class="mt-5">Testing Node.js Applications</h3>

                        <h4>Setting up Testing Environment</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install testing dependencies
npm install --save-dev jest supertest nodemon

# Install additional testing libraries
npm install --save-dev @types/jest eslint-plugin-jest
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <pre><button class="copy-button">Copy</button><code class="language-json">{% raw %}
// package.json scripts
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Unit Testing</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
// userController.js
const User = require('../models/User');
const { ValidationError } = require('../utils/errors');

exports.createUser = async (userData) => {
    const { name, email } = userData;
    
    if (!name || !email) {
        throw new ValidationError('Name and email are required');
    }
    
    const existingUser = await User.findOne({ where: { email } });
    if (existingUser) {
        throw new ValidationError('User with this email already exists');
    }
    
    return await User.create(userData);
};

// userController.test.js
const { createUser } = require('../controllers/userController');
const User = require('../models/User');
const { ValidationError } = require('../utils/errors');

// Mock the User model
jest.mock('../models/User');

describe('User Controller', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    describe('createUser', () => {
        it('should create a user with valid data', async () => {
            const userData = { name: 'John Doe', email: 'john@example.com' };
            const mockUser = { id: 1, ...userData };
            
            User.findOne.mockResolvedValue(null);
            User.create.mockResolvedValue(mockUser);
            
            const result = await createUser(userData);
            
            expect(User.findOne).toHaveBeenCalledWith({ where: { email: userData.email } });
            expect(User.create).toHaveBeenCalledWith(userData);
            expect(result).toEqual(mockUser);
        });

        it('should throw ValidationError when name is missing', async () => {
            const userData = { email: 'john@example.com' };
            
            await expect(createUser(userData)).rejects.toThrow(ValidationError);
        });

        it('should throw ValidationError when email is missing', async () => {
            const userData = { name: 'John Doe' };
            
            await expect(createUser(userData)).rejects.toThrow(ValidationError);
        });

        it('should throw ValidationError when user already exists', async () => {
            const userData = { name: 'John Doe', email: 'john@example.com' };
            const existingUser = { id: 1, ...userData };
            
            User.findOne.mockResolvedValue(existingUser);
            
            await expect(createUser(userData)).rejects.toThrow(ValidationError);
        });
    });
});
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Integration Testing</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
// app.test.js
const request = require('supertest');
const app = require('../app');
const User = require('../models/User');

describe('User API', () => {
    beforeEach(async () => {
        await User.destroy({ where: {} });
    });

    afterAll(async () => {
        // Close database connection
        await User.sequelize.close();
    });

    describe('POST /api/users', () => {
        it('should create a new user', async () => {
            const userData = {
                name: 'John Doe',
                email: 'john@example.com',
                age: 30
            };

            const response = await request(app)
                .post('/api/users')
                .send(userData)
                .expect(201);

            expect(response.body).toHaveProperty('message');
            expect(response.body).toHaveProperty('user');
            expect(response.body.user.name).toBe(userData.name);
            expect(response.body.user.email).toBe(userData.email);
        });

        it('should return 400 for missing name', async () => {
            const userData = {
                email: 'john@example.com',
                age: 30
            };

            const response = await request(app)
                .post('/api/users')
                .send(userData)
                .expect(400);

            expect(response.body).toHaveProperty('error');
        });

        it('should return 409 for duplicate email', async () => {
            const userData = {
                name: 'John Doe',
                email: 'john@example.com',
                age: 30
            };

            // Create first user
            await request(app)
                .post('/api/users')
                .send(userData);

            // Try to create second user with same email
            const response = await request(app)
                .post('/api/users')
                .send(userData)
                .expect(409);

            expect(response.body).toHaveProperty('error');
        });
    });

    describe('GET /api/users', () => {
        beforeEach(async () => {
            // Create test users
            await User.bulkCreate([
                { name: 'User 1', email: 'user1@example.com' },
                { name: 'User 2', email: 'user2@example.com' },
                { name: 'User 3', email: 'user3@example.com' }
            ]);
        });

        it('should return all users', async () => {
            const response = await request(app)
                .get('/api/users')
                .expect(200);

            expect(response.body).toHaveProperty('users');
            expect(Array.isArray(response.body.users)).toBe(true);
            expect(response.body.users.length).toBe(3);
        });

        it('should support pagination', async () => {
            const response = await request(app)
                .get('/api/users?page=1&limit=2')
                .expect(200);

            expect(response.body.users.length).toBe(2);
            expect(response.body.pagination).toHaveProperty('page');
            expect(response.body.pagination).toHaveProperty('limit');
            expect(response.body.pagination).toHaveProperty('total');
        });
    });

    describe('GET /api/users/:id', () => {
        let testUser;

        beforeEach(async () => {
            testUser = await User.create({
                name: 'Test User',
                email: 'test@example.com'
            });
        });

        it('should return user by ID', async () => {
            const response = await request(app)
                .get(`/api/users/${testUser.id}`)
                .expect(200);

            expect(response.body.id).toBe(testUser.id);
            expect(response.body.name).toBe(testUser.name);
        });

        it('should return 404 for non-existent user', async () => {
            const response = await request(app)
                .get('/api/users/99999')
                .expect(404);

            expect(response.body).toHaveProperty('error');
        });
    });
});
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="performance" class="mt-5">Performance Optimization</h3>

                        <h4>Caching with Redis</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install Redis client
npm install redis
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const redis = require('redis');

// Create Redis client
const client = redis.createClient({
    host: process.env.REDIS_HOST || 'localhost',
    port: process.env.REDIS_PORT || 6379,
    password: process.env.REDIS_PASSWORD
});

client.on('error', (err) => {
    console.error('Redis Client Error', err);
});

client.on('connect', () => {
    console.log('Connected to Redis');
});

// Cache middleware
const cache = (duration = 300) => {
    return async (req, res, next) => {
        const key = req.originalUrl;
        
        try {
            // Try to get data from cache
            const cachedData = await client.get(key);
            
            if (cachedData) {
                return res.json(JSON.parse(cachedData));
            }
            
            // Override res.json to cache response
            const originalJson = res.json;
            res.json = function(data) {
                // Cache the response
                client.setex(key, duration, JSON.stringify(data));
                return originalJson.call(this, data);
            };
            
            next();
        } catch (error) {
            next();
        }
    };
};

// Usage in routes
app.get('/api/users', cache(600), async (req, res) => {
    try {
        const users = await User.findAll();
        res.json(users);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Cache helper functions
const cacheHelper = {
    async get(key) {
        try {
            const data = await client.get(key);
            return data ? JSON.parse(data) : null;
        } catch (error) {
            console.error('Cache get error:', error);
            return null;
        }
    },

    async set(key, data, duration = 300) {
        try {
            await client.setex(key, duration, JSON.stringify(data));
        } catch (error) {
            console.error('Cache set error:', error);
        }
    },

    async del(key) {
        try {
            await client.del(key);
        } catch (error) {
            console.error('Cache delete error:', error);
        }
    },

    async flush() {
        try {
            await client.flushall();
        } catch (error) {
            console.error('Cache flush error:', error);
        }
    }
};

module.exports = { cache, cacheHelper };
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Compression</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install compression middleware
npm install compression
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const compression = require('compression');

// Enable compression for all requests
app.use(compression());

// Custom compression options
app.use(compression({
    filter: (req, res) => {
        if (req.headers['x-no-compression']) {
            return false;
        }
        return compression.filter(req, res);
    },
    level: 6, // Compression level (1-9)
    threshold: 1024, // Only compress responses larger than 1KB
    windowBits: 15,
    memLevel: 8
}));

// Conditional compression
const shouldCompress = (req, res) => {
    if (req.headers['x-no-compression']) {
        return false;
    }
    return compression.filter(req, res);
};

app.use(compression({
    filter: shouldCompress,
    level: 6
}));
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Cluster Mode</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const cluster = require('cluster');
const os = require('os');
const express = require('express');

if (cluster.isMaster) {
    const numCPUs = os.cpus().length;
    
    console.log(`Master ${process.pid} is running`);
    
    // Fork workers
    for (let i = 0; i < numCPUs; i++) {
        cluster.fork();
    }
    
    cluster.on('exit', (worker, code, signal) => {
        console.log(`Worker ${worker.process.pid} died`);
        cluster.fork(); // Restart worker
    });
} else {
    const app = express();
    const PORT = process.env.PORT || 3000;
    
    app.get('/', (req, res) => {
        res.send(`Hello from Worker ${process.pid}`);
    });
    
    app.listen(PORT, () => {
        console.log(`Worker ${process.pid} started`);
    });
}

// Graceful shutdown
process.on('SIGTERM', () => {
    console.log('SIGTERM signal received: closing HTTP server');
    server.close(() => {
        console.log('HTTP server closed');
    });
});

process.on('SIGINT', () => {
    console.log('SIGINT signal received: closing HTTP server');
    server.close(() => {
        console.log('HTTP server closed');
    });
});
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="streams-buffers" class="mt-5">Streams and Buffers</h3>

                        <h4>Working with Streams</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const fs = require('fs');
const { Transform } = require('stream');

// Readable stream
const readableStream = fs.createReadStream('large-file.txt', {
    encoding: 'utf8',
    highWaterMark: 1024 // Buffer size
});

// Writable stream
const writableStream = fs.createWriteStream('output.txt');

// Pipe streams
readableStream.pipe(writableStream);

// Transform stream (uppercase)
const uppercaseStream = new Transform({
    transform(chunk, encoding, callback) {
        this.push(chunk.toString().toUpperCase());
        callback();
    }
});

// Chain streams
readableStream
    .pipe(uppercaseStream)
    .pipe(writableStream);

// Custom readable stream
const { Readable } = require('stream');

class CounterStream extends Readable {
    constructor(options) {
        super(options);
        this.max = 100;
        this.index = 0;
    }

    _read() {
        const i = this.index++;
        
        if (i > this.max) {
            this.push(null);
        } else {
            const buf = Buffer.from(`${i}\n`, 'utf8');
            this.push(buf);
        }
    }
}

const counterStream = new CounterStream();
counterStream.pipe(process.stdout);

// Custom writable stream
const { Writable } = require('stream');

class LoggerStream extends Writable {
    constructor(options) {
        super(options);
    }

    _write(chunk, encoding, callback) {
        console.log(chunk.toString().trim());
        callback();
    }
}

const loggerStream = new LoggerStream();
readableStream.pipe(loggerStream);

// Stream events
readableStream.on('data', (chunk) => {
    console.log('Received chunk:', chunk.length);
});

readableStream.on('end', () => {
    console.log('Stream ended');
});

readableStream.on('error', (err) => {
    console.error('Stream error:', err);
});

writableStream.on('finish', () => {
    console.log('Write completed');
});
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Buffer Operations</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
// Creating buffers
const buf1 = Buffer.from('Hello World');
const buf2 = Buffer.alloc(10);
const buf3 = Buffer.allocUnsafe(10);

// Buffer from array
const buf4 = Buffer.from([0x48, 0x65, 0x6c, 0x6c, 0x6f]);

// Writing to buffer
buf2.write('Hello');
console.log(buf2.toString()); // Hello

// Buffer operations
const buf = Buffer.from('Hello World');

// Get buffer length
console.log(buf.length); // 11

// Convert to JSON
console.log(buf.toJSON());

// Slice buffer (creates a new buffer)
const slice = buf.slice(0, 5);
console.log(slice.toString()); // Hello

// Copy buffer
const targetBuffer = Buffer.alloc(10);
buf.copy(targetBuffer, 0, 0, 5);
console.log(targetBuffer.toString()); // Hello

// Concatenate buffers
const buf1 = Buffer.from('Hello ');
const buf2 = Buffer.from('World');
const buf3 = Buffer.concat([buf1, buf2]);
console.log(buf3.toString()); // Hello World

// Buffer comparison
const bufA = Buffer.from('ABC');
const bufB = Buffer.from('ABC');
console.log(bufA.equals(bufB)); // true

// Buffer encoding/decoding
const string = 'Hello World';
const buffer = Buffer.from(string, 'utf8');
const decodedString = buffer.toString('utf8');

// Working with different encodings
const utf8Buffer = Buffer.from('Hello', 'utf8');
const base64Buffer = Buffer.from('Hello', 'base64');
const hexBuffer = Buffer.from('Hello', 'hex');

console.log(utf8Buffer.toString('utf8'));
console.log(base64Buffer.toString('base64'));
console.log(hexBuffer.toString('hex'));
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="best-practices" class="mt-5">Node.js Best Practices</h3>

                        <h4>Project Structure</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
// Recommended project structure
my-node-app/
 src/
    controllers/     # Route handlers
       authController.js
       userController.js
       index.js
    models/          # Database models
       User.js
       Post.js
       index.js
    routes/          # Route definitions
       auth.js
       users.js
       index.js
    middleware/      # Custom middleware
       auth.js
       validation.js
       index.js
    services/        # Business logic
       emailService.js
       paymentService.js
       index.js
    utils/           # Utility functions
       logger.js
       helpers.js
       index.js
    config/          # Configuration files
       database.js
       redis.js
       index.js
    app.js           # Express app setup
 tests/               # Test files
    unit/
    integration/
    fixtures/
 docs/                # Documentation
 logs/                # Log files
 .env                 # Environment variables
 .gitignore
 package.json
 server.js            # Application entry point
 README.md
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Environment Configuration</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
// config/index.js
require('dotenv').config();

const config = {
    development: {
        port: process.env.PORT || 3000,
        database: {
            host: process.env.DB_HOST || 'localhost',
            port: process.env.DB_PORT || 5432,
            name: process.env.DB_NAME || 'myapp_dev',
            username: process.env.DB_USER || 'postgres',
            password: process.env.DB_PASSWORD || 'password'
        },
        redis: {
            host: process.env.REDIS_HOST || 'localhost',
            port: process.env.REDIS_PORT || 6379,
            password: process.env.REDIS_PASSWORD
        },
        jwt: {
            secret: process.env.JWT_SECRET || 'your-secret-key',
            expiresIn: process.env.JWT_EXPIRES_IN || '24h'
        },
        cors: {
            origin: process.env.CORS_ORIGIN || 'http://localhost:3000'
        }
    },
    
    production: {
        port: process.env.PORT || 80,
        database: {
            host: process.env.DB_HOST,
            port: process.env.DB_PORT || 5432,
            name: process.env.DB_NAME,
            username: process.env.DB_USER,
            password: process.env.DB_PASSWORD
        },
        redis: {
            host: process.env.REDIS_HOST,
            port: process.env.REDIS_PORT || 6379,
            password: process.env.REDIS_PASSWORD
        },
        jwt: {
            secret: process.env.JWT_SECRET,
            expiresIn: process.env.JWT_EXPIRES_IN || '1h'
        },
        cors: {
            origin: process.env.CORS_ORIGIN || false
        }
    },
    
    test: {
        port: process.env.PORT || 3001,
        database: {
            host: process.env.DB_HOST || 'localhost',
            port: process.env.DB_PORT || 5432,
            name: process.env.DB_NAME || 'myapp_test',
            username: process.env.DB_USER || 'postgres',
            password: process.env.DB_PASSWORD || 'password'
        }
    }
};

const env = process.env.NODE_ENV || 'development';
module.exports = config[env];
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Logging</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install winston for logging
npm install winston winston-daily-rotate-file
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const winston = require('winston');
const DailyRotateFile = require('winston-daily-rotate-file');

// Create logger
const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
    ),
    defaultMeta: { service: 'user-service' },
    transports: [
        // Write all logs with level 'error' and below to error.log
        new DailyRotateFile({
            filename: 'logs/error-%DATE%.log',
            datePattern: 'YYYY-MM-DD',
            level: 'error'
        }),
        
        // Write all logs with level 'info' and below to combined.log
        new DailyRotateFile({
            filename: 'logs/combined-%DATE%.log',
            datePattern: 'YYYY-MM-DD'
        })
    ]
});

// If we're not in production, log to the console
if (process.env.NODE_ENV !== 'production') {
    logger.add(new winston.transports.Console({
        format: winston.format.simple()
    }));
}

// Custom logger methods
logger.logRequest = (req, res, next) => {
    const start = Date.now();
    
    res.on('finish', () => {
        const duration = Date.now() - start;
        logger.info('HTTP Request', {
            method: req.method,
            url: req.url,
            status: res.statusCode,
            duration: `${duration}ms`,
            ip: req.ip,
            userAgent: req.get('User-Agent')
        });
    });
    
    next();
};

// Error logging
logger.logError = (err, req) => {
    logger.error('Application Error', {
        message: err.message,
        stack: err.stack,
        url: req.url,
        method: req.method,
        ip: req.ip,
        userAgent: req.get('User-Agent')
    });
};

module.exports = logger;
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Security Best Practices</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss');

// Security headers
app.use(helmet());

// Rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100 // limit each IP to 100 requests per windowMs
});

app.use(limiter);

// Data sanitization
app.use(mongoSanitize());

// XSS protection
app.use((req, res, next) => {
    if (req.body) {
        Object.keys(req.body).forEach(key => {
            if (typeof req.body[key] === 'string') {
                req.body[key] = xss(req.body[key]);
            }
        });
    }
    next();
});

// Input validation
const { body, validationResult } = require('express-validator');

app.post('/api/users',
    [
        body('name').trim().isLength({ min: 2, max: 50 }).escape(),
        body('email').isEmail().normalizeEmail(),
        body('age').optional().isInt({ min: 0, max: 120 })
    ],
    (req, res) => {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ errors: errors.array() });
        }
        // Process request
    }
);

// CORS configuration
const corsOptions = {
    origin: process.env.ALLOWED_ORIGINS?.split(',') || 'http://localhost:3000',
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    credentials: true
};

app.use(cors(corsOptions));

// Hide server information
app.disable('x-powered-by');

// Content Security Policy
app.use(helmet.contentSecurityPolicy({
    directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"]
    }
}));
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="real-world-examples" class="mt-5">Real-World Examples</h3>

                        <h4>File Upload Service</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install multer for file uploads
npm install multer
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Configure multer for file uploads
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const uploadDir = 'uploads/';
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
    }
});

const upload = multer({
    storage: storage,
    limits: {
        fileSize: 5 * 1024 * 1024 // 5MB limit
    },
    fileFilter: (req, file, cb) => {
        const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx/;
        const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
        const mimetype = allowedTypes.test(file.mimetype);
        
        if (mimetype && extname) {
            return cb(null, true);
        } else {
            cb(new Error('Invalid file type'));
        }
    }
});

// Single file upload
app.post('/upload', upload.single('file'), (req, res) => {
    if (!req.file) {
        return res.status(400).json({ error: 'No file uploaded' });
    }
    
    res.json({
        message: 'File uploaded successfully',
        file: {
            filename: req.file.filename,
            originalname: req.file.originalname,
            size: req.file.size,
            mimetype: req.file.mimetype,
            path: req.file.path
        }
    });
});

// Multiple files upload
app.post('/upload-multiple', upload.array('files', 5), (req, res) => {
    if (!req.files || req.files.length === 0) {
        return res.status(400).json({ error: 'No files uploaded' });
    }
    
    const files = req.files.map(file => ({
        filename: file.filename,
        originalname: file.originalname,
        size: file.size,
        mimetype: file.mimetype,
        path: file.path
    }));
    
    res.json({
        message: 'Files uploaded successfully',
        files
    });
});

// Download file
app.get('/download/:filename', (req, res) => {
    const filename = req.params.filename;
    const filePath = path.join(__dirname, 'uploads', filename);
    
    if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'File not found' });
    }
    
    res.download(filePath, filename);
});

// Delete file
app.delete('/file/:filename', (req, res) => {
    const filename = req.params.filename;
    const filePath = path.join(__dirname, 'uploads', filename);
    
    if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'File not found' });
    }
    
    fs.unlinkSync(filePath);
    res.json({ message: 'File deleted successfully' });
});
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>Email Service</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install nodemailer
npm install nodemailer
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const nodemailer = require('nodemailer');

// Create transporter
const createTransporter = () => {
    return nodemailer.createTransporter({
        host: process.env.SMTP_HOST,
        port: process.env.SMTP_PORT || 587,
        secure: false, // true for 465, false for other ports
        auth: {
            user: process.env.SMTP_USER,
            pass: process.env.SMTP_PASS
        }
    });
};

// Send email
const sendEmail = async (options) => {
    try {
        const transporter = createTransporter();
        
        const mailOptions = {
            from: process.env.SMTP_FROM,
            to: options.to,
            subject: options.subject,
            text: options.text,
            html: options.html
        };
        
        const info = await transporter.sendMail(mailOptions);
        console.log('Email sent: ' + info.messageId);
        return info;
    } catch (error) {
        console.error('Error sending email:', error);
        throw error;
    }
};

// Email templates
const emailTemplates = {
    welcome: (name) => ({
        subject: 'Welcome to Our Service',
        html: `
            <h1>Welcome, ${name}!</h1>
            <p>Thank you for joining our service. We're excited to have you on board.</p>
            <p>Best regards,<br>The Team</p>
        `
    }),
    
    passwordReset: (name, resetLink) => ({
        subject: 'Password Reset Request',
        html: `
            <h1>Password Reset</h1>
            <p>Hi ${name},</p>
            <p>You requested a password reset. Click the link below to reset your password:</p>
            <a href="${resetLink}">Reset Password</a>
            <p>This link will expire in 1 hour.</p>
            <p>If you didn't request this, please ignore this email.</p>
        `
    }),
    
    orderConfirmation: (order) => ({
        subject: 'Order Confirmation',
        html: `
            <h1>Order Confirmation</h1>
            <p>Thank you for your order!</p>
            <p>Order ID: ${order.id}</p>
            <p>Total: $${order.total}</p>
            <p>We'll send you another email when your order ships.</p>
        `
    })
};

// Email service
const emailService = {
    async sendWelcomeEmail(userEmail, userName) {
        const template = emailTemplates.welcome(userName);
        return await sendEmail({
            to: userEmail,
            ...template
        });
    },
    
    async sendPasswordResetEmail(userEmail, userName, resetLink) {
        const template = emailTemplates.passwordReset(userName, resetLink);
        return await sendEmail({
            to: userEmail,
            ...template
        });
    },
    
    async sendOrderConfirmationEmail(userEmail, order) {
        const template = emailTemplates.orderConfirmation(order);
        return await sendEmail({
            to: userEmail,
            ...template
        });
    }
};

module.exports = { sendEmail, emailService };
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h4>WebSocket Chat Server</h4>
                        <pre><button class="copy-button">Copy</button><code class="language-bash">{% raw %}
# Install socket.io
npm install socket.io
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <pre><button class="copy-button">Copy</button><code class="language-javascript">{% raw %}
const http = require('http');
const socketIo = require('socket.io');
const express = require('express');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
    cors: {
        origin: process.env.CLIENT_URL || "http://localhost:3000",
        methods: ["GET", "POST"]
    }
});

// Store connected users
const users = new Map();

// Socket connection handling
io.on('connection', (socket) => {
    console.log('User connected:', socket.id);
    
    // Handle user joining
    socket.on('join', (userData) => {
        users.set(socket.id, {
            id: socket.id,
            name: userData.name,
            room: userData.room
        });
        
        socket.join(userData.room);
        
        // Notify others in the room
        socket.to(userData.room).emit('userJoined', {
            name: userData.name,
            id: socket.id
        });
        
        // Send current users in room
        const roomUsers = Array.from(users.values())
            .filter(user => user.room === userData.room);
        socket.emit('roomUsers', roomUsers);
    });
    
    // Handle chat messages
    socket.on('chatMessage', (messageData) => {
        const user = users.get(socket.id);
        if (user) {
            const message = {
                id: Date.now(),
                user: user.name,
                userId: socket.id,
                text: messageData.text,
                timestamp: new Date().toISOString()
            };
            
            // Broadcast to room
            io.to(user.room).emit('newMessage', message);
        }
    });
    
    // Handle typing indicators
    socket.on('typing', (isTyping) => {
        const user = users.get(socket.id);
        if (user) {
            socket.to(user.room).emit('userTyping', {
                userId: socket.id,
                userName: user.name,
                isTyping
            });
        }
    });
    
    // Handle disconnect
    socket.on('disconnect', () => {
        const user = users.get(socket.id);
        if (user) {
            users.delete(socket.id);
            
            // Notify others in the room
            socket.to(user.room).emit('userLeft', {
                name: user.name,
                id: socket.id
            });
        }
        
        console.log('User disconnected:', socket.id);
    });
});

// REST API for chat history
const chatHistory = [];

app.get('/api/chat/:room/history', (req, res) => {
    const { room } = req.params;
    const roomHistory = chatHistory.filter(msg => msg.room === room);
    res.json(roomHistory);
});

// Save messages to history
io.on('connection', (socket) => {
    socket.on('chatMessage', (messageData) => {
        const user = users.get(socket.id);
        if (user) {
            const message = {
                id: Date.now(),
                user: user.name,
                userId: socket.id,
                text: messageData.text,
                room: user.room,
                timestamp: new Date().toISOString()
            };
            
            // Save to history
            chatHistory.push(message);
            
            // Keep only last 1000 messages
            if (chatHistory.length > 1000) {
                chatHistory.splice(0, chatHistory.length - 1000);
            }
            
            // Broadcast to room
            io.to(user.room).emit('newMessage', message);
        }
    });
});

const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
    console.log(`Socket.IO server running on port ${PORT}`);
});
{% endraw %}</code><button class="copy-button">Copy</button></pre>

                        <h3 id="conclusion" class="mt-5">Conclusion</h3>
                        <p>This comprehensive Node.js documentation covers essential concepts from basics to advanced topics. Node.js provides a powerful platform for building scalable, high-performance server-side applications.</p>
                        <p>Key takeaways:</p>
                        <ul>
                            <li>Node.js uses an event-driven, non-blocking I/O model</li>
                            <li>Express.js simplifies building web applications and APIs</li>
                            <li>Proper error handling is crucial for robust applications</li>
                            <li>Security should be considered from the beginning</li>
                            <li>Performance optimization ensures scalability</li>
                            <li>Testing ensures reliability and maintainability</li>
                            <li>Following best practices leads to maintainable code</li>
                        </ul>
                        <p>Continue learning by building real-world applications, exploring the Node.js ecosystem, and staying engaged with the community. Happy coding!</p>

                        <div class="mt-5 text-center">
                            <a href="/practice" class="btn btn-primary btn-lg">Take Practice Test</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="animation-container-docs" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1;">
        </div>
    </section>

    <script>
        document.getElementById('search-input').addEventListener('input', function() {
            const query = this.value.toLowerCase();
            const content = document.getElementById('content');
            const elements = content.querySelectorAll('h2, h3, h4, p, pre');

            elements.forEach(element => {
                const text = element.textContent.toLowerCase();
                if (query === '' || text.includes(query)) {
                    element.style.display = '';
                } else {
                    element.style.display = 'none';
                }
            });
        });
    </script>
    <script>
        const copyButtons = document.querySelectorAll('.copy-button');
        copyButtons.forEach(button => {
            button.addEventListener('click', function() {
                const code = this.parentNode.querySelector('code').textContent;
                navigator.clipboard.writeText(code);
                this.textContent = 'Copied!';
                setTimeout(() => {
                    this.textContent = 'Copy';
                }, 2000);
            });
        });
    </script>
{% endblock %}